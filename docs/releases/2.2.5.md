# Release Notes: v2.2.5

**Release Date:** 2025-11-25
**Type:** Patch Release - Extends v2.2.4 Fix to push() Method

## üö® Critical Bug Fix: Environment Name Duplication in push()

### Issue

v2.2.4 fixed environment name duplication in `smartSync()` pull operations, but the same bug existed in `push()` method. This caused metadata keys to be duplicated when pushing secrets.

**User Evidence (v2.2.4):**
```bash
# In git repo "test_multihost"
lsh push

# ‚úÖ Push succeeds
# ‚ùå But metadata key is duplicated: test_multihost_test_multihost
# ‚ùå Instead of correct: test_multihost_
```

This caused:
- Incorrect metadata key generation
- Potential issues with multi-environment secret management
- Inconsistent naming between push and pull operations

### Root Cause

**Same pattern as v2.2.4, but in push() method:**

```typescript
// v2.2.4 (Partially Fixed - pull only)
async push(filePath: string, environment: string, ...): Promise<void> {
  // Line 247: Transform environment
  const effectiveEnv = getRepoAwareEnvironment(environment, this.gitInfo?.repoName);
  // effectiveEnv is now "test_multihost"

  // Line 286-288: Pass already-transformed environment to storage.push()
  const cid = await this.storage.push(
    secrets,
    effectiveEnv,  // ‚ùå Wrong! Already transformed
    this.encryptionKey,
    this.gitInfo?.repoName,
    this.gitInfo?.currentBranch
  );
}

// In ipfs-secrets-storage.ts
async push(secrets, environment, ...): Promise<string> {
  // Creates metadata key with getMetadataKey(gitRepo, environment)
  // If gitRepo exists, transforms AGAIN!
  // "test_multihost" -> "test_multihost_test_multihost" ‚ùå
}
```

**The Problem:**
1. `push()` transforms `''` ‚Üí `'test_multihost'` (correct)
2. `push()` passes transformed `effectiveEnv` to `storage.push()` (wrong!)
3. Storage layer transforms again when creating metadata key (broken!)

### The Solution (v2.2.5)

**Pass raw environment parameter to let storage layer handle transformation:**

```typescript
// v2.2.5 (Fixed)
async push(filePath: string, environment: string, ...): Promise<void> {
  const effectiveEnv = getRepoAwareEnvironment(environment, this.gitInfo?.repoName);
  // effectiveEnv is "test_multihost"

  // ‚úÖ Pass RAW environment, not effectiveEnv
  const cid = await this.storage.push(
    secrets,
    environment,  // Use raw environment, storage will apply repo-aware naming
    this.encryptionKey,
    this.gitInfo?.repoName,
    this.gitInfo?.currentBranch
  );
}

// In ipfs-secrets-storage.ts
async push(secrets, environment, ...): Promise<string> {
  // Creates metadata key with correct transformation
  const metadataKey = getMetadataKey(gitRepo, environment);
  // '' -> "test_multihost_" ‚úÖ (correct!)
}
```

### What This Fixes

**Complete Push Workflow (v2.2.5):**
```bash
# In git repo "test_multihost"
export LSH_SECRETS_KEY=abc123...
lsh push

# ‚úÖ Metadata key: test_multihost_  ‚Üê Correct!
# ‚úÖ Secrets pushed successfully!
# ‚úÖ Consistent with pull operations!
```

**Before v2.2.5:**
- ‚ùå Metadata key duplicated: `test_multihost_test_multihost`
- ‚ùå Inconsistent with pull operations
- ‚ùå Potential multi-environment conflicts

**After v2.2.5:**
- ‚úÖ Metadata key correct: `test_multihost_`
- ‚úÖ Consistent with pull operations (fixed in v2.2.4)
- ‚úÖ Reliable multi-environment support

## üìù Technical Details

### Files Changed

**`src/lib/secrets-manager.ts` (3 lines modified)**

**Line 288 (push - storage.push() call):**
```diff
  const cid = await this.storage.push(
    secrets,
-   effectiveEnv,
+   environment,  // Use raw environment, storage will apply repo-aware naming
    this.encryptionKey,
    this.gitInfo?.repoName,
    this.gitInfo?.currentBranch
  );
```

**Lines 249-254 (push - destructive change detection):**
```diff
- if (this.storage.exists(effectiveEnv, this.gitInfo?.repoName)) {
+ if (this.storage.exists(environment, this.gitInfo?.repoName)) {
    const existingSecrets = await this.storage.pull(
-     effectiveEnv,
+     environment,
      this.encryptionKey,
      this.gitInfo?.repoName
    );
```

### Implementation Details

**Consistent Pattern Across All Methods:**

```typescript
// ‚úÖ Correct Pattern (v2.2.5)
async push/pull/sync() {
  // Transform for local use only (logging, display)
  const effectiveEnv = getRepoAwareEnvironment(environment);

  // Pass RAW environment to all other methods
  await this.storage.push(secrets, environment, ...);  // ‚úÖ
  await this.storage.pull(environment, ...);           // ‚úÖ
  await this.storage.exists(environment, ...);         // ‚úÖ
}

// Each storage method applies transformation internally
// No double transformation!
```

**Why This Matters:**
- Storage layer is responsible for metadata key generation
- Storage layer has `gitRepo` context to apply repo-aware naming
- Passing pre-transformed environment bypasses this logic
- Results in double transformation: `repo_name` ‚Üí `repo_name_repo_name`

### Transformation Flow (Fixed)

```
User Input: environment = "" (empty in root .env)
    ‚Üì
push():
    effectiveEnv = getRepoAwareEnvironment("", "test_multihost") = "test_multihost"
    (local variable for display/logging only)
    ‚Üì
    Call: storage.push(secrets, "", ...)  ‚Üê Pass RAW environment
    ‚Üì
storage.push():
    metadataKey = getMetadataKey("test_multihost", "")
    ‚Üí getRepoAwareEnvironment("", "test_multihost") = "test_multihost"
    ‚Üí metadataKey = "test_multihost_" ‚úÖ Correct!
```

## üéØ Impact

### Before v2.2.5 (Broken)
```bash
cd ~/repos/test_multihost
lsh push

# ‚úÖ Secrets pushed
# ‚ùå Metadata key: test_multihost_test_multihost (duplicated!)

# Metadata inspection shows:
{
  "test_multihost_test_multihost": {  // ‚ùå Wrong key!
    "cid": "bafkrei...",
    "timestamp": "2025-11-25T..."
  }
}
```

### After v2.2.5 (Fixed)
```bash
cd ~/repos/test_multihost
lsh push

# ‚úÖ Secrets pushed
# ‚úÖ Metadata key: test_multihost_ (correct!)

# Metadata inspection shows:
{
  "test_multihost_": {  // ‚úÖ Correct key!
    "cid": "bafkrei...",
    "timestamp": "2025-11-25T..."
  }
}
```

## üì¶ Installation

```bash
# Upgrade to v2.2.5
npm update -g lsh-framework@2.2.5

# Verify
lsh --version  # Should show 2.2.5
```

## üîÑ Migration from v2.2.4

**Automatic Migration:**

When you upgrade to v2.2.5 and run `lsh push`, the correct metadata key will be created. Old duplicated keys will remain in metadata but won't be used.

**Optional Cleanup (Advanced Users Only):**

If you want to clean up old duplicated metadata keys:

```bash
# Backup metadata first!
cp ~/.lsh/secrets-metadata.json ~/.lsh/secrets-metadata.json.backup

# Edit ~/.lsh/secrets-metadata.json and remove entries with duplicated names
# Example: Remove "test_repo_test_repo" and keep "test_repo_"
```

**Most users don't need to do this** - the duplicated keys are harmless and will be ignored.

## ‚ö†Ô∏è Important Notes

### Completed Fix

v2.2.5 completes the environment naming fix started in v2.2.4:

- **v2.2.4**: Fixed `pull()` operations in `smartSync()`
- **v2.2.5**: Fixed `push()` operations and destructive change detection ‚Üê **This release**

Both push and pull now use consistent environment naming patterns.

### What Was Fixed
- ‚úÖ `lsh push` metadata key generation
- ‚úÖ Destructive change detection environment lookup
- ‚úÖ Consistency between push and pull operations

### What Wasn't Affected
- ‚úÖ Actual secret storage - Always worked correctly
- ‚úÖ Secret retrieval - Fixed in v2.2.4
- ‚úÖ Non-repo-aware environments - Always worked correctly

## üêõ Related Issues

This completes the environment naming fix series:
- **v2.0.0**: Introduced repo-aware environment naming
- **v2.2.3**: Bug - Environment name duplication in multiple methods
- **v2.2.4**: Fixed `smartSync()` pull operations
- **v2.2.5**: Fixed `push()` operations and destructive change detection ‚Üê **This release**

## üìä Test Results

**Build:** ‚úÖ Success
**CI:** ‚úÖ All tests passing (with test setup fix)
**Manual Test:** ‚úÖ Push metadata keys are correct

**Test Scenario:**
```bash
# Test push with repo-aware naming
cd /tmp/test_multihost
echo "SECRET_1=value1" > .env
export LSH_SECRETS_KEY=aaa...
lsh push

# Check metadata
cat ~/.lsh/secrets-metadata.json
# ‚úÖ Result: Key is "test_multihost_" (correct!)

# Test destructive change detection
echo "SECRET_1=" > .env  # Empty value
lsh push
# ‚úÖ Result: Detected destructive change, prompts for confirmation
```

## üîß Additional Fix: Test Environment Setup

This release also includes a CI fix (committed separately):

**Created `__tests__/setup.ts`:**
```typescript
// Disable Storacha in tests to prevent timeouts from network operations
process.env.LSH_STORACHA_ENABLED = 'false';
process.env.LSH_API_ENABLED = 'false';
```

**Modified `jest.config.js`:**
```javascript
setupFiles: ['<rootDir>/__tests__/setup.ts'],
```

This ensures CI tests run reliably without external network dependencies.

## üìà Full Changelog

**From v2.2.4 ‚Üí v2.2.5:**

### Fixed
- Environment name duplication in `push()` method
- Metadata key generation now uses correct environment names
- Destructive change detection uses raw environment parameter
- Consistency between push and pull operations

### Changed
- `push()` line 288: Use raw `environment` instead of `effectiveEnv` in storage.push call
- `push()` lines 249-254: Use raw `environment` in destructive change detection
- Both pull and push now follow the same pattern

### Added
- Test environment setup to disable external services in CI
- Jest setup file for consistent test configuration

### Technical
- All storage layer calls now receive raw environment parameter
- Storage layer handles repo-aware transformation internally
- Prevents double transformation throughout the codebase
- CI tests now run reliably without network timeouts

**GitHub**: https://github.com/gwicho38/lsh/compare/v2.2.4...v2.2.5

---

**Environment naming is now fully fixed!** ‚úÖ v2.2.5 ensures consistent, correct environment naming across all push and pull operations.
