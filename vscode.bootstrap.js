(function($global, $conn) {
'use strict';
const Type$Proto = function Type(conn, init) {
Object.defineProperties(this, {
'name': { value: function name() { return init.name; }, enumerable: true },
'$conn': { value: conn },
'$init': { value: init },
});
};
Type$Proto.prototype.toString = new Function('return this.name();');
Type$Proto.prototype.toJSON = Type$Proto.prototype.toString;
Type$Proto.prototype.toTypedJson = Type$Proto.prototype.toString;
Type$Proto.prototype.connection = new Function('return this.$conn;');
Type$Proto.prototype.typeSystem = new Function('return this.connection().typeSystem();');
function SimpleCache(type, field, dfltKey) {
this.type = type;
this.field = field;
this.entries = {};
this.dfltKey = dfltKey == null ? 'null' : String(dfltKey);
}
SimpleCache.prototype.key = function (key) {
return key == null ? this.dfltKey : String(key);
};
SimpleCache.prototype.keys = function () {
return Object.keys(this.entries);
};
SimpleCache.prototype.values = function () {
return this.keys().map(k => this.entries[k]);
};
SimpleCache.prototype.get = function (key, failIfMissing, impl, dontCacheNull) {
let keyStr = this.key(key);
let v = this.entries[keyStr];
if (!_hasOwnProperty(this.entries, keyStr)) {
v = impl.call(undefined);
if (v != null || !dontCacheNull) {
this.entries[keyStr] = v;
}
}
if (failIfMissing && v == null) {
throw new TypeError(`Missing "${keyStr}" for ${this.ownerName()}.`);
}
return v;
};
SimpleCache.prototype.put = function (key, value) {
const keyStr = this.key(key);
this.entries[keyStr] = value;
};
SimpleCache.prototype.putLambda = function (key, lambda) {
const keyStr = this.key(key);
const entries = this.entries;
function delayGet() {
let resolved = lambda.call(undefined);
Object.defineProperty(entries, keyStr, { value: resolved, enumerable: true, writable: true });
return resolved;
}
Object.defineProperty(this.entries, keyStr, { get: delayGet, enumerable: true, configurable: true });
};
SimpleCache.prototype.ownerName = function () {
let s = this.type;
if (this.field != null) {
s += '.' + this.field;
}
return s;
};
SimpleCache.prototype.toString = function () {
return '[object SimpleCache(' + this.ownerName() + ')]';
};
class Fail {
static ifMissing(v, failIfMissing, ...args) {
if (v == null && failIfMissing) {
if (typeof args[1] === 'function') {
args[1] = args[1]();
}
throw Err.missing(...args);
}
return v;
}
static ifMissingOrNull(failIfMissing, ...args) {
if (failIfMissing) {
if (typeof args[1] === 'function') {
args[1] = args[1]();
}
throw Err.missing(...args);
}
return null;
}
static ifInvalid(v, failIfInvalid, ...args) {
if (v == null && failIfInvalid) {
if (typeof args[1] === 'function') {
args[1] = args[1]();
}
throw Err.invalidValue(...args);
}
return v;
}
static ifInvalidOrNull(failIfInvalid, ...args) {
if (failIfInvalid) {
if (typeof args[1] === 'function') {
args[1] = args[1]();
}
throw Err.invalidValue(...args);
}
return null;
}
}
const Ctx = (function() {
let nodeId;
let state = C3.$ctx;
if (state == null) {
state = {
stack: [],
errorFrame: null,
nextId: 1,
bootstrapped: false,
};
Object.defineProperty(C3, '$ctx', { value: state });
}
class Ctx {
static call(action, type, method, thisArg, ...args) {
try {
if (state.stack.length == 0 && state.errorFrame) {
state.errorFrame = null;
}
Ctx.#enter(type, method, thisArg, args);
return Ctx.#exit(action.call(undefined, thisArg, args));
} catch (e) {
throw Ctx.#exitErr(e);
}
}
static #enter(type, method, thisArg, args) {
const id = 'js-' + state.nextId++;
const frame = { id, type, method, thisArg, args };
return state.stack.push(frame);
}
static #exit(val) {
const frame = state.stack.pop();
return val;
}
static #exitErr(e) {
const frame = state.stack.pop();
frame.error = e;
state.errorFrame = frame;
return e;
}
static actionForId(id, failIfMissing) {
let frame = state.stack.find(e => e.id === id);
if (frame == null) {
return Fail.ifMissing(null, failIfMissing, "action id", id);
}
return Ctx.#frameToAction(frame);
}
static currentAction() {
if (state.stack.length > 0) {
let frame = state.stack[state.stack.length - 1];
if (frame.action == null) {
frame.action = Ctx.#frameToAction(frame);
}
return frame.action;
}
}
static parentAction(id) {
let i = state.stack.findIndex(e => e.id === id);
if (i > 0) {
return Ctx.actionForId(state.stack[i - 1].id);
}
}
static get bootstrapped() {
return state.bootstrapped;
}
static set bootstrapped(v) {
if (v) {
state.bootstrapped = true;
}
}
static #frameToAction(frame) {
if (nodeId == null) {
nodeId = 'local-' + C3.context().env.name + '-' + C3.context().app.name + '-' +
C3.context().actionEngine.name.replace(/^js-/, '') + '-0001';
}
const inst = Action._instantiate(frame.id, frame.type, frame.method, { state: 'Running', nodeId });
Action.typeSystem()._setupInst(inst, Action);
return inst;
}
}
return Ctx;
})();
class If {
static empty(v, falseFunc) {
return Val.isEmpty(v) ? falseFunc() : null;
}
static notEmpty(v, ...args) {
if (args.length === 2) {
return !Val.isEmpty(v) ? args[0](v) : args[1]();
}
return !Val.isEmpty(v) ? args[0](v) : null;
}
static null_(v, dflt) {
return v != null ? v : dflt.call();
}
static notNull(i, ...args) {
if (args.length === 2) {
return i != null ? args[0](i) : args[1]();
}
return i != null ? args[0](i) : null;
}
}
function _isPlainObject(v) {
return v != null && typeof v === 'object' && v.constructor === Object;
}
function _hasOwnProperty(object, property) {
return Object.prototype.hasOwnProperty.call(object, property);
}
function _deepFreeze(obj) {
for (let name of Object.getOwnPropertyNames(obj)) {
let value = obj[name];
if (value && typeof value === 'object') {
_deepFreeze(value);
}
}
return Object.freeze(obj);
}
function _odv(obj, prop, v) {
Object.defineProperty(obj, prop, { value: v });
}
function _impl(obj, fn) {
Object.defineProperty(obj, '$impl', { value: fn });
}
$conn._registerType((function() {
const $init = _deepFreeze({
"type" : "TypeMeta",
"metadataPath" : "platform/src/remote/ServerConnection.c3typ",
"package" : "platform",
"packageSubPath" : "remote",
"name" : "ServerConnection",
"doc" : "A remote connection to a C3 server. This should be established by calling {@link Remote.connect connect} or\n{@link Remote.connectAsync connectAsync}.\n\n@see Remote",
"declaredInline" : true,
"declaredMixinRefTypes" : [ {
"name" : "Value"
} ],
"declaredFieldTypes" : [ {
"doc" : "The base URL to the server.",
"name" : "url",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Clean up any state associated with this connection.",
"name" : "close",
"valueType" : {
"type" : "MethodType",
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Create a request to be used on this connection.",
"name" : "request",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "method",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "HttpMethod"
}
}
}, {
"name" : "encodedPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Get an instance of the full type system that makes requests synchronously.",
"name" : "typeSystem",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeSystem"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Get an instance of the full type system that makes requests asynchronously.",
"name" : "asyncTypeSystem",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "AsyncTypeSystem"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Get an instance of the thin type system that makes requests synchronously.",
"name" : "thinTypeSystem",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ThinTypeSystem"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Get an instance of the thin type system that makes requests asynchronously.",
"name" : "asyncThinTypeSystem",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "AsyncThinTypeSystem"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Build a URL string for fetching the specified type's metadata. If the runtime is unspecified, it defaults to the\none used to initialize the connection.",
"name" : "metadataUrl",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "runtime",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Url"
}
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Build a URL string for calling the specified type method.",
"name" : "callUrl",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "action",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Url"
}
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Build a request instance usable for calling the specified type method. The type and method name are required to\nform the URL. The HTTP method will always be `POST`.\n\nIf any arguments are specified, the body of the request will be JSON and it will have the JSON-related\nheaders, including `Accept: application/json`. Otherwise, the request will have no body and `Accept: *\\/*`.\n\n@param type the name of the type on which to call the method\n@param action the name of the method to call\n@param args the arguments to pass, with `this` or the type name first\n@return the HTTP request to make this call\n\n@see #callUrl",
"name" : "callRequest",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "action",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "args",
"valueType" : {
"type" : "AnyType"
},
"varArgs" : true
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"annotationsJson" : [ {
"call" : [ {
"name" : "stayInEngine",
"value" : true
} ]
} ],
"doc" : "To cache metadata for types in given `typeNames`.",
"name" : "cacheTypes",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "typeNames",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"annotationsJson" : [ {
"call" : [ {
"name" : "stayInEngine",
"value" : true
} ]
} ],
"doc" : "Discard cached type metadata for the given type. When not provided an argument, discard all cached type metadata\non this connection. This is typically used in client SDKs to refresh cache for specific type or all types.\nNote that existing instances will still continue to use the old types, but references to types through this\nconnection itself will reload after this call.\n\nNote that there may still be higher-level caches, particularly in the {@link TypeSystemBase full type systems}.",
"name" : "clearTypeCache",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
} ],
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"annotationsJson" : [ {
"call" : [ {
"name" : "stayInEngine",
"value" : true
} ]
} ],
"doc" : "Returns true if the type meta for the type with given typeName is cached on this server connection, false otherwise.",
"name" : "cacheContainsType",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
} ],
"isWithType" : false,
"isObj" : false,
"isMutable" : false,
"isStateful" : false,
"isSingleton" : false,
"isDefaultInstance" : false,
"isAbstract" : false,
"hasEventStream" : false,
"isGeneric" : false,
"isNativeRemix" : false,
"hasVarBindings" : false,
"prototypeName" : "ServerConnection",
"hasSerNameFields" : false,
"annotations" : {
"type" : "Annotations"
},
"mixins" : [ "Value" ],
"referenceType" : {
"type" : "ReferenceType",
"name" : "ServerConnection"
},
"mixinsWithSourceCode" : {
"js-ide-vscode-client-node" : [ ]
},
"methods" : [ {
"type" : "Method",
"name" : "url",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "ServerConnection" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "ServerConnection"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "The base URL to the server.",
"name" : "url",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "url",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
},
"$nearestImplementedOn" : "ServerConnection"
}, {
"type" : "Method",
"name" : "close",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "ServerConnection" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "ServerConnection"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Clean up any state associated with this connection.",
"name" : "close",
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "close"
},
"$nearestImplementedOn" : "ServerConnection"
}, {
"type" : "Method",
"name" : "request",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "ServerConnection" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "ServerConnection"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Create a request to be used on this connection.",
"name" : "request",
"params" : [ {
"name" : "method",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "HttpMethod"
}
}
}, {
"name" : "encodedPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "request",
"params" : [ {
"name" : "method",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "HttpMethod"
}
}
}, {
"name" : "encodedPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest"
},
"paramNames" : [ "method", "encodedPath" ]
},
"$nearestImplementedOn" : "ServerConnection"
}, {
"type" : "Method",
"name" : "typeSystem",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeSystem"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "ServerConnection" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "ServerConnection"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get an instance of the full type system that makes requests synchronously.",
"name" : "typeSystem",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeSystem"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "typeSystem",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeSystem"
}
},
"$nearestImplementedOn" : "ServerConnection"
}, {
"type" : "Method",
"name" : "asyncTypeSystem",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "AsyncTypeSystem"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "ServerConnection" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "ServerConnection"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get an instance of the full type system that makes requests asynchronously.",
"name" : "asyncTypeSystem",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "AsyncTypeSystem"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "asyncTypeSystem",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "AsyncTypeSystem"
}
},
"$nearestImplementedOn" : "ServerConnection"
}, {
"type" : "Method",
"name" : "thinTypeSystem",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ThinTypeSystem"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "ServerConnection" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "ServerConnection"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get an instance of the thin type system that makes requests synchronously.",
"name" : "thinTypeSystem",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ThinTypeSystem"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "thinTypeSystem",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ThinTypeSystem"
}
},
"$nearestImplementedOn" : "ServerConnection"
}, {
"type" : "Method",
"name" : "asyncThinTypeSystem",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "AsyncThinTypeSystem"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "ServerConnection" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "ServerConnection"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get an instance of the thin type system that makes requests asynchronously.",
"name" : "asyncThinTypeSystem",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "AsyncThinTypeSystem"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "asyncThinTypeSystem",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "AsyncThinTypeSystem"
}
},
"$nearestImplementedOn" : "ServerConnection"
}, {
"type" : "Method",
"name" : "metadataUrl",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Url"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "ServerConnection" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "ServerConnection"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Build a URL string for fetching the specified type's metadata. If the runtime is unspecified, it defaults to the\none used to initialize the connection.",
"name" : "metadataUrl",
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "runtime",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Url"
}
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "metadataUrl",
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "runtime",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Url"
}
},
"paramNames" : [ "type", "runtime" ]
},
"$nearestImplementedOn" : "ServerConnection"
}, {
"type" : "Method",
"name" : "callUrl",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Url"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "ServerConnection" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "ServerConnection"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Build a URL string for calling the specified type method.",
"name" : "callUrl",
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "action",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Url"
}
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "callUrl",
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "action",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Url"
}
},
"paramNames" : [ "type", "action" ]
},
"$nearestImplementedOn" : "ServerConnection"
}, {
"type" : "Method",
"name" : "callRequest",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "ServerConnection" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "ServerConnection"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Build a request instance usable for calling the specified type method. The type and method name are required to\nform the URL. The HTTP method will always be `POST`.\n\nIf any arguments are specified, the body of the request will be JSON and it will have the JSON-related\nheaders, including `Accept: application/json`. Otherwise, the request will have no body and `Accept: *\\/*`.\n\n@param type the name of the type on which to call the method\n@param action the name of the method to call\n@param args the arguments to pass, with `this` or the type name first\n@return the HTTP request to make this call\n\n@see #callUrl",
"name" : "callRequest",
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "action",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "args",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "callRequest",
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "action",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "args",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest"
},
"paramNames" : [ "type", "action", "args" ]
},
"$nearestImplementedOn" : "ServerConnection"
}, {
"type" : "Method",
"name" : "cacheTypes",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "ServerConnection" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "ServerConnection"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"call" : [ {
"name" : "stayInEngine",
"value" : true
} ]
} ],
"doc" : "To cache metadata for types in given `typeNames`.",
"name" : "cacheTypes",
"params" : [ {
"name" : "typeNames",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"call" : [ {
"name" : "stayInEngine",
"value" : true
} ]
} ],
"name" : "cacheTypes",
"params" : [ {
"name" : "typeNames",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"paramNames" : [ "typeNames" ]
},
"$nearestImplementedOn" : "ServerConnection"
}, {
"type" : "Method",
"name" : "clearTypeCache",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "ServerConnection" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "ServerConnection"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"call" : [ {
"name" : "stayInEngine",
"value" : true
} ]
} ],
"doc" : "Discard cached type metadata for the given type. When not provided an argument, discard all cached type metadata\non this connection. This is typically used in client SDKs to refresh cache for specific type or all types.\nNote that existing instances will still continue to use the old types, but references to types through this\nconnection itself will reload after this call.\n\nNote that there may still be higher-level caches, particularly in the {@link TypeSystemBase full type systems}.",
"name" : "clearTypeCache",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
} ],
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"call" : [ {
"name" : "stayInEngine",
"value" : true
} ]
} ],
"name" : "clearTypeCache",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
} ],
"paramNames" : [ "typeName" ]
},
"$nearestImplementedOn" : "ServerConnection"
}, {
"type" : "Method",
"name" : "cacheContainsType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "ServerConnection" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "ServerConnection"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"call" : [ {
"name" : "stayInEngine",
"value" : true
} ]
} ],
"doc" : "Returns true if the type meta for the type with given typeName is cached on this server connection, false otherwise.",
"name" : "cacheContainsType",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"call" : [ {
"name" : "stayInEngine",
"value" : true
} ]
} ],
"name" : "cacheContainsType",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "typeName" ]
},
"$nearestImplementedOn" : "ServerConnection"
} ],
"hasSourceCode" : {
"js-ide-vscode-client-node" : true
},
"fieldTypes" : [ ]
});
const TYPESYS = '/typesys/8/';
function ServerConnection(url, authz, actionEngine) {
if (!actionEngine) {
actionEngine = (typeof window === 'object' || typeof importScripts === 'function') ? 'js-client-browser' : 'js-client-node';
}
Object.defineProperty(this, '$url', { value: url });
if (authz != null) {
Object.defineProperty(this, '$authz', { value: authz, configurable: true, writable: true });
}
Object.defineProperties(this, {
'$actionEngine': { value: actionEngine },
'$language': { value: 'en-US', configurable: true, writable: true },
'$requested': { value: new Set() },
'$async': { value: false, writable: true },
'$extraHeaders': { value: {}, writable: true },
'$debugger': { value: false, writable: true },
'$bootstrapTypes': { value: [], writable: true },
'$typeCache': { value: {}, configurable: true, writable: true },
'$syncThin': { value: undefined, configurable: true, writable: true },
'$asyncThin': { value: undefined, configurable: true, writable: true },
'$syncFull': { value: undefined, configurable: true, writable: true },
'$asyncFull': { value: undefined, configurable: true, writable: true },
'$forceLocalTypes': { value: [], writable: true },
'$noSourceMapPointer': { value: false, writable: true },
'$pkgRoots': { value: null, writable: true },
});
}
ServerConnection.prototype.profile = profile;
ServerConnection._formatProfile = formatProfile;
ServerConnection._logForProfile = logForProfile;
ServerConnection.prototype._registerType = _registerType;
ServerConnection.prototype.setBundle = setBundle;
ServerConnection.prototype._logHttpRequest = _logHttpRequest;
ServerConnection.prototype._bootstrap = _bootstrap;
ServerConnection.prototype._loadType = _loadType;
ServerConnection.prototype._prepareMetadata = _prepareMetadata;
ServerConnection.prototype._extraHeaders = _extraHeaders;
ServerConnection.prototype._debugger = _debugger;
ServerConnection.prototype._updateLocalTypes = _updateLocalTypes;
ServerConnection.prototype._defaultHeaders = _defaultHeaders;
function clearTypeCache(typeName) {
if (Val.isEmpty(typeName)) {
Object.defineProperty(this, '$typeCache', { value: {}, configurable: true, writable: true });
this.$bootstrapTypes = [];
} else {
delete this.$typeCache[typeName];
}
}
function cacheContainsType(typeName) {
return !Val.isEmpty(this.$typeCache[typeName]);
}
function url() {
return this.$url;
}
function close() {
['$syncThin', '$asyncThin', '$syncFull', '$asyncFull'].forEach((ts) => {
if (this[ts]) {
this[ts].clearCache();
if (typeof this[ts].clearImports == 'function') {
this[ts].clearImports();
}
this[ts] = undefined;
}
})
}
function request(method, path) {
let ServerRequest = this._loadType('ServerRequest', true);
let init = {
connection: this,
};
if (method != null) {
init.method = method;
}
var headers;
if (this.$authz) {
headers = new Map([['Authorization', this.$authz]]);
}
headers = _defaultHeaders(headers);
if (path != null && path !== '') {
if (/^https?:/.test(path)) {
init.url = path;
} else if (/^\//.test(path)) {
init.url = this.$url + path;
} else {
init.url = this.$url + '/' + path;
}
}
return ServerRequest.make(init).withHeaders(headers);
}
function thinTypeSystem() {
if (this.$syncThin == null) {
let ThinTypeSystem = this._bootstrap('ThinTypeSystem', 'THIN', false);
this.$syncThin = new ThinTypeSystem(this);
}
return this.$syncThin;
}
function asyncThinTypeSystem() {
if (this.$asyncThin == null) {
let AsyncThinTypeSystem = this._bootstrap('AsyncThinTypeSystem', 'THIN', true);
this.$asyncThin = new AsyncThinTypeSystem(this);
}
return this.$asyncThin;
}
function typeSystem() {
if (this.$syncFull == null) {
let TypeSystem = this._bootstrap('TypeSystem', 'FULL', false);
this.$syncFull = new TypeSystem(this);
}
return this.$syncFull;
}
function asyncTypeSystem() {
if (this.$asyncFull == null) {
let AsyncTypeSystem = this._bootstrap('AsyncTypeSystem', 'FULL', true);
this.$asyncFull = new AsyncTypeSystem(this);
}
return this.$asyncFull;
}
function metadataUrl(type, actionEngine) {
if (typeof type != 'string' || type === '') {
throw new Error(`Invalid value "${type}" for type name for metadata.`);
}
if (actionEngine == null || actionEngine === '') {
actionEngine = this.$actionEngine;
}
return this.url() + TYPESYS + encodeURIComponent(type + `.${actionEngine}.json`);
}
function callUrl(type, action) {
if (typeof type != 'string' || type === '') {
throw new Error(`Invalid value "${type}" for type name to call.`);
}
if (typeof action != 'string' || action === '') {
throw new Error('Invalid value "${action}" for action to call.');
}
type = _prototypeName(type);
return this.url() + '/api/8/' + encodeURIComponent(type) + '/' + encodeURIComponent(action);
}
function callRequest(type, action, ...args) {
let req = this.request("POST", this.callUrl(type, action));
if (args.length > 0) {
req = req.withJsonHeaders()
.withBodyString(JSON.stringify(args));
} else {
req = req.withHeader("Accept", "*/*");
}
return req;
}
function logForProfile(elapsed, info) {
if (!info) {
info = {
count: 1,
total: elapsed,
min: elapsed,
max: elapsed,
};
} else {
info.count++;
info.total += elapsed;
if (!isNaN(elapsed)) {
info.min = Math.min(info.min, elapsed);
info.max = Math.max(info.max, elapsed);
}
}
return info;
}
function formatProfile(data, columns, match, keyName) {
function pad(v, width, right) {
let s;
if (typeof v == 'number') {
s = isNaN(v) ? '' : v.toFixed();
} else {
s = String(v);
}
let p = '';
while (s.length + p.length < width) {
p += ' ';
}
return right ? p + s : s + p;
}
let urls = Object.keys(data);
urls.sort((a, b) => {
if (data[a].total > data[b].total)
return -1;
if (data[a].total < data[b].total)
return 1;
return a.localeCompare(b);
});
let other;
if (match) {
other = { count: 0, total: 0, unique: 0 };
let filtered = [];
urls.forEach(u => {
let matched;
if (typeof match == 'string') {
matched = u.indexOf(match) >= 0;
} else {
matched = match.test(u);
}
if (matched) {
filtered.push(u);
} else {
other.count += data[u].count;
other.total += data[u].total;
other.unique++;
}
});
if (other.unique === 0) {
other = undefined;
} else {
urls = filtered;
}
}
let maxUrl = urls.reduce((prev, u) => Math.max(prev, u.length), 10);
const numWid = 6;
let colLength = [maxUrl];
let table = pad(keyName || 'ID', maxUrl);
for (let i = 0; i < columns.length; i++) {
table += ' | ' + pad(Str.firstUpper(columns[i]), numWid, true);
colLength.push(numWid);
}
function line() {
table += '\n';
colLength.forEach((w, i) => {
if (i > 0) {
table += '-+-';
}
for (let j = 0; j < w; j++) {
table += '-';
}
});
}
line();
let count = 0, total = 0;
urls.forEach(u => {
let info = data[u];
table += '\n' + pad(u, maxUrl);
for (let i = 0; i < columns.length; i++) {
let c = columns[i];
let v = c === 'avg' ? info.total / info.count : info[c];
table += ' | ' + pad(v, numWid, true);
}
count += info.count;
total += info.total;
});
line();
let unique = urls.length;
if (other) {
table += '\n' + pad('(other)', maxUrl);
for (let i = 0; i < columns.length; i++) {
switch (columns[i]) {
case 'count':
case 'total':
table += ' | ' + pad(other[columns[i]], numWid, true);
break;
case 'avg':
table += ' | ' + pad(other.total / other.count, numWid, true);
break;
default:
table += ' | ' + pad('--', numWid, true);
}
}
count += other.count;
total += other.total;
unique += other.unique;
}
table += '\n' + pad('(all ' + unique + ')', maxUrl);
for (let i = 0; i < columns.length; i++) {
switch (columns[i]) {
case 'count':
table += ' | ' + pad(count, numWid, true);
break;
case 'total':
table += ' | ' + pad(total, numWid, true);
break;
case 'avg':
table += ' | ' + pad(total / count, numWid, true);
break;
default:
table += ' | ' + pad('--', numWid, true);
}
}
return table;
}
function profile(match, columns) {
if (this.$requests) {
if (Array.isArray(match)) {
columns = match;
match = null;
}
return formatProfile(this.$requests, columns || ['count', 'total', 'avg'], match, 'URL');
}
}
function setBundle(name) {
delete this.$bundle;
if (name != null) {
if (typeof name !== 'string' || !/^[\w-]+$/.test(name)) {
throw new Error(`Invalid value "${name}" for bundle name.`);
}
let bundle = _getBundle(this, name, false) || { name };
Object.defineProperty(this, '$bundle', { value: bundle, configurable: true, writable: true });
}
}
function _hasOwnProperty(object, property) {
return Object.prototype.hasOwnProperty.call(object, property);
}
function _bootstrap(name, tier, async) {
const url = `${TYPESYS}bootstrap.${this.$actionEngine}.js?tier=${tier}` + (async ? '&async' : '');
const req = _setupHttpRequest(this, url, 'GET', 'text/javascript');
const res = req.sendSync();
!req.$fake && this._logHttpRequest(req.url, res.elapsedMs);
if (res.statusCode !== 200) {
throw new Error(`Metadata request for bootstrap "${name}" failed (status ${res.statusCode}).`);
}
try {
let f = eval(this._prepareMetadata(res.responseText));
f.call(undefined, globalThis, this);
} catch (e) {
console.error(e);
e.message = `Implementation of bootstrap "${name}" is invalid JavaScript for actionEngine ${this.$actionEngine}: ${e.message}`;
throw e;
}
this.$bootstrapTypes = Object.keys(this.$typeCache);
this.$async = async;
return this.$typeCache[name];
}
function _loadType(name, failIfMissing) {
if (_hasOwnProperty(this.$typeCache, name))
return this.$typeCache[name];
this.$requested.add(name);
const url = TYPESYS + encodeURIComponent(name + `.${this.$actionEngine}.js`);
const spec = {
tier: 'FULL',
async: this.$async,
bootstrapped: this.$bootstrapTypes.length > 0,
x: [],
forceLocalTypes: this.$forceLocalTypes,
noSourceMapPointer: this.$noSourceMapPointer,
pkgRoots: this.$pkgRoots
};
Object.keys(this.$typeCache).forEach(loaded => {
if (loaded != name && !this.$bootstrapTypes.includes(loaded)) {
spec.x.push(loaded);
}
});
const _send = () => {
let getUrl = url;
Object.keys(spec).forEach((fieldName, fi) => {
const value = spec[fieldName];
if (Array.isArray(value) && value.length < 1 || value == null || value === false) return;
getUrl += (fi == 0 ? '?' : '&') + fieldName;
if (value === true) return;
if (Array.isArray(value)) {
value.forEach((e, ei) => {
if (ei > 0) getUrl += '&' + fieldName;
getUrl += '=' + encodeURIComponent(e);
});
} else {
getUrl += '=' + encodeURIComponent(value);
}
});
let req, res;
if (getUrl.length > this.$maxUrlLength || spec.pkgRoots) {
req = _setupHttpRequest(this, url, 'POST', 'text/javascript');
res = req.sendSync(JSON.stringify(spec));
!req.$fake && this._logHttpRequest(req.url, res.elapsedMs);
} else {
req = _setupHttpRequest(this, getUrl, 'GET', 'text/javascript');
res = req.sendSync();
!req.$fake && this._logHttpRequest(req.url, res.elapsedMs);
if (res.statusCode === 414) {
let max = getUrl.length - 1;
if (this.$maxUrlLength > 0) max = Math.min(this.$maxUrlLength, max);
Object.defineProperty(this, '$maxUrlLength', { value: max, configurable: true });
res = _send();
}
}
return res;
};
const res = _send();
if (res.statusCode === 404) {
if (failIfMissing) {
throw new Error('Unknown type "' + name + '".');
}
return;
}
if (res.statusCode !== 200) {
throw new Error(`Metadata request for type "${name}" failed (status ${res.statusCode}).`);
}
try {
let f = eval(this._prepareMetadata(res.responseText));
f.call(undefined, globalThis, this);
} catch (e) {
const msg = `Implementation of type "${name}" is invalid JavaScript for actionEngine ${this.$actionEngine}.`;
console.error(msg);
console.error(e);
try {
spec.failedSource = true;
const res2 = _send();
let f = eval(this._prepareMetadata(res2.responseText));
f.call(undefined, globalThis, this);
} catch (e2) {
if (failIfMissing) {
e2.message = `${msg} ${e2.message}`;
throw e2;
}
}
}
return this.$typeCache[name];
}
function _registerType(type) {
const name = type.name();
this.$typeCache[name] = type;
}
function _getMetas(conn, typeNames, callback) {
const req = new XMLHttpRequest();
req.open('POST', conn.url() + TYPESYS + "batch", false);
req.onload = function () {
if (req.status === 200) {
callback(req.responseText);
} else {
throw new Error('Request for type Metas failed with status code: ' + req.status);
}
}
req.send(typeNames.map(typeName => typeName + `.${conn.$actionEngine}.json`).join('; '));
}
function cacheTypes(typeNames) {
const callback = response => {
try {
let metas = JSON.parse(response);
typeNames.forEach(typeName => {
let meta = metas.filter(meta => meta.path === typeName + `.${conn.$actionEngine}.json` && meta.status === 200);
if (meta.length === 1) {
this._loadType(typeName, true);
}
})
} catch (e) {
throw new Error('Metadata response for types is invalid JSON.\n' + e);
}
}
_getMetas(this, typeNames, callback);
}
function _getBundle(conn, name, failIfMissing) {
let req = _setupHttpRequest(conn, TYPESYS + 'bundle/' + name + '.json');
let res = req.sendSync();
!req.$fake && conn._logHttpRequest(req.url, res.elapsedMs);
if (res.statusCode === 404 || res.statusCode === 204) {
if (failIfMissing) {
throw new Error('Unknown bundle "' + name + '".');
}
return;
}
if (res.statusCode !== 200) {
throw new Error('Metadata request for bundle "' + name + '" failed (status ' + res.statusCode + ').');
}
let init;
try {
init = JSON.parse(res.responseText);
} catch (e) {
throw new Error('Metadata response for bundle "' + name + '" is invalid JSON.\n' + e);
}
if (init == null || init.name !== name)
throw new Error('Metadata response for bundle "' + name + '" has unrecognized structure.');
return init;
}
function _setupHttpRequest(conn, path, method = 'GET', accept = 'application/json') {
const url = /^https?:/.test(path) ? path : conn.url() + path;
if (conn.$bundle && conn.$bundle.paths) {
const parsed = new URL(decodeURIComponent(url));
const findPath = parsed.href.substring(parsed.origin.length);
const cached = conn.$bundle.paths.find(p => p.path === findPath);
if (cached) {
return Object.freeze({
$fake: true,
method: method,
url,
headers: cached.headers,
sendSync: function () {
const responseText = cached.text || JSON.stringify(cached.json);
return new C3.$JsHttpResponse(responseText, null, cached.status, null);
},
sendAsync: function () {
return new Promise(function (resolve, reject) {
const responseText = cached.text || JSON.stringify(cached.json);
resolve(new C3.$JsHttpResponse(responseText, null, cached.status, null));
});
},
});
}
}
let headers = Object.fromEntries(_defaultHeaders(new Map(Object.entries({
...conn.$extraHeaders,
'Accept': accept,
'Authorization': conn.$authz,
'X-C3-Language': conn.$language
}))));
if (conn.$bundle != null) {
headers['X-C3-Bundle'] = conn.$bundle.name;
}
return new C3.$JsHttpRequest(method, url, headers, null, conn);
}
function _logHttpRequest(url, elapsed) {
let requests = this.$requests;
if (requests == null) {
requests = {};
Object.defineProperty(this, '$requests', { value: requests });
}
if (url.startsWith(this.url())) {
url = url.substring(this.url().length);
if (url === '') url = '/';
}
requests[url] = ServerConnection._logForProfile(elapsed, requests[url]);
}
function _prototypeName(name) {
if (name != null) {
return name.replace(/<.*>\./g, '.').replace(/<.*$/, '');
}
}
function _extraHeaders(object) {
this.$extraHeaders = {
...this.$extraHeaders,
...object,
};
}
function _debugger(on) {
this.$debugger = on || false;
}
function _updateLocalTypes (forceLocalTypes) {
this.$forceLocalTypes = forceLocalTypes;
}
function _prepareMetadata(s) {
if (this.$debugger) {
const os = require('os'), path = require('path'), fs = require('fs');
let sourceUrl, sourceMapUrl;
let m = /\/\/# *sourceURL=([^\n]+)\s*\/\/# *sourceMappingURL=([^\n]+)\s*$/.exec(s);
if (m) {
sourceUrl = m[1];
sourceMapUrl = m[2];
} else {
m = /\/\/# *sourceMappingURL=([^\n]+)\s*\/\/# *sourceURL=([^\n]+)\s*$/.exec(s);
if (m) {
sourceMapUrl = m[1];
sourceUrl = m[2];
}
}
if (sourceUrl && sourceMapUrl) {
try {
const file = decodeURIComponent(sourceUrl.replace(/^.*\//, '').trim() || 'metadata');
const sourceFile = path.join(os.tmpdir(), file);
const sourceMapFile = `${sourceFile}.map`;
const spec = { tier: 'FULL', forceLocalTypes: this.$forceLocalTypes, pkgRoots: this.$pkgRoots };
const req = _setupHttpRequest(this, sourceMapUrl, 'POST');
const res = req.sendSync(JSON.stringify(spec));
if (res.statusCode == 200) {
fs.writeFileSync(sourceMapFile, res.responseText);
}
const sourcePointer = '//# ' + 'sourceURL=' + sourceFile + '\n';
const sourceMapPointer = '//# ' + 'sourceMappingURL=' + sourceMapFile;
const s2 = s.substring(0, m.index) + sourcePointer + sourceMapPointer;
fs.writeFileSync(sourceFile, s2);
return s2;
} catch (e) {
}
}
}
return s;
}
function _defaultHeaders(headers) {
const header = 'Accept-Encoding';
const value = 'gzip, deflate, br';
if (!headers) {
return new Map([[header, value]]);
}
if (!Object.keys(headers).map(header => header.toLowerCase()).includes(header.toLowerCase())) {
headers.set(header, value);
}
return headers;
}
let $logger;
function log() {
if ($logger == null) {
$logger = C3.Logger.for($type.name());
}
return $logger;
};
const $type = ServerConnection;
$type.__proto__ = Type$Proto;
Type$Proto.call($type, $conn, $init);
const $proto = new (function ServerConnection() {});
Object.defineProperty($proto, '$conn', { value: $conn });
Object.defineProperties($type, {
$objProto: { value: $proto }
});
Object.defineProperty($type, Symbol.hasInstance, { value: function(inst) { return inst != null && inst.$c3inst && inst.$c3inst.meta().isA(this); } });
$type.prototype.url = url;
$proto.url = url;
$type.prototype.close = close;
$proto.close = close;
$type.prototype.cacheContainsType = cacheContainsType;
$proto.cacheContainsType = cacheContainsType;
$type.prototype.callRequest = callRequest;
$proto.callRequest = callRequest;
$type.prototype.typeSystem = typeSystem;
$proto.typeSystem = typeSystem;
$type.prototype.cacheTypes = cacheTypes;
$proto.cacheTypes = cacheTypes;
$type.prototype.metadataUrl = metadataUrl;
$proto.metadataUrl = metadataUrl;
$type.prototype.request = request;
$proto.request = request;
$type.prototype.asyncThinTypeSystem = asyncThinTypeSystem;
$proto.asyncThinTypeSystem = asyncThinTypeSystem;
$type.prototype.thinTypeSystem = thinTypeSystem;
$proto.thinTypeSystem = thinTypeSystem;
$type.prototype.clearTypeCache = clearTypeCache;
$proto.clearTypeCache = clearTypeCache;
$type.prototype.callUrl = callUrl;
$proto.callUrl = callUrl;
$type.prototype.asyncTypeSystem = asyncTypeSystem;
$proto.asyncTypeSystem = asyncTypeSystem;
$type._instantiate = function _instantiate(...args) {
let inst = Object.create(this.$objProto);
const r = ServerConnection.apply(inst, args);
if (typeof this.$setupInst === 'function') {
this.$setupInst(inst);
}
return r ?? inst;
};
$type.prototype.log = log;
$proto.log = log;
$proto.toJSON = function toJSON() { return '$value' in this ? this.$value : null; };
Object.freeze($type);
Object.freeze($proto);
return $type;
})());
$conn._registerType((function() {
const $init = _deepFreeze({
"type" : "TypeMeta",
"metadataPath" : "platform/src/remote/ServerRequest.c3typ",
"package" : "platform",
"packageSubPath" : "remote",
"name" : "ServerRequest",
"doc" : "All C3 remote requests go over HTTP. The only thing we add is connection from which the request was initiated since\ndifferent connections to different servers may have different metadata and even different implementations.",
"declaredInline" : true,
"declaredMixinRefTypes" : [ {
"name" : "HttpRequest"
} ],
"declaredFieldTypes" : [ {
"doc" : "The connection for which this request was instantiated.",
"name" : "connection",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerConnection"
}
} ],
"isWithType" : true,
"isObj" : true,
"isMutable" : false,
"isStateful" : false,
"isSingleton" : false,
"isDefaultInstance" : false,
"isAbstract" : false,
"hasEventStream" : false,
"isGeneric" : false,
"isNativeRemix" : false,
"hasVarBindings" : false,
"prototypeName" : "ServerRequest",
"typeSerName" : "type",
"hasSerNameFields" : false,
"annotations" : {
"type" : "Annotations"
},
"mixins" : [ "HttpRequest", "WithHttpHeaders", "Obj", "Serializable", "Value", "Fingerprintable", "MemoryMeasurable", "WithType", "Spec" ],
"referenceType" : {
"type" : "ReferenceType",
"name" : "ServerRequest"
},
"mixinsWithSourceCode" : {
"js-ide-vscode-client-node" : [ "HttpRequest", "WithHttpHeaders", "Obj", "WithType" ]
},
"fieldTypes" : [ {
"type" : "FieldType",
"doc" : "The internally used case-insensitive HTTP headers.",
"name" : "_headers",
"schemaSuffix" : "HDRS",
"private" : true,
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"isNumber" : false,
"instanceType" : "Map<string, [string]>"
}
}, {
"type" : "FieldType",
"doc" : "Parent HTTP client",
"name" : "client",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "ReferenceType",
"name" : "HttpClient",
"isNumber" : false,
"instanceType" : "HttpClient"
}
}, {
"type" : "FieldType",
"doc" : "The HTTP method to use.",
"name" : "method",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"isNumber" : false
}
}, {
"type" : "FieldType",
"doc" : "The URL to send the request.\nAlways required.",
"name" : "url",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Url"
},
"isNumber" : false
}
}, {
"type" : "FieldType",
"doc" : "The encoded body as binary for the request.",
"name" : "encodedBody",
"private" : true,
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "BinaryType",
"name" : "binary",
"isNumber" : false
}
}, {
"type" : "FieldType",
"doc" : "The connection for which this request was instantiated.",
"name" : "connection",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerConnection",
"isNumber" : false,
"instanceType" : "ServerConnection"
}
} ],
"methods" : [ {
"type" : "Method",
"name" : "toJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a JSON object.\n\n@return JSON object representation\n\n@see #fromJson",
"name" : "toJson",
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"name" : "toJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"name" : "toJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
} ]
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ]
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"paramNames" : [ "include", "exclude" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "toTypedJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a _typed_ JSON object.\n@param omitTopLevelType\n       Whether to leave out `type: {{ type of this serializable instance }}` as the **first** key-value pair in\n       the outer level of the produced json.\n@param runtime\n       If provided, then any special serialization logic required for the {@link ImplLanguage.Runtime} will be\n       performed. **NOTE** This argument is ignored if `typed` is not `true`. @see Ann.Ser\n\n\n@return JSON object representation\n\n@see #fromJson\n@see #toJson\n@see serdeser.c3doc\n@see JsonType",
"name" : "toTypedJson",
"params" : [ {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"name" : "toTypedJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"name" : "toTypedJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toTypedJson",
"params" : [ {
"name" : "omitTopLevelTypeOrIncludeOrInclude",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
} ]
}
}, {
"name" : "actionRequirementOrExcludeOrExclude",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
}, {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
} ]
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"paramNames" : [ "omitTopLevelTypeOrIncludeOrInclude", "actionRequirementOrExcludeOrExclude" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "toJsonString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toJsonString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized JSON string.\n\n@return JSON object as string",
"name" : "toJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "pretty" ]
}
}, {
"type" : "Method",
"name" : "toTypedJsonString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toTypedJsonString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"name" : "toTypedJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toTypedJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "pretty", "omitTopLevelType" ]
}
}, {
"type" : "Method",
"name" : "toJsString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toJsString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized JavaScript object literal.\n\n@return JavaScript object literal string",
"name" : "toJsString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJsString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "withType" ]
}
}, {
"type" : "Method",
"name" : "toXmlString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toXmlString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized XML string.\n\n@return XML element as string\n\n@see #fromXmlString",
"name" : "toXmlString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toXmlString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "withType" ]
}
}, {
"type" : "Method",
"name" : "serialize",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a string serialized representation of the object.\n\n@return string serialized object representation",
"name" : "serialize",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "serialize",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "contentType" ]
}
}, {
"type" : "Method",
"name" : "fromJson",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the JSON-based representation and reconstruct the corresponding object.\n\nfromJson is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which may be\na type that mixes in the type on which it is called). This means that the resulting object's type will be isA the\ncalled-on type, but perhaps not identical. In particular, `Obj.fromJson` works for any actual type and will return\nan instance of the correct type.\n\n@see #toJson",
"name" : "fromJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "ServerRequest",
"mixing" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "json" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fromJsonString",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the JSON-based representation and reconstruct the corresponding object.\n\nfromJsonString is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which may be\na type that mixes in the type on which it is called). This means that the resulting object's type will be isA the\ncalled-on type, but perhaps not identical. In particular, `Obj.fromJsonString` works for any actual type and will return\nan instance of the correct type.\n\n@see #toJsonString",
"name" : "fromJsonString",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "ServerRequest",
"mixing" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromJsonString",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "json" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fromXmlString",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the XML-based representation and reconstruct the corresponding object.\n\nfromXmlString is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which\nmay be a type that mixes in the type on which it is called). This means that the resulting object's type will be\nisA the called type, but perhaps not identical. In particular, `Obj.fromXmlString` works for any actual type and\nwill return an instance of the correct type.\n\n@see #toXmlString",
"name" : "fromXmlString",
"params" : [ {
"name" : "xml",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "ServerRequest",
"mixing" : true
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromXmlString",
"params" : [ {
"name" : "xml",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "xml" ]
}
}, {
"type" : "Method",
"name" : "deserialize",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load from contentType representation and reconstruct the corresponding object.\n\nfromString is be called on the type be deserialized and must reconstruct an object of the appropriate type\n(which may be a type that mixes in the type on which it is called). This means that the resulting object's type\nwill be isA the called-on type, but perhaps not identical. In particular, `fromString` works for any actual\ntype and will return an instance of the correct type.",
"name" : "deserialize",
"params" : [ {
"name" : "contentStr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "ServerRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "deserialize",
"params" : [ {
"name" : "contentStr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "contentStr", "contentType" ]
}
}, {
"type" : "Method",
"name" : "fingerprint",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Produce a checksum that can easily be compared to determine if two objects are definitely different. Note that\nthere is a slight possibility that two objects with the same fingerprint will actually differ.\n\nThe fingerprint recurses into field values, including collections and referenced Objs. The handling of nested\n{@link Identified identified} references (typically entities) differ in that _only_ the `id` field is included\nunless the allIdentifiedRefFields option is specified.\n\nIf the object graph may contain recursive embedded object references, the trackRecursiveRefs option may be used.\nHowever, maintaining the list of visited objects is costly so this should not be done unnecessarily.\n\n@param allIdentifiedRefFields\n          if `true`, fingerprint individual fields of persistable references, not just the `id`\n@param trackRecursiveRefs\n          if `true`, a set of referenced objects is maintained to avoid infinite recursion\n@param traversedRefs\n          only considered together with trackRecursiveRefs and if provided then all traversed references are\n          checked against and added to it\n@return integer fingerprint\n\n@see https://en.wikipedia.org/wiki/Fingerprint_(computing)",
"name" : "fingerprint",
"params" : [ {
"name" : "allIdentifiedRefFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "trackRecursiveRefs",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "traversedRefs",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<Obj>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fingerprint",
"params" : [ {
"name" : "allIdentifiedRefFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "trackRecursiveRefs",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "traversedRefs",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<Obj>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"paramNames" : [ "allIdentifiedRefFields", "trackRecursiveRefs", "traversedRefs" ]
}
}, {
"type" : "Method",
"name" : "retainedMemory",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Measures retained memory by this instance.\n\n@param deep\n       if true and this instance contains references to other objects also measures memory retained by those\n@param allMeasured\n       if set then will skip instances that are in the set and will add instances that where measured by this call\n@return retained memory in bytes for this instances",
"name" : "retainedMemory",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "allMeasured",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<any>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "retainedMemory",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "allMeasured",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<any>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"paramNames" : [ "deep", "allMeasured" ]
}
}, {
"type" : "Method",
"name" : "type",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "C3 Type of this instance.",
"name" : "type",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "type",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "replaceType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns new instance with all references to old type, including result of #type, replaced with new type. If new\ntype does not contain fields from old or field value types are not convertable then drops the field.\n\nThis method is used during live metadata update",
"name" : "replaceType",
"params" : [ {
"name" : "old",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "new",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "replaceType",
"params" : [ {
"name" : "old",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "new",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "old", "new" ]
}
}, {
"type" : "Method",
"name" : "super",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithType" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithType"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : " Produce a calling proxy that represents the content of all Obj type's mixins, but not the type itself. This is\n useful for redispatching **member** methods reimplemented on this type to a parent implementation:\n ```js\n function toString() {\n   return this.super().toString() + ', x=' + this.x;\n }\n ```\n\n ```py\n def toString(this):\n    return this.super().toString() + ', x=' + this.x\n```\n\n To redispatch **static** methods, see {@link Type#super}.\n\n Note that this not the same as the language-specific `super` keyword because it works through the type system and\n supports multiple mixins. It behaves like the Python `super()` function, except called on the instance rather than\n globally.\n\n If `mixin` is the implementing type in a client implementation, this will delegate the call to the server.\n This can be used to create a local implementation \"around\" the server implementation for additional caching or\n other local state management.\n\n @param mixin if specified, this mixin is used instead or an error is thrown\n @return \"super\" calling proxy for this object\n\n @see Type.super",
"name" : "super",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "ReferenceType",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "super",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "ReferenceType",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"paramNames" : [ "mixin" ]
},
"$nearestImplementedOn" : "WithType"
}, {
"type" : "Method",
"name" : "instanceOf",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Checks whether this Obj is an instance of the specified type by checking both its type and the mixin chain.\nThis is the most convenient way to ask \"is this type usable in a context requiring the other type?\"\n\n@return true if this instance is of this type or any of its mixins",
"name" : "instanceOf",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Checks whether this instance is an instance of the specified type by checking both its type and the mixin chain.\nThis is the most convenient way to ask \"is this type usable in a context requiring the other type?\"\n\n@return true if this instance is of this type or any of its mixins\n\n@see ValueType#isA",
"name" : "instanceOf",
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "instanceOf",
"params" : [ {
"name" : "typeNameOrType",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ]
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "typeNameOrType" ]
}
}, {
"type" : "Method",
"name" : "isEmptyObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether all the fields of this instance are empty.",
"name" : "isEmptyObj",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isEmptyObj",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "isSame",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether the specified instance represents exactly the same object as this instance.",
"name" : "isSame",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isSame",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "other" ]
}
}, {
"type" : "Method",
"name" : "fieldValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns value of the given field.\n\n@param field\n          Field to return the value for\n       defaultToEmpty\n          will return default empty value if field is missing",
"name" : "fieldValue",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Returns value of the given field type. Be sure to use the FieldType instance for the exact same type as the type of\nthe obj.\n\n@param field\n          Field to return the value for\n       defaultToEmpty\n          will return default empty value if field is missing\n@return value for the given field",
"name" : "fieldValue",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValue",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
} ]
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "field", "defaultToEmpty" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fieldValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldValue"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all non empty field values. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValues",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldValue"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValues",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldValue"
}
}
}
}, {
"type" : "Method",
"name" : "fieldValuesByOrdinal",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all field values including empty ones as array where value of a field is at corresponding ordinal position.\nUnless `skipTrailingEmpty` parameter is set and there are trailing empty values resulting array has same size as\n#dataFieldTypes",
"name" : "fieldValuesByOrdinal",
"params" : [ {
"name" : "skipTrailingEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesByOrdinal",
"params" : [ {
"name" : "skipTrailingEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"paramNames" : [ "skipTrailingEmpty" ]
}
}, {
"type" : "Method",
"name" : "fieldValuesByFieldType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all non empty field values by field type. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValuesByFieldType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesByFieldType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
}
}, {
"type" : "Method",
"name" : "fieldValuesByFieldName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all non empty field values by field name. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValuesByFieldName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesByFieldName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}
}, {
"type" : "Method",
"name" : "fieldNames",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all data field names including those whose values are empty. Array is ordered by field ordinal.",
"name" : "fieldNames",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldNames",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}
}, {
"type" : "Method",
"name" : "at",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return value of the field at provided ordinal\n\n@param ordinal\n        Integer ordinal of the field in the parent type\n@return value of field at ordinal",
"name" : "at",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "ordinal",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Return value for the given serialized expression\n\n@param expr\n        Serialized expression to obtain the value in the given Obj\n@param failIfNotValid\n        If set, fails if not a valid expression\n@return value obtained as a result of expression evaluation",
"name" : "at",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "expr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
}, {
"name" : "failIfNotValid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "at",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "ordinalOrExpr",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
}, {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
} ]
}
}, {
"name" : "failIfNotValid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "ordinalOrExpr", "failIfNotValid" ]
}
}, {
"type" : "Method",
"name" : "fieldValueAtPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Looks up a single field value by path from this Obj. Field paths are separated by dots so an expression like\n`fieldValueAtPath(\"location.elevation\")` is equivalent to `traverse(\"location\").fieldValue(\"elevation\")` except\nthat it also handles `null`. If path contains any collections then only first element will be traversed,\nunless the collection index is specified in the path.\n\nIf you need to traverse all elements of collection fields use #fieldValuesAtPath instead.\n\n@param fieldPath\n          field names separated by dots\n@param failIfNotFound\n          if true, an error will be thrown if the any of the field types aren't defined\n@param context\n          if an error is thrown, the context returned by calling the lambda will be incorporated\n@return the field or null",
"name" : "fieldValueAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValueAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "fieldPath", "failIfNotFound", "context" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fieldValuesAtPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "VarReferenceType",
"name" : "T"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Looks up all the fields by path from root Obj. If path contains any collections then result will contain all\ntraversals, unless the collection index is specified in the path.\n\n@param fieldPath\n          field names separated by dots\n@param failIfNotFound\n          if true, an error will be thrown if the any of the field types aren't defined\n@param context\n          if an error is thrown, the context returned by calling the lambda will be incorporated\n@return fields as a flat list\n\n@see #fieldValueAtPath",
"name" : "fieldValuesAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "VarReferenceType",
"name" : "T"
}
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "VarReferenceType",
"name" : "T"
}
},
"paramNames" : [ "fieldPath", "failIfNotFound", "context" ]
}
}, {
"type" : "Method",
"name" : "eachFieldValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Perform an action for each non-empty field of this object.\n\n@param action\n          lambda to apply",
"name" : "eachFieldValue",
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Perform an action for each field of this object. Fields are filtered based on provided `spec`.\n\n@param spec\n          which fields to include\n@param action\n          lambda to apply",
"name" : "eachFieldValue",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachFieldValue",
"params" : [ {
"name" : "actionOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"paramNames" : [ "actionOrSpec", "action" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "eachFieldValueWhile",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Perform an action for each field of this object while processing action returns `true`. Fields are filtered based\non provided `spec`.\n\n@param spec\n          which fields to include\n@param action\n          lambda to apply; stop if this `action` returns `false\n@return `true` if iteration was not aborted by lambda i.e. it saw all field values",
"name" : "eachFieldValueWhile",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachFieldValueWhile",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "spec", "action" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "eachRef",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type. For reference fields, this means\nthe field value if non-null and for collections of Obj, this means each element in the collection.\n\n@param action\n          function to be executed for each pair of field type and Obj instance",
"name" : "eachRef",
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type. For reference fields, this means\nthe field value if non-null and for collections of Obj, this means each element in the collection.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param action\n          function to be executed for each pair of field type and Obj instance",
"name" : "eachRef",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRef",
"params" : [ {
"name" : "actionOrIncludeEmpty",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
}, {
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ]
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"paramNames" : [ "actionOrIncludeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "eachRefWhile",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type while processing action returns\n`true`.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param action\n          function to be executed for each pair of field type and Obj instance; stops processing if return `false`\n@return `true` if iteration was not aborted by lambda i.e. it saw all refs",
"name" : "eachRefWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRefWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "includeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "eachRefRecursive",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type or in any child refs.",
"name" : "eachRefRecursive",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRefRecursive",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"paramNames" : [ "includeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "eachRefRecursiveWhile",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type or in any child refs. Continue while\nprocessing action returns `true`.",
"name" : "eachRefRecursiveWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRefRecursiveWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "includeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "mapFieldValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Result of this function call is a copy of current instance with all non empty fields replaced based on results of\nthe `mapper` invocation.\n\n@param action\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValues",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Result of this function call is a copy of current instance with all fields replaced based on results of the\n`mapper` invocation.\n\n@param spec\n          which fields to include\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValues",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapFieldValues",
"params" : [ {
"name" : "mapperOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "convertValueOrMapper",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ]
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "mapperOrSpec", "convertValueOrMapper", "convertValue" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapFieldValuesAsync",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing ServerRequest>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Result of this function call is a copy of current instance with all non empty fields replaced based on results of\nthe asynchronous `mapper` invocation.\n\n@param action\n          lambda to apply for every field value to produce a new value for that fields\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValuesAsync",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing ServerRequest>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Result of this function call is a copy of current instance with all fields replaced based on results of the\nasynchronous `mapper` invocation.\n\n@param spec\n          which fields to include\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValuesAsync",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing ServerRequest>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"name" : "mapFieldValuesAsync",
"params" : [ {
"name" : "mapperOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "convertValueOrMapper",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
} ]
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing ServerRequest>",
"hadDeclaredVarBindings" : true
},
"paramNames" : [ "mapperOrSpec", "convertValueOrMapper", "convertValue" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapFieldValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Result of this function call is a copy of current instance with specified field value replaced based on result of\nthe `mapper` invocation.\n@param field\n          field being mapped\n@param includeEmpty\n          if set, invokes mapper for fields with empty value\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValue",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapFieldValue",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "field", "includeEmpty", "mapper", "convertValue" ]
}
}, {
"type" : "Method",
"name" : "mapRefs",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Executes the specified lambda against each referenced Obj instance and replaces it's value with result of this\nlambda application.\n\nResult of this function call is a copy of current instance with all references replaced based on results of the\n`mapper` invocation.\n\n@param action\n          function to be executed for each pair of field type and Obj instance\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapRefs",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Executes the specified lambda against each referenced Obj instance and replaces it's value with result of this\nlambda application.\n\nResult of this function call is a copy of current instance with all references replaced based on results of the\n`mapper` invocation.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param mapper\n          function to be executed for each pair of field type and Obj instance for producing new reference value\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapRefs",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapRefs",
"params" : [ {
"name" : "mapperOrIncludeEmpty",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
}, {
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ]
}
}, {
"name" : "convertValueOrMapper",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
} ]
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "mapperOrIncludeEmpty", "convertValueOrMapper", "convertValue" ]
}
}, {
"type" : "Method",
"name" : "foldFieldValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Result of this function is application of `folder` lambda to every non empty field value where `accumulator`\nargument is a result of previous application. Initial value of `accumulator` will be `null`.\n\nThis function is useful for calculating aggregate values based on all current non empty field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Result of this function is application of `folder` lambda to every non empty field value where `accumulator`\nargument is a result of previous application. Initial value of `accumulator` is provided via `initial` parameter.\n\nThis function is useful for calculating aggregate values based on all current non empty field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "initial",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Result of this function is application of `folder` lambda to every field value where `accumulator` argument is a\nresult of previous application. Initial value of `accumulator` is provided via `initial` parameter.\n\nThis function is useful for calculating aggregate values based on all field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "initial",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}, {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "folderOrInitialOrInitial",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
}, {
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ]
}
}, {
"name" : "folderOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "folderOrInitialOrInitial", "folderOrSpec", "folder" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "evalProjection",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "AnyType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Evaluates given projection expression over this instance.",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
}, {
"name" : "resultType",
"valueType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "AnyType"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Evaluates given projection over this instance and returns results as json.",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "JsonType",
"name" : "json"
},
"inline" : true,
"member" : true,
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Evaluates given projection over this instance and returns results as instance of the new Obj.",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
}, {
"name" : "resultType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
},
"inline" : true,
"member" : true,
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
}, {
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
} ]
}
}, {
"name" : "resultTypeOrBindingsOrResultType",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
}, {
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
} ]
}
}, {
"name" : "bindingsOrOptionsOrBindings",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ]
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "AnyType"
},
"paramNames" : [ "projection", "resultTypeOrBindingsOrResultType", "bindingsOrOptionsOrBindings", "options" ]
}
}, {
"type" : "Method",
"name" : "validateObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjResult"
}
} ]
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Populates all missing default values and throws error if any constraint it violated.",
"name" : "validateObj",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Validate that the Obj fields are set according to all the required rules.",
"name" : "validateObj",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjSpec"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjResult"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "validateObj",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjSpec"
}
} ],
"returnType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjResult"
}
} ]
},
"paramNames" : [ "spec" ]
}
}, {
"type" : "Method",
"name" : "withField",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the provided field in it. The name must correspond to an existing field\ndefined on this type or its mixins. The value must be of the correct type if doNotConvert flag is true.\n\n@param field\n          name of the field\n@param value\n          of the field\n@param doNotConvert\n          if true, do not attempt to convert the value to match the field's type\n@return new Obj",
"name" : "withField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the provided field in it. The name must correspond to an existing field\ndefined on this type or its mixins. The value must be of the correct type if doNotConvert flag is true.\n\n@param field\n          the field\n@param value\n          of the field\n@param doNotConvert\n          if true, do not attempt to convert the value to match the field's type\n@return new Obj",
"name" : "withField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
} ]
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "field", "value", "doNotConvert" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "withFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the provided fields in it. The name must correspond to an existing fields\ndefined on this type or its mixins. The values must be of the correct type if doNotConvert flag is true.\n\n@param fields\n          map of fields name/values\n@param doNotConvert\n          if true, attempt to convert the values to match the fields' type\n@return new Obj",
"name" : "withFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "fields", "doNotConvert" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "withFieldAtPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj with the value at the specified path field. If the value is null, the final field is removed.\n\nImmutable objects may return the same instance if the field being set or removed does not actually represent a\nchange to the existing object.\n\n@param path\n          path to set value at\n@param value\n          value to set\n@param doNotConvert\n          if true, attempt to convert the values to match the fields' type\n@param doNotCreateIfMissing\n          true indicates that any empty reference along the path will not set the value\n@return new Obj",
"name" : "withFieldAtPath",
"params" : [ {
"name" : "path",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "doNotCreateIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withFieldAtPath",
"params" : [ {
"name" : "path",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "doNotCreateIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "path", "value", "doNotConvert", "doNotCreateIfMissing" ]
}
}, {
"type" : "Method",
"name" : "withoutField",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the field with the provided name.\n\nImmutable objects may return the same instance if the field being removed is not present in the existing object.\n\n@param name\n          of the field to remove\n@return new Obj with removed field",
"name" : "withoutField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the field with the provided field type.\n\nImmutable objects may return the same instance if the field being removed is not present in the existing object.\n\n@param field\n          of the field to remove\n@return new Obj with removed field",
"name" : "withoutField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
} ]
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "field" ]
}
}, {
"type" : "Method",
"name" : "withoutFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the fields with the provided names.\n\nImmutable objects may return the same instance if the fields being removed are not present in the existing object.\n\n@param names\n          of the fields to remove\n@return new Obj with removed fields",
"name" : "withoutFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "withoutFieldsByType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the fields with the provided field types. Be sure to use the FieldType instance for the\nexact same type as the type of the obj to respect the \"ordinal\" of the field type\n\nImmutable objects may return the same instance if the fields being removed are not present in the existing object.\n\n@param fields\n          of the fields to remove\n@return new Obj with removed fields",
"name" : "withoutFieldsByType",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutFieldsByType",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "withDefaults",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the default values (if defined) for all empty fields. This is implemented by\ncalling {@link FieldType#defaultValue defaultValue} for a field if it is not already set and\n{@link FieldType#hasDefault has a default}. It will also set {@see ValueType#initialValue initial values} for\nfields with required primitive ValueTypes (E.g. x: `!int32` -> will be set to 0). Note that this will not overwrite\nfields that have already been set.\n\n{@link FunctionParam#validateArg} will call {@link #withDefaults} for {@link Spec}s passed as arguments to methods.\nAs a result, methods should be implemented assuming all default values are set on `Spec` arguments.\n\n@param includeEmptyRefsWithDefaults\n          it `true` then missing / empty child references that have fields with defaults will also be instantiated\n@param defaultFields\n          If not empty, a list of default field paths to populate.  Any default fields not specified in the\n          array will be ignored.\n@return new Obj\n\n@see FieldType#defaultValueConst\n@see FieldType#defaultValue",
"name" : "withDefaults",
"params" : [ {
"name" : "includeEmptyRefsWithDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "defaultFields",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withDefaults",
"params" : [ {
"name" : "includeEmptyRefsWithDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "defaultFields",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "includeEmptyRefsWithDefaults", "defaultFields" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mergeObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Merges all the fields of the provided Obj into this instance, producing a new Obj of the same type as this one.\nIn case of conflicts, fields of other instance take precedence unless otherwise specified by the fieldPathMergeSpec\n\n@param other\n          object\n@param fieldPathMergeSpec\n          mapping of fields of the object to the respective merge annotations\n@return the new merged Obj",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "fieldPathMergeSpec",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Merges all the fields of the provided Obj into this instance, producing a new Obj of the same type as this one.\nIn case of conflicts, fields of other instance take precedence.\n\n@param other\n          object\n@param otherFieldsFilter\n          only fields of otherFieldsFilter type from other are merged into this obj.\n@return the new merged Obj",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "otherFieldsFilter",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Merge the fields of this Obj with corresponding fields on other Obj using the provided lambda. This means that\nfields that exist on other Obj and do not exist on this Obj will not be added to final Obj.\n@param deep\n       if set to true then traverse reference and collection fields and merge corresponding fields or elements with\n       the same key or index.",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 2
}, {
"type" : "MethodType",
"doc" : "Merge the fields of this Obj with corresponding fields on other Obj using the provided lambda. This means that\nfields that exist other Obj and do not exist on this Obj will not be added to final Obj or evaluated. Does not\ntraverse child reference and collection fields.",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 3
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "fieldPathMergeSpecOrOtherFieldsFilterOrDeepOrMerger",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ]
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "other", "fieldPathMergeSpecOrOtherFieldsFilterOrDeepOrMerger", "merger" ]
}
}, {
"type" : "Method",
"name" : "mergeAndExpandObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Create new Obj with all non-null fields of this and other. Fields that are non null in both apply merger lambda.\nFields that non null in only one of this and other will be in the resulting Obj without change.",
"name" : "mergeAndExpandObj",
"genericVars" : [ {
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeAndExpandObj",
"genericVars" : [ {
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"paramNames" : [ "other", "merger" ]
}
}, {
"type" : "Method",
"name" : "mergeJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "mergeJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "json" ]
}
}, {
"type" : "Method",
"name" : "mergeChildren",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Merge the obj references within the current obj\n@param deep\n       If set, traverses the reference fields within the obj as well for a deep merge\n@param objKey\n       lambda specifying how to obtain the key for the Obj while determining which Objs to merge\n@param filter\n       Field paths that need to be filtered from this merge\n@return Obj with child references merged",
"name" : "mergeChildren",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "objKey",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "child",
"valueType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "filter",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeChildren",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "objKey",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "child",
"valueType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "filter",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "deep", "objKey", "filter" ]
}
}, {
"type" : "Method",
"name" : "sumObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds the numeric Obj fields with the other Objs respective fields.\nIf deep is set it will traverse reference and collection fields and sum corresponding numeric fields in\nreferences with same name and collection elements at same index or key.",
"name" : "sumObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "sumObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "other", "deep" ]
}
}, {
"type" : "Method",
"name" : "singletonArray",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "ServerRequest",
"mixing" : true
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Build an array of the correct type with a single element which is this instance.\n\n@return new array instance with this as only element.",
"name" : "singletonArray",
"returnType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "ServerRequest",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"name" : "singletonArray",
"returnType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "ServerRequest",
"mixing" : true
}
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "array",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "ServerRequest",
"mixing" : true
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an array of instances of this type.",
"name" : "array",
"params" : [ {
"name" : "elements",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "ServerRequest",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "array",
"params" : [ {
"name" : "elements",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "ServerRequest",
"mixing" : true
}
},
"paramNames" : [ "elements" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "arrayBuilder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "ArrayBuilder<mixing ServerRequest>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an array of instances of this type.",
"name" : "arrayBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "ArrayBuilder<mixing ServerRequest>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "arrayBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "ArrayBuilder<mixing ServerRequest>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "singletonSet",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "SetType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "ServerRequest",
"mixing" : true
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Build an set of the correct type with a single element which is this instance.\n\n@return new array instance with this as only element.",
"name" : "singletonSet",
"returnType" : {
"type" : "SetType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "ServerRequest",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"name" : "singletonSet",
"returnType" : {
"type" : "SetType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "ServerRequest",
"mixing" : true
}
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "setBuilder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<mixing ServerRequest>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates a set of instances of this type.",
"name" : "setBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<mixing ServerRequest>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "setBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<mixing ServerRequest>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapBuilder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<string, mixing ServerRequest>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Create a map of string to elements of this type.",
"name" : "mapBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<string, mixing ServerRequest>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<string, mixing ServerRequest>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapBuilderOf",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<any, mixing ServerRequest>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Create a map with the given key type and elements of this type.",
"name" : "mapBuilderOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<any, mixing ServerRequest>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapBuilderOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<any, mixing ServerRequest>",
"hadDeclaredVarBindings" : true
},
"paramNames" : [ "keyType" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "myReferenceType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myReferenceType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myReferenceType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
}
}
}, {
"type" : "Method",
"name" : "myMapTypeOf",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myMapTypeOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myMapTypeOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"paramNames" : [ "keyType" ]
}
}, {
"type" : "Method",
"name" : "myMapType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myMapType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myMapType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
}
}
}, {
"type" : "Method",
"name" : "myArrayType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myArrayType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myArrayType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
}
}
}, {
"type" : "Method",
"name" : "mySetType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "mySetType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mySetType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
}
}
}, {
"type" : "Method",
"name" : "myStreamType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myStreamType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myStreamType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
}
}
}, {
"type" : "Method",
"name" : "toBuilder",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing ServerRequest>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return new ObjBuilder with initial state set to fields of this instance.",
"name" : "toBuilder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing ServerRequest>",
"hadDeclaredVarBindings" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toBuilder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing ServerRequest>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "builder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing ServerRequest>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return new ObjBuilder of this instance.",
"name" : "builder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing ServerRequest>",
"hadDeclaredVarBindings" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "builder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing ServerRequest>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fromFields",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type from provided fields\n@param fields\n           Fields to construct the instance of the obj with\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0) populated\n\n@see withDefaults",
"name" : "fromFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "fields", "withDefaults" ]
}
}, {
"type" : "Method",
"name" : "make",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type with no non-default field values unless explicitly specified by passing param true\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0)\n           populated\n\n@see withDefaults",
"name" : "make",
"params" : [ {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Construct an instance from provided fields\n@param fields\n           Fields (in the format <field_name, value>) to construct an instance of the obj. Note that \"type\" as a\n           field_name will be considered as the actual Obj's type, e.g. Obj.make({\"type\": \"Panda\"}) is equivalent\n           to Panda.make()\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32\n           -> 0) populated. Passing an empty value for a field will result in the default field value being set if\n           the field does not {@link ValueModifier#PRESERVES_EMPTY preserve empty} and {@link FieldType#hasDefault\n           has a default value}.\n\n\n@see fromFields\n@see beforeMake\n@see afterMake\n@see withDefaults",
"name" : "make",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : " Construct an instance of this type from provided fields. Note it is more efficient to use #fromFields and other overloads\n\n ```js\n User.make({\n   email: 'joe@smith.com',\n   realName: 'Joe Smith'\n })\n\n Obj.make({\n   type: 'User',\n   email: 'joe@smith.com',\n   realName: 'Joe Smith'\n })\n ```\n\n ```py\n c3.User.make({\n   \"email\": 'joe@smith.com',\n   \"realName\": 'Joe Smith'\n })\n\n c3.Obj.make({\n   \"type\": 'User',\n   \"email\": 'joe@smith.com',\n   \"realName\": 'Joe Smith'\n })\n\n c3.User(email='joe@smith.com', realName='Joe Smith')\n\n c3.Obj(type='User', email='joe@smith.com', realName='Joe Smith')\n```\n\n Note that this is **not** the same as the [serialization format](serdeser.c3doc). This is a convenient way to\n specify fields and values in the \"JSON like\" form supported by each language, but the usual serialization rules,\n such as {@link Ann.Ser} do not apply.\n @param fields\n            Fields to construct the instance of the obj with\n @param withDefaults\n            If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0) populated\n\n @see fromFields\n @see beforeMake\n @see afterMake\n @see withDefaults",
"name" : "make",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "make",
"params" : [ {
"name" : "withDefaultsOrFieldsOrFields",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "withDefaultsOrFieldsOrFields", "withDefaults" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "remake",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type from provided instance of a subtype or a \"duck type\".",
"name" : "remake",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "failIfExtraOrInvalidFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "remake",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "failIfExtraOrInvalidFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "other", "failIfExtraOrInvalidFields" ]
}
}, {
"type" : "Method",
"name" : "remakeAs",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an obj of the new type with all fields that exist on the original obj that are defined in the new type\nconverted and copied to the new obj instance. Note, that checking assignability and conversion of field values\ncould be costly if types have different value types for same fields.\n\n@param type\n        Type of new obj to return\n@return new obj of the requested type with all fields present in the original obj that are defined in the new type\n        converted and copied to it",
"name" : "remakeAs",
"genericVars" : [ {
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "remakeAs",
"genericVars" : [ {
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"paramNames" : [ "type" ]
}
}, {
"type" : "Method",
"name" : "beforeMake",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : true,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : false,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Optional override that will be called every time instance of this type is created.\n\n\nNote that it introduces additional overhead so should only be implemented for low volume data.",
"name" : "beforeMake",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"private" : true,
"optional" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "beforeMake",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "afterMake",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Optional override that will be called after every instance creation.\n\nNote that it introduces additional overhead so should only be implemented for low volume data.",
"name" : "afterMake",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "afterMake",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
}
}
}, {
"type" : "Method",
"name" : "cachedEmptyInst",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an empty inst using `MyType.make()` and caches it. Avoid recreating multiple copies of the spec for\nevery action dispatch. The cached inst can also be used for comparing whether the object is an empty or not\nWill only create empty instance for immutable Obj e.g. if an Obj is Mutable, this method will throw an error\n\n@see ValueType#defaultEmptyValue",
"name" : "cachedEmptyInst",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "cachedEmptyInst",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
}
}
}, {
"type" : "Method",
"name" : "toData",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Data"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Represent the current obj instance as {@link Data}",
"name" : "toData",
"returnType" : {
"type" : "ReferenceType",
"name" : "Data"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toData",
"returnType" : {
"type" : "ReferenceType",
"name" : "Data"
}
}
}, {
"type" : "Method",
"name" : "header",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns the header value for a header containing a single value.\n\n@param @required name\n          The header name, case insensitive\n@param dflt\n          The default value to return if the header does not exist\n@return The header value, or values concatenated together by ', ' if multiple, or dflt if not found.",
"name" : "header",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "dflt",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "header",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "dflt",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "name", "dflt" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "headers",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns the header values for a header containing potentially multiple values.\n\n@param @required name\n          the header name, case insensitive\n@return The header values array if header is found, else empty array.",
"name" : "headers",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "headers",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"paramNames" : [ "name" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "allHeaders",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns the headers map with the lower-case header and list of values",
"name" : "allHeaders",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "allHeaders",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "allHeadersMerged",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns headers map with keys of the lower-case header and value the result of the predicate. If predicate is not\nprovided, it will combine all headers with a \", \" except it will skip the set-cookie header if its present.\n\n@param merger\n          the optional function used to turn the array of header values to a string value. If the predicate returns\n          an empty value, it will not be added to the output.\n@return The headers map with keys of the lower-case header and value the result of the predicate",
"name" : "allHeadersMerged",
"params" : [ {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "header",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"name" : "values",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "allHeadersMerged",
"params" : [ {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "header",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"name" : "values",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"paramNames" : [ "merger" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "findFirstHeaderValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns the first header value satisfied by the given predicate.\n\n@param name\n          the header name (case-insensitive)\n@param predicate\n          the condition used to find the header value. If null the first header value found will be used\n@return The first matching header value for name or null if not found.",
"name" : "findFirstHeaderValue",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "predicate",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "v",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "findFirstHeaderValue",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "predicate",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "v",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "name", "predicate" ]
}
}, {
"type" : "Method",
"name" : "findAllHeaderValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns the header values satisfied by the given predicate.\n\n@param name\n          the header name (case-insensitive)\n@param predicate\n          the condition used to find the header values. If null the all header values for name will be returned\n@return All matching header values for name or null if not found.",
"name" : "findAllHeaderValues",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "predicate",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "v",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "findAllHeaderValues",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "predicate",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "v",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"paramNames" : [ "name", "predicate" ]
}
}, {
"type" : "Method",
"name" : "contentType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "The content type for these headers.",
"name" : "contentType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "contentType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "contentEncoding",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "The content encoding for these headers.",
"name" : "contentEncoding",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "contentEncoding",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "cookieValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Gets the cookie value from Http headers by a given cookie key.\n\n@param key\n          cookie key\n@return The cookie value or null if not found.",
"name" : "cookieValue",
"params" : [ {
"name" : "key",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "cookieValue",
"params" : [ {
"name" : "key",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "key" ]
}
}, {
"type" : "Method",
"name" : "replaceHeader",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Sets the header to (only) the specified value. This will wipe out any prior setting of this header, replacing it\nwith just this value. This is useful to _change_ a header value, instead of adding another value.\n\n@param name\n          header name (case-insensitive)\n@param value\n          replacement header value\n@return The new {@link WithHttpHeaders} object with name and value applied\n\n@see #withHeader\n@see #withoutHeader",
"name" : "replaceHeader",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "replaceHeader",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "name", "value" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withHeader",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds a header value into the existing headers. If called multiple times with the same header name, all values\nwill be added in the order they were called with duplicates removed.\n\n@param name\n          header name (case-insensitive)\n@param value\n          additional header value\n@return The new {@link WithHttpHeaders} object with name and value applied\n\n@see #replaceHeader\n@see #withoutHeader",
"name" : "withHeader",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withHeader",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "name", "value" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withoutHeader",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Removes all values from the existing header.\n\n@param name\n          header name (case-insensitive)\n@return The new {@link WithHttpHeaders} object with header removed\n\n@see #withHeader\n@see #replaceHeader",
"name" : "withoutHeader",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutHeader",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "name" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withHeaders",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Puts multiple header values into the existing headers. If the map has keys that collide in a case-insensitive way,\nthe order of the values may not be preserved, but duplicate values will be removed.\n\n@param headers\n          a map where the key is a header and value is one or many string values for that header.\n@return A modified {@link WithHttpHeaders} object with the headers applied",
"name" : "withHeaders",
"params" : [ {
"name" : "headers",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ]
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withHeaders",
"params" : [ {
"name" : "headers",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ]
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "headers" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withJsonHeaders",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds \"Accept\" and \"ContentType\" headers as \"application/json\".",
"name" : "withJsonHeaders",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withJsonHeaders",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
}
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withActionEngineHeader",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Add a \"X-C3-Action-Engine\" header appropriate to the current execution environment.",
"name" : "withActionEngineHeader",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withActionEngineHeader",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
}
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withAuthHeader",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Add Authorization header to this HTTP header.",
"name" : "withAuthHeader",
"params" : [ {
"name" : "auth",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Authorization"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withAuthHeader",
"params" : [ {
"name" : "auth",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Authorization"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "auth" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withContentType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds a content type to this HTTP header. Will silently not add contentType if it is empty.",
"name" : "withContentType",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withContentType",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "contentType" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withContentEncoding",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds a content encoding type to this HTTP header. Will silently not add contentEncoding if it is empty.",
"name" : "withContentEncoding",
"params" : [ {
"name" : "contentEncoding",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentEncoding"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withContentEncoding",
"params" : [ {
"name" : "contentEncoding",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentEncoding"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "contentEncoding" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "body",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : true,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Content"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "The entity body as {@link Content} for the request. Required for POST and PUT; ignored by GET.\nFor usage examples, see {@link HttpRequest.c3poly.md#body}.",
"name" : "body",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Content"
},
"cached" : true,
"inline" : true,
"member" : true,
"property" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "body",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Content"
}
}
}, {
"type" : "Method",
"name" : "hasBody",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "HttpRequest" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "HttpRequest"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Checks body is present.",
"name" : "hasBody",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasBody",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
},
"$nearestImplementedOn" : "HttpRequest"
}, {
"type" : "Method",
"name" : "readBodyString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "HttpRequest" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "HttpRequest"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Read the entity body as String.",
"name" : "readBodyString",
"params" : [ {
"name" : "failIfNotText",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "readBodyString",
"params" : [ {
"name" : "failIfNotText",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
},
"paramNames" : [ "failIfNotText" ]
},
"$nearestImplementedOn" : "HttpRequest"
}, {
"type" : "Method",
"name" : "withBody",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "HttpRequest" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "HttpRequest"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds a body from the {@link Content} to this HTTP request. This sets the #encodedBody field as well as the\n`Content-Type` and `Content-Encoding` headers from the values in the content.",
"name" : "withBody",
"params" : [ {
"name" : "body",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Content"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Adds a body from the binary value, content type, and encoding. This sets the #encodedBody field as well as the\n`Content-Type` and `Content-Encoding` headers to the specified values.",
"name" : "withBody",
"params" : [ {
"name" : "encodedBody",
"valueType" : {
"type" : "BinaryType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "binary"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
}, {
"name" : "contentEncoding",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "ContentEncoding"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withBody",
"params" : [ {
"name" : "bodyOrEncodedBody",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Content"
}
}, {
"valueType" : {
"type" : "BinaryType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "binary"
}
} ]
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
}, {
"name" : "contentEncoding",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "ContentEncoding"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "bodyOrEncodedBody", "contentType", "contentEncoding" ]
},
"$nearestImplementedOn" : "HttpRequest"
}, {
"type" : "Method",
"name" : "withBodyString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "HttpRequest" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "HttpRequest"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds a body from the string value, content type, and encoding. This sets the #encodedBody field as well as the\n`Content-Type` and `Content-Encoding` headers to the specified values.",
"name" : "withBodyString",
"params" : [ {
"name" : "body",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
}, {
"name" : "contentEncoding",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "ContentEncoding"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withBodyString",
"params" : [ {
"name" : "body",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
}, {
"name" : "contentEncoding",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "ContentEncoding"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest",
"mixing" : true
},
"paramNames" : [ "body", "contentType", "contentEncoding" ]
},
"$nearestImplementedOn" : "HttpRequest"
}, {
"type" : "Method",
"name" : "queryString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return the query string for a GET request. This will not include the leading `?` and will be null if there is none\nat all.",
"name" : "queryString",
"returnType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "queryString",
"returnType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "queryParam",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return all values for one single query parameter, one value for each time the param is used or assigned. If the\nusage is without an equal sign, it will have a null value in the array.",
"name" : "queryParam",
"params" : [ {
"name" : "param",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "queryParam",
"params" : [ {
"name" : "param",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
}
},
"paramNames" : [ "param" ]
}
}, {
"type" : "Method",
"name" : "postParamContent",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Content"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return all values for one single POST parameter, one value for each time the param is used or assigned.\nThis supports the content types `application/x-www-form-urlencoded` and `multipart/form-data` only.\n\nFor `application/x-www-form-urlencoded`, if the usage is without an equal sign, it will have a null value in the\narray.\n\nThis method returns the {@link Content} instances, which preserve the content type specified in the\n`multipart/form-data` chunks.",
"name" : "postParamContent",
"params" : [ {
"name" : "param",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Content"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "postParamContent",
"params" : [ {
"name" : "param",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Content"
}
},
"paramNames" : [ "param" ]
}
}, {
"type" : "Method",
"name" : "postParamData",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "BinaryType",
"modifier" : "PRESERVES_EMPTY",
"name" : "binary"
}
} ]
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return all values for one single POST parameter, one value for each time the param is used or assigned.\nThis supports the content types `application/x-www-form-urlencoded` and `multipart/form-data` only.\n\nFor `application/x-www-form-urlencoded`, if the usage is without an equal sign, it will have a null value in the\narray. If the content type is needed, use #postParamContent instead.\n\nFor `multipart/form-data`, the values will be binary if the individual chunk's Content-Type is non-text.",
"name" : "postParamData",
"params" : [ {
"name" : "param",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "BinaryType",
"modifier" : "PRESERVES_EMPTY",
"name" : "binary"
}
} ]
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "postParamData",
"params" : [ {
"name" : "param",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "BinaryType",
"modifier" : "PRESERVES_EMPTY",
"name" : "binary"
}
} ]
}
},
"paramNames" : [ "param" ]
}
}, {
"type" : "Method",
"name" : "sendAsync",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<HttpResponse>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "HttpRequest" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "HttpRequest"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Sends this HTTP request to target URI asynchronously.",
"name" : "sendAsync",
"params" : [ {
"name" : "timeout",
"valueType" : {
"type" : "ReferenceType",
"name" : "Duration"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<HttpResponse>",
"hadDeclaredVarBindings" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "sendAsync",
"params" : [ {
"name" : "timeout",
"valueType" : {
"type" : "ReferenceType",
"name" : "Duration"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<HttpResponse>",
"hadDeclaredVarBindings" : true
},
"paramNames" : [ "timeout" ]
},
"$nearestImplementedOn" : "HttpRequest"
}, {
"type" : "Method",
"name" : "sendSync",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "HttpResponse"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "HttpRequest" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "HttpRequest"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Sends this HTTP request to target URI synchronously (if supported by the runtime environment).",
"name" : "sendSync",
"params" : [ {
"name" : "timeout",
"valueType" : {
"type" : "ReferenceType",
"name" : "Duration"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "HttpResponse"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "sendSync",
"params" : [ {
"name" : "timeout",
"valueType" : {
"type" : "ReferenceType",
"name" : "Duration"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "HttpResponse"
},
"paramNames" : [ "timeout" ]
},
"$nearestImplementedOn" : "HttpRequest"
}, {
"type" : "Method",
"name" : "responseFromValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates HttpResponse to this request based on provided C3 value",
"name" : "responseFromValue",
"params" : [ {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "valueType",
"valueType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "responseFromValue",
"params" : [ {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "valueType",
"valueType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"paramNames" : [ "value", "valueType" ]
}
}, {
"type" : "Method",
"name" : "responseFromContent",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates HttpResponse to this request based on provided content",
"name" : "responseFromContent",
"params" : [ {
"name" : "content",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Content"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "responseFromContent",
"params" : [ {
"name" : "content",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Content"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"paramNames" : [ "content" ]
}
}, {
"type" : "Method",
"name" : "emptyResponse",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an empty HttpResponse to this request",
"name" : "emptyResponse",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "emptyResponse",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
}
}
}, {
"type" : "Method",
"name" : "redirectResponse",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates 302 Found Redirect HttpResponse to this request",
"name" : "redirectResponse",
"params" : [ {
"name" : "url",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Url"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "redirectResponse",
"params" : [ {
"name" : "url",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Url"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"paramNames" : [ "url" ]
}
}, {
"type" : "Method",
"name" : "notFoundResponse",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates 404 Not Found HttpResponse to this request",
"name" : "notFoundResponse",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "notFoundResponse",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
}
}
}, {
"type" : "Method",
"name" : "errorResponse",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an error HttpResponse to this request",
"name" : "errorResponse",
"params" : [ {
"name" : "err",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Error"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "errorResponse",
"params" : [ {
"name" : "err",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Error"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"paramNames" : [ "err" ]
}
}, {
"type" : "Method",
"name" : "contentMeta",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ContentMeta"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates {@link ContentMeta} from headers in this request",
"name" : "contentMeta",
"params" : [ {
"name" : "contentLocation",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ContentMeta"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "contentMeta",
"params" : [ {
"name" : "contentLocation",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ContentMeta"
},
"paramNames" : [ "contentLocation" ]
}
}, {
"type" : "Method",
"name" : "toJava",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'org.apache.http.client.methods.HttpUriRequest'"
} ]
} ]
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toJava",
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'org.apache.http.client.methods.HttpUriRequest'"
} ]
} ]
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJava",
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'org.apache.http.client.methods.HttpUriRequest'"
} ]
} ]
}
}
}, {
"type" : "Method",
"name" : "toObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an Obj from this request's query string, parsing values from the query string as fields of the specified\ntype. Query parameters that don't correspond to fields are ignored and conversion failures are also ignored unless\nthe `failIfInvalid` parameter is true.\n\n@param type the Obj type to construct\n@param failIfInvalid if true, throw an error if any conversions fail",
"name" : "toObj",
"genericVars" : [ {
"name" : "O"
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "failIfInvalid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toObj",
"genericVars" : [ {
"name" : "O"
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "failIfInvalid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O"
},
"paramNames" : [ "type", "failIfInvalid" ]
}
}, {
"type" : "Method",
"name" : "queryToObj",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an Obj from the specified query string, parsing values from the query string as fields of the specified\ntype. The query string should be standard format, without the leading `?`. Query parameters that don't correspond\nto fields are ignored and conversion failures are also ignored unless the `failIfInvalid` parameter is true.\n\n@param type the Obj type to construct\n@param query the query string to parse\n@param failIfInvalid if true, throw an error if any conversions fail\n\n@see #queryFromObj",
"name" : "queryToObj",
"genericVars" : [ {
"name" : "O"
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "query",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfInvalid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O"
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "queryToObj",
"genericVars" : [ {
"name" : "O"
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "query",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfInvalid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O"
},
"paramNames" : [ "type", "query", "failIfInvalid" ]
}
}, {
"type" : "Method",
"name" : "queryFromObj",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct a query string from the specified Obj instance. The query string is in standard format, without the\nleading `?`.\n\n@param inst the Obj inst as the source\n@return produced query string (may be empty, but not null)\n\n@see #queryToObj",
"name" : "queryFromObj",
"params" : [ {
"name" : "inst",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "queryFromObj",
"params" : [ {
"name" : "inst",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
},
"paramNames" : [ "inst" ]
}
}, {
"type" : "Method",
"name" : "fromJava",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "fromJava",
"params" : [ {
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'java.lang.Object'"
} ]
} ],
"name" : "request",
"valueType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest"
},
"private" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromJava",
"params" : [ {
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'java.lang.Object'"
} ]
} ],
"name" : "request",
"valueType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest"
},
"paramNames" : [ "request" ]
}
} ],
"hasSourceCode" : {
"js-ide-vscode-client-node" : false
}
});
let ACTION_ENGINE = "js-client";
function hasBody() {
return this.encodedBody != null && this.encodedBody.byteLength > 0;
}
function readBodyString() {
if (this.encodedBody != null) {
const encoder = new C3.$TextDecoder();
return encoder.decode(this.encodedBody);
}
}
function withBody(...args) {
let body;
let contentType, contentEncoding;
if (args[0] instanceof ArrayBuffer || ArrayBuffer.isView(args[0])) {
body = args[0];
contentType = args[1];
contentEncoding = args[2];
} else if (args[0] != null) {
body = args[0].readEncoded();
contentType = args[0].contentType;
contentEncoding = args[0].contentEncoding;
} else {
contentType = args[1];
contentEncoding = args[2];
}
if (body != null && contentType == null) {
contentType = _header(this, 'Content-Type') ?? 'application/octet-stream';
}
return this.withEncodedBody(body)
.withContentType(contentType)
.withContentEncoding(contentEncoding);
}
function withBodyString(entity, contentType, contentEncoding) {
if (contentType == null) {
contentType = _header(this, 'Content-Type') ?? 'text/plain';
}
const encoder = new C3.$TextEncoder();
return this.withBody(encoder.encode(entity), contentType);
}
function _extraHeaders(req) {
return {};
}
function _header(req, name) {
return req.header(name);
}
function _headers(req) {
let headers = _extraHeaders(req);
req.allHeaders().forEach((v, p) => {
if (v != null){
headers[p] = req.header(p);
}
});
return headers;
}
function _hasAuthz(req) {
return !!req.header('authorization', '');
}
function sendAsync(_timeout) {
const self = this;
let req = new C3.$JsHttpRequest(self.method || 'GET', self.url, _headers(self), self.encodedBody);
return req.sendAsync().then(function (res) {
return _buildResponse(self, res);
});
}
function sendSync(_timeout) {
const self = this;
let req = new C3.$JsHttpRequest(self.method || 'GET', self.url, _headers(self), self.encodedBody);
return _buildResponse(self, req.sendSync());
}
function _buildResponse(req, res) {
let response = {
request: req,
statusCode: res.statusCode,
reasonPhrase: res.reasonPhrase,
elapsedMs: res.elapsedMs,
_headers: new Map(),
};
if (res.headers != null) {
Object.keys(res.headers).forEach(p => response._headers.set(p.toLowerCase(), [res.headers[p]]));
}
if (res.response != null) {
if (res.responseType === 'arraybuffer') {
response._body = res.response;
} else {
const encoder = new C3.$TextEncoder();
response._body = encoder.encode(res.responseText).buffer;
response.entity = res.responseText;
}
}
if (req.connection) {
req.connection._logHttpRequest(req.url, res.elapsedMs);
let HttpResponse = req.connection._loadType('HttpResponse', true, true);
return HttpResponse.make(response);
} else if (typeof C3.HttpResponse === 'object') {
return C3.HttpResponse.make(response);
} else {
return response;
}
}
ACTION_ENGINE = 'js-client-node';
function allHeaders() {
return new Map(this._headers);
}
function allHeadersMerged(merger) {
if (merger == null) merger = (header, vals) => {
if ("set-cookie" == header) return null;
return vals.join(", ");
}
let merged = new Map;
for (let [header, vals] of this._headers) {
let m = merger(header, vals);
if (m != null) merged.set(header, m);
}
return merged;
}
function header(name, dflt) {
if ("set-cookie" == name?.toLowerCase()) {
throw new Error("Unsupported header Set-Cookie for WithHttpHeaders.header. Use WithHttpHeaders.headers instead.")
}
let values = this.headers(name);
if (values.length === 0) {
return dflt;
}
return values.join(", ");
}
function headers(name) {
return this._headers?.get(name?.toLowerCase()) || [];
}
function replaceHeader(name, value) {
_validateHeaderName(name);
_validateHeaderValue(value);
let _headers = new Map(this._headers);
_headers.set(name.toLowerCase(), [value]);
return this.with_headers(_headers);
}
function withHeader(name, value) {
_validateHeaderName(name);
let values = this.headers(name);
if (value != null && value !== '' && !values.includes(value)) {
values = values.concat([value]);
}
if (values.length === 0) {
return this;
}
let _headers = new Map(this._headers);
_headers.set(name.toLowerCase(), values);
return this.with_headers(_headers);
}
function withoutHeader(name) {
_validateHeaderName(name);
let _headers = new Map(this._headers);
_headers.delete(name.toLowerCase());
return this.with_headers(_headers);
}
function withHeaders(headers) {
let _headers = new Map(this._headers);
if (headers != null) {
if (!(headers instanceof Map)) {
headers = new Map(Object.entries(headers));
}
headers.forEach((vals, key) => {
_validateHeaderName(key);
let keyLowerCase = key.toLowerCase();
vals = typeof(vals) === 'string' ? [vals]: vals;
let newValues = (_headers.get(keyLowerCase) ?? []).concat(vals);
let existingValues = new Set();
newValues = newValues.filter(v => {
if (!existingValues.has(v)) {
existingValues.add(v);
return true;
}
return false;
});
if (newValues.length > 0) {
_headers.set(keyLowerCase, newValues);
}
});
}
return this.with_headers(_headers);
}
function withContentEncoding(contentEncoding) {
return !contentEncoding ? this: this.withHeader("Content-Encoding", contentEncoding);
}
function withContentType(contentType) {
return !contentType ? this: this.withHeader("Content-Type", contentType);
}
function withJsonHeaders() {
return this.withContentType('application/json').withHeader("Accept", 'application/json');
}
function withAuthHeader(auth) {
return this.withHeader("Authorization", auth);
}
function withActionEngineHeader() {
if (this?.$conn?.$actionEngine != null) {
return this.withHeader("X-C3-Action-Engine", this.$conn.$actionEngine);
}
return this;
}
function cookieValue(key) {
let values = this.headers('Set-Cookie');
for (let value of values) {
let r = /^([^=]+)="([^"]*)"(;.*)?$/.exec(value) || /^([^=]+)=([^;]*)(;.*)?$/.exec(value);
if (r && r[1] == key) {
return r[2];
}
}
}
function contentType() {
return this.header("Content-Type");
}
function contentEncoding() {
return this.header("Content-Encoding");
}
function _validateHeaderName(name) {
if (name == null || name.trim() === '') {
throw new Error(`Invalid value ${name} for http header, it must not be empty.`);
}
}
function _validateHeaderValue(value) {
if (value == null || value.trim() === '') {
throw new Error(`Invalid value ${name} for http header, it must not be empty.`);
}
}
function array(...elements) {
const b = this.arrayBuilder();
for (let e of elements) b.add(e);
return b.build();
}
function arrayBuilder() {
return ArrayType.of(this.myReferenceType()).makeBuilder();
}
function eachFieldValue(action) {
let spec;
if (arguments.length == 2) {
spec = arguments[0];
action = arguments[1];
}
this.type().meta().dataFieldTypes().forEach(ft => Val.consumeFieldValue(this, ft, this[ft.name], spec, action));
}
function eachFieldValueWhile(action) {
let spec;
if (arguments.length == 2) {
spec = arguments[0];
action = arguments[1];
}
let fieldTypes = this.type().meta().dataFieldTypes();
if (spec == null) {
for (let i = 0; i < fieldTypes.length; i++) {
let ft = fieldTypes[i];
if (this.hasOwnProperty(ft.name) && Val.isNotEmpty(this[ft.name])) {
let continue_ = action.call(undefined, ft, this[ft.name]);
if (!continue_)
return true;
}
}
} else {
throw new Error('eachFieldValueWhile with ValueSpec not implemented (yet)');
}
return false;
}
function fieldValue(field, defaultToEmpty) {
const name = typeof field === 'string' ? field : field.name;
let v = this[name];
if (v == null && defaultToEmpty) {
const ft = typeof field === 'string' ? this.type().meta().fieldType(field) : field;
if (ft != null) v = ft.defaultEmptyValue();
}
return v;
}
function fieldValueAtPath(fieldPath, failIfNotFound, _context) {
const rootObj = this;
const rootType = rootObj.type();
let parentType = rootType;
let info = FieldPath.parse(rootType, fieldPath)
.fold([rootObj, rootType.myReferenceType()],
(fp, i, isLeaf, parentInfo) => {
if (parentInfo == null) {
return null;
}
const parentFp = fp.parent();
let parentVal = parentInfo[0];
let parentVt = parentInfo[1];
if (parentVal == null) {
if (fp.valueType() == null && failIfNotFound) {
throw new Error(`Missing field "${fp.pathInRootType()}" of ${rootObj.type().name()}.`);
}
return null;
}
if (parentVt.isCollection() && !parentFp.isIndexed()) {
parentVal = parentVal.first();
parentVt = parentVt.elementType;
}
let value, vt;
if (parentVal.$c3inst != null) {
let ft = parentVal.$c3inst.meta().fieldType(fp.name());
if (ft == null) {
if (failIfNotFound) {
throw new Error(`Missing field "${fp.pathInRootType()}" of ${rootObj.type().name()}.`);
}
return null;
}
value = parentVal[fp.name()];
vt = ft.valueType();
} else {
value = parentVal;
vt = parentVt;
}
if (value == null) {
value = null;
} else if (_vtHasCollection(vt) && fp.isIndexed()) {
const index = fp.index();
if (Array.isArray(value) && typeof index === 'number') {
value = value[index];
} else if (value instanceof Set && typeof index === 'number') {
value = value.get(index);
} else if (value instanceof Map) {
value = value.get(String(index));
} else {
value = value.first(e => String(e) === index);
}
vt = vt.elementType;
}
return [value, vt];
});
return info != null ? info[0] : null;
}
function foldFieldValues(...args) {
let initial = null;
let spec;
let folder;
if (args.length >= 3) {
initial = args[0];
spec = args[1];
folder = args[2];
} else if (args.length === 2) {
initial = args[0];
folder = args[1];
} else {
folder = args[0];
}
let result = initial;
this.eachFieldValue(spec, (ft, v) => result = folder(ft, v, result));
return result;
}
function fromJson(json) {
if (json == null) {
return null;
}
let meta = this.meta();
if (typeof json === 'object') {
if (Object.getOwnPropertyNames(json).length == 0) {
return null;
}
let typeSerName = meta.typeSerName;
if (typeSerName != null && typeof json[typeSerName] === 'string') {
let t = C3.type(json[typeSerName]);
if (t != null && t.meta().isA(this)) {
meta = t.meta();
}
}
let copy = {}, renamed = false;
Object.keys(json).forEach(p => {
if (p === typeSerName) {
return;
}
let ft = meta.fieldTypeBySerName(p);
if (ft != null) {
copy[ft.name] = json[p];
renamed = true;
} else {
copy[p] = json[p];
}
});
return meta.toType().make(renamed ? copy : json);
}
if (typeof json === 'string' && meta.isA('StringSerializable')) {
return this.fromString(json);
}
throw Err.invalidValue(json, meta.name);
}
function fromJsonString(string) {
if (Str.isEmpty(string)) return;
let json;
try {
json = JSON.parse(string);
} catch (e) {
throw Err.invalidValue(string, this.name() + ' JSON string');
}
return this.fromJson(json);
}
function _vtHasCollection(vt) {
if (vt.isCollection()) {
return true;
} else if (vt.isAnyOf()) {
for (let candidate of vt.restrictions) {
if (candidate.valueType.isCollection()) return true;
}
}
return false;
}
function isEmptyObj() {
let count = 0;
if (this.type().meta().isA('Mutable')) {
let spec = ValueSpec.make({ skipTraversedRefs: true, traversedRefs: new Set(), includeEmptyRefs: true });
this.eachFieldValue(spec, (ft, v) => {
if (v != null && ft.valueType().isReference()) {
if (spec.traversedRefs.contains(v)) {
count++;
return;
}
spec.traversedRefs.add(v);
}
if (Val.isNotEmpty(v))
count++;
});
} else {
this.eachFieldValue((_ft, _v) => count++);
}
return count == 0;
}
function make(...args) {
let init;
let withDefaults = false;
if (args.length == 1 && typeof args[0] == 'boolean') {
withDefaults = args[0];
} else if (args.length > 0) {
init = args[0];
if (args.length > 1 && typeof args[1] == 'boolean') {
withDefaults = args[1];
}
}
let obj;
if (typeof init === 'string' && this.meta().isA('StringSerializable')) {
obj = this.fromString(...args);
} else {
obj = this.builder(init).build();
if (withDefaults) {
obj = obj.withDefaults();
}
}
return obj;
}
function mapFieldValues(mapper) {
let spec;
if (arguments.length == 2) {
spec = arguments[0];
mapper = arguments[1];
}
let init = {};
this.eachFieldValue(spec, (ft, v) => {
let mapped = mapper.call(undefined, ft, v);
if (mapped != null)
init[ft.name] = mapped;
});
return this.type().builder(init).build();
}
function mapFieldValuesAsync(mapper) {
let spec;
if (arguments.length == 2) {
spec = arguments[0];
mapper = arguments[1];
}
let init = {};
const allAsyncMaps = [];
this.eachFieldValue(spec, (ft, v) => {
let mapped = mapper.call(undefined, ft, v);
if (mapped != null) {
allAsyncMaps.push(mapped);
mapped.then((resolve) => {
init[ft.name] = resolve;
});
}
});
return Promise.all(allAsyncMaps).then(() => {
return this.type().builder(init).build();
});
}
function mapBuilder() {
return MapType.of(PrimitiveType.ofStr(), this.myReferenceType()).makeBuilder();
}
function mapBuilderOf(keyType) {
return MapType.of(keyType, this.myReferenceType()).makeBuilder();
}
function singletonArray() {
return ArrayType.of(this.type().myReferenceType()).makeBuilder().add(this).build();
}
function singletonSet() {
return SetType.of(this.type().myReferenceType()).makeBuilder().add(this).build();
}
function setBuilder() {
return SetType.of(this.myReferenceType()).makeBuilder();
}
function toBuilder() {
return this.type().builder(this);
}
function withDefaults(includeEmptyRefsWithDefaults, defaultFields) {
if (this.$cache.get('$withDefaults', false, () => false)) return this;
if (defaultFields != null && defaultFields.length === 0) defaultFields = null;
const fields = new Map();
let delegate = false;
this.type().meta().fieldTypes().forEach(ft => {
if (delegate) return;
if (defaultFields && !defaultFields.includes(ft.name)) return;
const oldVal = this[ft.name];
if (oldVal == null ||
!ft.valueType().preservesEmpty() && Val.isCollection(oldVal) && oldVal.isEmpty()) {
if (ft.hasDefault()) {
const c = ft.defaultValueConst();
if (c != null) {
fields.set(ft.name, c);
} else {
delegate = true;
}
} else if (!Object.hasOwnProperty.call(this, ft.name)) {
const initVal = ft.valueType().initialValue();
if (initVal != null) fields.set(ft.name, initVal);
}
} else if (Val.isObj(oldVal) &&
(!oldVal.isEmptyObj() || includeEmptyRefsWithDefaults) &&
!(oldVal instanceof WithUniqueId)) { // TODO PLAT-48170 Use WithUniqueKey
fields.set(ft.name, oldVal.withDefaults(includeEmptyRefsWithDefaults, defaultFields));
} else if (Val.isCollection(oldVal)) {
fields.set(ft.name, oldVal.withDefaults(includeEmptyRefsWithDefaults, defaultFields));
}
});
let res;
if (delegate) {
res = this.type().typeSystem().call(this.type().name(), 'withDefaults', this,
includeEmptyRefsWithDefaults, defaultFields);
} else {
res = this.withFields(fields, true);
}
res.$cache.put('$withDefaults', true);
return res;
}
function withField(field, value, doNotConvert) {
if (typeof field === 'string') {
field = this.type().meta().fieldType(field, true);
}
return this.toBuilder().v(field, value, doNotConvert).build();
}
function withFields(fields, doNotConvert) {
if (fields == null || fields.size === 0) return this;
return this.toBuilder().setFields(fields, doNotConvert).build();
}
function _toJson(ths, typed, writeTopLevelType) {
let o = {};
if (writeTopLevelType && ths.type().meta().fieldTypeBySerName('type') == null) {
o.type = ths.type().name();
}
let toJsonFuncName = typed ? "valueToTypedJson" : "valueToJson";
Object.keys(ths).forEach(p => {
let ft = ths.type().meta().fieldType(p);
if (ft == null || (ft.annotations().has('ser') && ft.annotations().ser().hidden))
return;
let v = ths[p];
if (ft.valueType().preservesEmpty() || (v != null && !ft.valueType().isEmptyValue(v))) {
o[ft.serName()] = ft.valueType()[toJsonFuncName](v);
}
});
return o;
}
function toTypedJson() {
let omitTopLevelType = arguments.length > 0 ? arguments[0] : false;
if (arguments[1] != null || arguments[2] != null) {
throw new Error('Obj.toTypedJson with include/exclude or runtime is not implemented (yet)');
}
return _toJson(this, true, !omitTopLevelType);
}
function toJson() {
if (arguments.length > 0) {
throw new Error('Obj.toJson with include/exclude not implemented (yet)');
}
return _toJson(this, false, false);
}
function super_(mixin) {
throw Err.notImplemented('WithType', 'super');
}
"use strict";
function $Builder(type, inst) {
let fields = {};
this.$type = type;
this.$setup = function (_inst) {};
this.$findType = function (type, _fields) { return type; };
this.$makeField = function (ft, value) { return value; };
this.$afterMake = function (inst) { return inst; };
if (inst != null) {
Object.keys(inst).forEach(fn => fields[fn] = inst[fn]);
}
Object.defineProperties(this, {
$objType: { value: type },
$onbuild: { value: undefined, writable: true },
$fields: { value: fields, configurable: true },
$refs: { value: {}, configurable: true },
$arrays: { value: {}, configurable: true },
$sets: { value: {}, configurable: true },
$maps: { value: {}, configurable: true },
$builder: { value: true },
});
}
$Builder.prototype.a = function a(field, element, doNotConvert) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isArray()) {
throw Err.invalidCall('ObjBuilder.a', `non-array field ${field.name}`);
}
let b = this.$arrays[field.name];
if (b == null) {
b = this.$fields[field.name];
if (b == null || !b.$builder) {
b = this.$arrays[field.name] = vt.makeBuilder(b);
}
}
if (arguments.length == 1) {
return b;
} else if (arguments.length == 2 || arguments.length == 3) {
b.add(element);
return this;
} else {
throw Err.invalidCall('ObjBuilder.a', 'expected field and element');
}
};
$Builder.prototype.clear = function clear() {
Object.defineProperty(this, '$fields', { value: {}, configurable: true });
Object.defineProperty(this, "$refs", { value: {}, configurable: true });
Object.defineProperty(this, "$arrays", { value: {}, configurable: true });
Object.defineProperty(this, "$sets", { value: {}, configurable: true });
Object.defineProperty(this, "$maps", { value: {}, configurable: true });
};
$Builder.prototype.constrain = function constrain() {
throw new Error('Unsupported operation ObjBuilder.constrain for JavaScript.');
};
$Builder.prototype.current = function current() {
let init = {};
Object.keys(this.$fields).forEach(p => {
let v = this.$fields[p];
if (v != null && v.$builder)
v = v.current();
init[p] = v;
});
return this.$objType.make(init);
};
$Builder.prototype.isEmpty = function isEmpty() {
return Object.keys(this.$fields).length === 0 &&
Object.keys(this.$refs).length === 0 &&
Object.keys(this.$arrays).length === 0 &&
Object.keys(this.$sets).length === 0 &&
Object.keys(this.$maps).length === 0;
};
$Builder.prototype.m = function m(field, key, element, doNotConvert) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isMap()) {
throw new Error(`Invalid call to ObjBuilder.m: non-map field ${field.name}.`);
}
let b = this.$maps[field.name];
if (b == null) {
b = this.$fields[field.name];
if (b == null || !b.$builder) {
b = this.$maps[field.name] = vt.makeBuilder(b);
}
}
if (arguments.length == 1) {
return b;
} else if (arguments.length == 3 || arguments.length == 4) {
b.put(key, element);
return this;
} else {
throw new Error(`Invalid call to ObjBuilder.m: expected field, key and value.`);
}
};
$Builder.prototype.mergeJson = function mergeJson(json) {
if (json != null) {
Object.keys(json).forEach(fn => this.v(fn, json[fn], false));
}
return this;
};
$Builder.prototype.mergeObj = function mergeObj(other, otherFieldsFilter) {
if (other == null) {
return this;
}
if (arguments.length == 1) {
if (this.objType() == other.type()) {
other.eachFieldValue((ft, v) => this.v(ft, v));
} else {
other.eachFieldValue((ft, v) => this.v(this.objType().fieldType(ft.name), v));
}
return this;
} else if (arguments.length == 2) {
if (other.instanceOf(otherFieldsFilter)) {
const tm = otherFieldsFilter.meta();
other.eachFieldValue((ft, v) => {
if (tm.fieldType(ft.name) != null)
this.v(ft, v);
});
}
return this;
}
throw new Error(`Invalid call to ObjBuilder.mergeObj: expected other and otherFieldsFilter.`);
};
$Builder.prototype.objType = function objType() {
return this.$objType;
};
$Builder.prototype.r = function r(field) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isReference()) {
throw new Error(`Invalid call to ObjBuilder.r: non-reference field ${field.name}.`);
}
let type = vt.dereference(true);
let b = this.$refs[field.name];
if (b == null) {
if (b == null || !b.$builder) {
b = this.$refs[field.name] = type.builder().mergeObj(b);
}
}
return b;
};
$Builder.prototype.s = function s(field, element, doNotConvert) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isSet()) {
throw Err.invalidCall('ObjBuilder.a', `non-array field ${field.name}`);
}
let b = this.$sets[field.name];
if (b == null) {
b = this.$fields[field.name];
if (b == null || !b.$builder) {
b = this.$sets[field.name] = vt.makeBuilder(b);
}
}
if (arguments.length == 1) {
return b;
} else if (arguments.length == 2 || arguments.length == 3) {
b.add(element);
return this;
} else {
throw Err.invalidCall('ObjBuilder.s', 'expected field and element');
}
};
$Builder.prototype.setFields = function setFields(fields, doNotConvert) {
if (fields != null) {
for (let [name, v] of fields) {
const ft = this.$objType.meta().fieldType(name, true);
if (v == null) {
delete this.$fields[ft.name];
} else {
this.$fields[ft.name] = v;
}
}
}
return this;
};
$Builder.prototype.v = function v(field, value, doNotConvert) {
if (arguments.length < 2) {
throw new Error(`Invalid call to ObjBuilder.v: expected field and value.`);
}
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
this.$fields[field.name] = value;
return this;
};
$Builder.prototype.build = function build() {
const type = this.$findType(this.$type, this.$fields);
let inst = Object.create(type.$objProto);
this.$setup(inst);
Object.keys(this.$refs).forEach(fn => {
this.$fields[fn] = this.$refs[fn].build();
});
Object.keys(this.$arrays).forEach(fn => {
this.$fields[fn] = this.$arrays[fn].build();
});
Object.keys(this.$sets).forEach(fn => {
this.$fields[fn] = this.$sets[fn].build();
});
Object.keys(this.$maps).forEach(fn => {
this.$fields[fn] = this.$maps[fn].build();
});
Object.keys(this.$fields).forEach(fn => {
let ft = type.$init.fieldTypes.find(fieldType => fieldType.name === fn && !fieldType.constant);
if (ft && inst[fn] === undefined && this.$fields[fn] != null) {
inst[fn] = this.$makeField(ft, this.$fields[fn]);
}
});
type.$init.fieldTypes.forEach(ft => {
if (!ft.constant && !_hasOwnProperty(inst, ft.name)) {
let vt = ft.valueType;
if (vt.modifier !== 'PRESERVES_EMPTY') {
let v = this.$makeField(ft, null);
if (v != null) {
inst[ft.name] = v;
}
}
}
});
inst = this.$afterMake(inst);
Object.freeze(inst);
if (this.$onbuild) {
this.$onbuild(inst);
}
return inst;
};
$Builder.prototype.type = function type() { return $type; };
$Builder.prototype.v = function v(field, value, doNotConvert) {
if (arguments.length < 2) {
throw new Error('Invalid call to ObjBuilder.v: expected field and value.');
}
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
this.$fields[field.name] = value;
return this;
};
$Builder.prototype._headers = function (v) {
if (v == null) {
delete this.$fields._headers;
} else {
this.$fields._headers = v;
}
return this;
};
$Builder.prototype.client = function (v) {
if (v == null) {
delete this.$fields.client;
} else {
this.$fields.client = v;
}
return this;
};
$Builder.prototype.method = function (v) {
if (v == null) {
delete this.$fields.method;
} else {
this.$fields.method = v;
}
return this;
};
$Builder.prototype.url = function (v) {
if (v == null) {
delete this.$fields.url;
} else {
this.$fields.url = v;
}
return this;
};
$Builder.prototype.encodedBody = function (v) {
if (v == null) {
delete this.$fields.encodedBody;
} else {
this.$fields.encodedBody = v;
}
return this;
};
$Builder.prototype.connection = function (v) {
if (v == null) {
delete this.$fields.connection;
} else {
this.$fields.connection = v;
}
return this;
};
let $logger;
function log() {
if ($logger == null) {
$logger = C3.Logger.for($type.name());
}
return $logger;
};
const $type = new Type$Proto($conn, $init);
const $proto = new (function ServerRequest() {});
Object.defineProperty($proto, '$conn', { value: $conn });
Object.defineProperties($type, {
$objProto: { value: $proto },
$withType: { value: true }
});
Object.defineProperty($type, Symbol.hasInstance, { value: function(inst) { return inst != null && inst.$c3inst && inst.$c3inst.meta().isA(this); } });
$proto.withField = withField;
$proto.withDefaults = withDefaults;
function withoutHeader_(name) {
return Ctx.call((t, a) => withoutHeader.apply(t, a), $type, 'withoutHeader', this, name);
}
_impl(withoutHeader_, withoutHeader);
$proto.withoutHeader = withoutHeader_;
$proto.eachFieldValue = eachFieldValue;
function allHeadersMerged_(merger) {
return Ctx.call((t, a) => allHeadersMerged.apply(t, a), $type, 'allHeadersMerged', this, merger);
}
_impl(allHeadersMerged_, allHeadersMerged);
$proto.allHeadersMerged = allHeadersMerged_;
function replaceHeader_(name, value) {
return Ctx.call((t, a) => replaceHeader.apply(t, a), $type, 'replaceHeader', this, name, value);
}
_impl(replaceHeader_, replaceHeader);
$proto.replaceHeader = replaceHeader_;
$type.fromJsonString = fromJsonString;
$type.array = array;
$proto.singletonArray = singletonArray;
$proto.sendAsync = sendAsync;
$type.mapBuilder = mapBuilder;
$type.make = make;
$proto.withBodyString = withBodyString;
function withHeaders_(headers) {
return Ctx.call((t, a) => withHeaders.apply(t, a), $type, 'withHeaders', this, headers);
}
_impl(withHeaders_, withHeaders);
$proto.withHeaders = withHeaders_;
function withAuthHeader_(auth) {
return Ctx.call((t, a) => withAuthHeader.apply(t, a), $type, 'withAuthHeader', this, auth);
}
_impl(withAuthHeader_, withAuthHeader);
$proto.withAuthHeader = withAuthHeader_;
$proto.sendSync = sendSync;
$proto.isEmptyObj = isEmptyObj;
$type.mapBuilderOf = mapBuilderOf;
$proto.fieldValueAtPath = fieldValueAtPath;
function withJsonHeaders_() {
return Ctx.call((t, a) => withJsonHeaders.apply(t, a), $type, 'withJsonHeaders', this);
}
_impl(withJsonHeaders_, withJsonHeaders);
$proto.withJsonHeaders = withJsonHeaders_;
function withContentEncoding_(contentEncoding) {
return Ctx.call((t, a) => withContentEncoding.apply(t, a), $type, 'withContentEncoding', this, contentEncoding);
}
_impl(withContentEncoding_, withContentEncoding);
$proto.withContentEncoding = withContentEncoding_;
$proto.hasBody = hasBody;
function withContentType_(contentType) {
return Ctx.call((t, a) => withContentType.apply(t, a), $type, 'withContentType', this, contentType);
}
_impl(withContentType_, withContentType);
$proto.withContentType = withContentType_;
function withHeader_(name, value) {
return Ctx.call((t, a) => withHeader.apply(t, a), $type, 'withHeader', this, name, value);
}
_impl(withHeader_, withHeader);
$proto.withHeader = withHeader_;
$proto.mapFieldValuesAsync = mapFieldValuesAsync;
$proto.readBodyString = readBodyString;
$proto.fieldValue = fieldValue;
$type.arrayBuilder = arrayBuilder;
function headers_(name) {
return Ctx.call((t, a) => headers.apply(t, a), $type, 'headers', this, name);
}
_impl(headers_, headers);
$proto.headers = headers_;
$proto.toTypedJson = toTypedJson;
$proto.withFields = withFields;
$type.fromJson = fromJson;
$proto.foldFieldValues = foldFieldValues;
$proto.singletonSet = singletonSet;
function withActionEngineHeader_() {
return Ctx.call((t, a) => withActionEngineHeader.apply(t, a), $type, 'withActionEngineHeader', this);
}
_impl(withActionEngineHeader_, withActionEngineHeader);
$proto.withActionEngineHeader = withActionEngineHeader_;
$proto.withBody = withBody;
$proto.toBuilder = toBuilder;
$proto.super = super_;
$proto.eachFieldValueWhile = eachFieldValueWhile;
$proto.mapFieldValues = mapFieldValues;
function header_(name, dflt) {
return Ctx.call((t, a) => header.apply(t, a), $type, 'header', this, name, dflt);
}
_impl(header_, header);
$proto.header = header_;
function allHeaders_() {
return Ctx.call((t, a) => allHeaders.apply(t, a), $type, 'allHeaders', this);
}
_impl(allHeaders_, allHeaders);
$proto.allHeaders = allHeaders_;
$type.setBuilder = setBuilder;
$proto.toJson = toJson;
$type.buildArray = function buildArray(builder) {
const b = this.arrayBuilder();
builder(b);
return b.build();
};
$type.buildMap = function buildMap(builder) {
const b = this.mapBuilder();
builder(b);
return b.build();
};
$type.builder = function builder(inst) { return new $Builder(this, inst); };
Object.defineProperty($type.builder, '$std', { value: true });
$type._instantiate = function _instantiate(fields) {
return this.make(fields);
};
$type.buildSet = function buildSet(builder) {
const b = this.setBuilder();
builder(b);
return b.build();
};
$proto.type = function type() { return $type; };
$proto.log = log;
$proto.with_headers = function(v) { return this.type().builder(this)._headers(v).build(); };
$proto.without_headers = function() { return this.type().builder(this)._headers().build(); };
$proto.withClient = function(v) { return this.type().builder(this).client(v).build(); };
$proto.withoutClient = function() { return this.type().builder(this).client().build(); };
$proto.withMethod = function(v) { return this.type().builder(this).method(v).build(); };
$proto.withoutMethod = function() { return this.type().builder(this).method().build(); };
$proto.withUrl = function(v) { return this.type().builder(this).url(v).build(); };
$proto.withoutUrl = function() { return this.type().builder(this).url().build(); };
$proto.withEncodedBody = function(v) { return this.type().builder(this).encodedBody(v).build(); };
$proto.withoutEncodedBody = function() { return this.type().builder(this).encodedBody().build(); };
$proto.withConnection = function(v) { return this.type().builder(this).connection(v).build(); };
$proto.withoutConnection = function() { return this.type().builder(this).connection().build(); };
$proto.toJSON = function toJSON() { return this.toTypedJson(); };
Object.freeze($type);
Object.freeze($proto);
return $type;
})());
$conn._registerType((function() {
const $init = _deepFreeze({
"type" : "TypeMeta",
"metadataPath" : "platform/src/http/HttpRequest.c3typ",
"package" : "platform",
"packageSubPath" : "http",
"name" : "HttpRequest",
"doc" : "HTTP request",
"declaredInline" : true,
"declaredMixinRefTypes" : [ {
"name" : "WithHttpHeaders"
}, {
"name" : "Spec"
} ],
"declaredFieldTypes" : [ {
"doc" : "Parent HTTP client",
"name" : "client",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "HttpClient"
}
}, {
"doc" : "The HTTP method to use.",
"name" : "method",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"doc" : "The URL to send the request.\nAlways required.",
"name" : "url",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Url"
}
}
}, {
"doc" : "The entity body as {@link Content} for the request. Required for POST and PUT; ignored by GET.\nFor usage examples, see {@link HttpRequest.c3poly.md#body}.",
"name" : "body",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Content"
},
"cached" : true,
"member" : true,
"property" : true
}
}, {
"doc" : "Checks body is present.",
"name" : "hasBody",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Read the entity body as String.",
"name" : "readBodyString",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "failIfNotText",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Adds a body from the {@link Content} to this HTTP request. This sets the #encodedBody field as well as the\n`Content-Type` and `Content-Encoding` headers from the values in the content.",
"name" : "withBody",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "body",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Content"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Adds a body from the binary value, content type, and encoding. This sets the #encodedBody field as well as the\n`Content-Type` and `Content-Encoding` headers to the specified values.",
"name" : "withBody",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "encodedBody",
"valueType" : {
"type" : "BinaryType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "binary"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "ContentType"
}
}
}, {
"name" : "contentEncoding",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "ContentEncoding"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Adds a body from the string value, content type, and encoding. This sets the #encodedBody field as well as the\n`Content-Type` and `Content-Encoding` headers to the specified values.",
"name" : "withBodyString",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "body",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "ContentType"
}
}
}, {
"name" : "contentEncoding",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "ContentEncoding"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "The encoded body as binary for the request.",
"name" : "encodedBody",
"private" : true,
"valueType" : {
"type" : "BinaryType",
"name" : "binary"
}
}, {
"doc" : "Return the query string for a GET request. This will not include the leading `?` and will be null if there is none\nat all.",
"name" : "queryString",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
},
"member" : true
}
}, {
"doc" : "Return all values for one single query parameter, one value for each time the param is used or assigned. If the\nusage is without an equal sign, it will have a null value in the array.",
"name" : "queryParam",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "param",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
}
},
"member" : true
}
}, {
"doc" : "Return all values for one single POST parameter, one value for each time the param is used or assigned.\nThis supports the content types `application/x-www-form-urlencoded` and `multipart/form-data` only.\n\nFor `application/x-www-form-urlencoded`, if the usage is without an equal sign, it will have a null value in the\narray.\n\nThis method returns the {@link Content} instances, which preserve the content type specified in the\n`multipart/form-data` chunks.",
"name" : "postParamContent",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "param",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "Content"
}
},
"member" : true
}
}, {
"doc" : "Return all values for one single POST parameter, one value for each time the param is used or assigned.\nThis supports the content types `application/x-www-form-urlencoded` and `multipart/form-data` only.\n\nFor `application/x-www-form-urlencoded`, if the usage is without an equal sign, it will have a null value in the\narray. If the content type is needed, use #postParamContent instead.\n\nFor `multipart/form-data`, the values will be binary if the individual chunk's Content-Type is non-text.",
"name" : "postParamData",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "param",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "BinaryType",
"modifier" : "PRESERVES_EMPTY",
"name" : "binary"
}
} ]
}
},
"member" : true
}
}, {
"doc" : "Sends this HTTP request to target URI asynchronously.",
"name" : "sendAsync",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "timeout",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "Duration"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise",
"refVarBindings" : [ {
"type" : "DeclaredReferenceType",
"name" : "HttpResponse"
} ]
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Sends this HTTP request to target URI synchronously (if supported by the runtime environment).",
"name" : "sendSync",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "timeout",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "Duration"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "HttpResponse"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Creates HttpResponse to this request based on provided C3 value",
"name" : "responseFromValue",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "valueType",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"inline" : true,
"member" : true
}
}, {
"doc" : "Creates HttpResponse to this request based on provided content",
"name" : "responseFromContent",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "content",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Content"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"inline" : true,
"member" : true
}
}, {
"doc" : "Creates an empty HttpResponse to this request",
"name" : "emptyResponse",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"inline" : true,
"member" : true
}
}, {
"doc" : "Creates 302 Found Redirect HttpResponse to this request",
"name" : "redirectResponse",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "url",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Url"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"inline" : true,
"member" : true
}
}, {
"doc" : "Creates 404 Not Found HttpResponse to this request",
"name" : "notFoundResponse",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"inline" : true,
"member" : true
}
}, {
"doc" : "Creates an error HttpResponse to this request",
"name" : "errorResponse",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "err",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Error"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"inline" : true,
"member" : true
}
}, {
"doc" : "Creates {@link ContentMeta} from headers in this request",
"name" : "contentMeta",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "contentLocation",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ContentMeta"
},
"inline" : true,
"member" : true
}
}, {
"name" : "toJava",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'org.apache.http.client.methods.HttpUriRequest'"
} ]
} ]
},
"private" : true,
"inline" : true,
"member" : true
}
}, {
"doc" : "Construct an Obj from this request's query string, parsing values from the query string as fields of the specified\ntype. Query parameters that don't correspond to fields are ignored and conversion failures are also ignored unless\nthe `failIfInvalid` parameter is true.\n\n@param type the Obj type to construct\n@param failIfInvalid if true, throw an error if any conversions fail",
"name" : "toObj",
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "O"
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type",
"metaRestriction" : {
"type" : "DeclaredReferenceType",
"name" : "O"
}
}
}, {
"name" : "failIfInvalid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O"
},
"member" : true
}
}, {
"doc" : "Construct an Obj from the specified query string, parsing values from the query string as fields of the specified\ntype. The query string should be standard format, without the leading `?`. Query parameters that don't correspond\nto fields are ignored and conversion failures are also ignored unless the `failIfInvalid` parameter is true.\n\n@param type the Obj type to construct\n@param query the query string to parse\n@param failIfInvalid if true, throw an error if any conversions fail\n\n@see #queryFromObj",
"name" : "queryToObj",
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "O"
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type",
"metaRestriction" : {
"type" : "DeclaredReferenceType",
"name" : "O"
}
}
}, {
"name" : "query",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfInvalid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O"
}
}
}, {
"doc" : "Construct a query string from the specified Obj instance. The query string is in standard format, without the\nleading `?`.\n\n@param inst the Obj inst as the source\n@return produced query string (may be empty, but not null)\n\n@see #queryToObj",
"name" : "queryFromObj",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "inst",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
}
}
}, {
"name" : "fromJava",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'java.lang.Object'"
} ]
} ],
"name" : "request",
"valueType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest"
},
"private" : true,
"inline" : true
}
} ],
"isWithType" : true,
"isObj" : true,
"isMutable" : false,
"isStateful" : false,
"isSingleton" : false,
"isDefaultInstance" : false,
"isAbstract" : false,
"hasEventStream" : false,
"isGeneric" : false,
"isNativeRemix" : false,
"hasVarBindings" : false,
"prototypeName" : "HttpRequest",
"typeSerName" : "type",
"hasSerNameFields" : false,
"annotations" : {
"type" : "Annotations"
},
"mixins" : [ "WithHttpHeaders", "Obj", "Serializable", "Value", "Fingerprintable", "MemoryMeasurable", "WithType", "Spec" ],
"referenceType" : {
"type" : "ReferenceType",
"name" : "HttpRequest"
},
"mixinsWithSourceCode" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders", "Obj", "WithType" ]
},
"fieldTypes" : [ {
"type" : "FieldType",
"doc" : "The internally used case-insensitive HTTP headers.",
"name" : "_headers",
"schemaSuffix" : "HDRS",
"private" : true,
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"isNumber" : false,
"instanceType" : "Map<string, [string]>"
}
}, {
"type" : "FieldType",
"doc" : "Parent HTTP client",
"name" : "client",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "ReferenceType",
"name" : "HttpClient",
"isNumber" : false,
"instanceType" : "HttpClient"
}
}, {
"type" : "FieldType",
"doc" : "The HTTP method to use.",
"name" : "method",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"isNumber" : false
}
}, {
"type" : "FieldType",
"doc" : "The URL to send the request.\nAlways required.",
"name" : "url",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Url"
},
"isNumber" : false
}
}, {
"type" : "FieldType",
"doc" : "The encoded body as binary for the request.",
"name" : "encodedBody",
"private" : true,
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "BinaryType",
"name" : "binary",
"isNumber" : false
}
} ],
"methods" : [ {
"type" : "Method",
"name" : "toJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a JSON object.\n\n@return JSON object representation\n\n@see #fromJson",
"name" : "toJson",
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"name" : "toJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"name" : "toJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
} ]
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ]
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"paramNames" : [ "include", "exclude" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "toTypedJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a _typed_ JSON object.\n@param omitTopLevelType\n       Whether to leave out `type: {{ type of this serializable instance }}` as the **first** key-value pair in\n       the outer level of the produced json.\n@param runtime\n       If provided, then any special serialization logic required for the {@link ImplLanguage.Runtime} will be\n       performed. **NOTE** This argument is ignored if `typed` is not `true`. @see Ann.Ser\n\n\n@return JSON object representation\n\n@see #fromJson\n@see #toJson\n@see serdeser.c3doc\n@see JsonType",
"name" : "toTypedJson",
"params" : [ {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"name" : "toTypedJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"name" : "toTypedJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toTypedJson",
"params" : [ {
"name" : "omitTopLevelTypeOrIncludeOrInclude",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
} ]
}
}, {
"name" : "actionRequirementOrExcludeOrExclude",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
}, {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
} ]
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"paramNames" : [ "omitTopLevelTypeOrIncludeOrInclude", "actionRequirementOrExcludeOrExclude" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "toJsonString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toJsonString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized JSON string.\n\n@return JSON object as string",
"name" : "toJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "pretty" ]
}
}, {
"type" : "Method",
"name" : "toTypedJsonString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toTypedJsonString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"name" : "toTypedJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toTypedJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "pretty", "omitTopLevelType" ]
}
}, {
"type" : "Method",
"name" : "toJsString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toJsString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized JavaScript object literal.\n\n@return JavaScript object literal string",
"name" : "toJsString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJsString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "withType" ]
}
}, {
"type" : "Method",
"name" : "toXmlString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toXmlString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized XML string.\n\n@return XML element as string\n\n@see #fromXmlString",
"name" : "toXmlString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toXmlString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "withType" ]
}
}, {
"type" : "Method",
"name" : "serialize",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a string serialized representation of the object.\n\n@return string serialized object representation",
"name" : "serialize",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "serialize",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "contentType" ]
}
}, {
"type" : "Method",
"name" : "fromJson",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the JSON-based representation and reconstruct the corresponding object.\n\nfromJson is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which may be\na type that mixes in the type on which it is called). This means that the resulting object's type will be isA the\ncalled-on type, but perhaps not identical. In particular, `Obj.fromJson` works for any actual type and will return\nan instance of the correct type.\n\n@see #toJson",
"name" : "fromJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "HttpRequest",
"mixing" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "json" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fromJsonString",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the JSON-based representation and reconstruct the corresponding object.\n\nfromJsonString is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which may be\na type that mixes in the type on which it is called). This means that the resulting object's type will be isA the\ncalled-on type, but perhaps not identical. In particular, `Obj.fromJsonString` works for any actual type and will return\nan instance of the correct type.\n\n@see #toJsonString",
"name" : "fromJsonString",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "HttpRequest",
"mixing" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromJsonString",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "json" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fromXmlString",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the XML-based representation and reconstruct the corresponding object.\n\nfromXmlString is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which\nmay be a type that mixes in the type on which it is called). This means that the resulting object's type will be\nisA the called type, but perhaps not identical. In particular, `Obj.fromXmlString` works for any actual type and\nwill return an instance of the correct type.\n\n@see #toXmlString",
"name" : "fromXmlString",
"params" : [ {
"name" : "xml",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "HttpRequest",
"mixing" : true
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromXmlString",
"params" : [ {
"name" : "xml",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "xml" ]
}
}, {
"type" : "Method",
"name" : "deserialize",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load from contentType representation and reconstruct the corresponding object.\n\nfromString is be called on the type be deserialized and must reconstruct an object of the appropriate type\n(which may be a type that mixes in the type on which it is called). This means that the resulting object's type\nwill be isA the called-on type, but perhaps not identical. In particular, `fromString` works for any actual\ntype and will return an instance of the correct type.",
"name" : "deserialize",
"params" : [ {
"name" : "contentStr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "HttpRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "deserialize",
"params" : [ {
"name" : "contentStr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "contentStr", "contentType" ]
}
}, {
"type" : "Method",
"name" : "fingerprint",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Produce a checksum that can easily be compared to determine if two objects are definitely different. Note that\nthere is a slight possibility that two objects with the same fingerprint will actually differ.\n\nThe fingerprint recurses into field values, including collections and referenced Objs. The handling of nested\n{@link Identified identified} references (typically entities) differ in that _only_ the `id` field is included\nunless the allIdentifiedRefFields option is specified.\n\nIf the object graph may contain recursive embedded object references, the trackRecursiveRefs option may be used.\nHowever, maintaining the list of visited objects is costly so this should not be done unnecessarily.\n\n@param allIdentifiedRefFields\n          if `true`, fingerprint individual fields of persistable references, not just the `id`\n@param trackRecursiveRefs\n          if `true`, a set of referenced objects is maintained to avoid infinite recursion\n@param traversedRefs\n          only considered together with trackRecursiveRefs and if provided then all traversed references are\n          checked against and added to it\n@return integer fingerprint\n\n@see https://en.wikipedia.org/wiki/Fingerprint_(computing)",
"name" : "fingerprint",
"params" : [ {
"name" : "allIdentifiedRefFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "trackRecursiveRefs",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "traversedRefs",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<Obj>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fingerprint",
"params" : [ {
"name" : "allIdentifiedRefFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "trackRecursiveRefs",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "traversedRefs",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<Obj>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"paramNames" : [ "allIdentifiedRefFields", "trackRecursiveRefs", "traversedRefs" ]
}
}, {
"type" : "Method",
"name" : "retainedMemory",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Measures retained memory by this instance.\n\n@param deep\n       if true and this instance contains references to other objects also measures memory retained by those\n@param allMeasured\n       if set then will skip instances that are in the set and will add instances that where measured by this call\n@return retained memory in bytes for this instances",
"name" : "retainedMemory",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "allMeasured",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<any>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "retainedMemory",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "allMeasured",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<any>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"paramNames" : [ "deep", "allMeasured" ]
}
}, {
"type" : "Method",
"name" : "type",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "C3 Type of this instance.",
"name" : "type",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "type",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "replaceType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns new instance with all references to old type, including result of #type, replaced with new type. If new\ntype does not contain fields from old or field value types are not convertable then drops the field.\n\nThis method is used during live metadata update",
"name" : "replaceType",
"params" : [ {
"name" : "old",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "new",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "replaceType",
"params" : [ {
"name" : "old",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "new",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "old", "new" ]
}
}, {
"type" : "Method",
"name" : "super",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithType" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithType"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : " Produce a calling proxy that represents the content of all Obj type's mixins, but not the type itself. This is\n useful for redispatching **member** methods reimplemented on this type to a parent implementation:\n ```js\n function toString() {\n   return this.super().toString() + ', x=' + this.x;\n }\n ```\n\n ```py\n def toString(this):\n    return this.super().toString() + ', x=' + this.x\n```\n\n To redispatch **static** methods, see {@link Type#super}.\n\n Note that this not the same as the language-specific `super` keyword because it works through the type system and\n supports multiple mixins. It behaves like the Python `super()` function, except called on the instance rather than\n globally.\n\n If `mixin` is the implementing type in a client implementation, this will delegate the call to the server.\n This can be used to create a local implementation \"around\" the server implementation for additional caching or\n other local state management.\n\n @param mixin if specified, this mixin is used instead or an error is thrown\n @return \"super\" calling proxy for this object\n\n @see Type.super",
"name" : "super",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "ReferenceType",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "super",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "ReferenceType",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"paramNames" : [ "mixin" ]
},
"$nearestImplementedOn" : "WithType"
}, {
"type" : "Method",
"name" : "instanceOf",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Checks whether this Obj is an instance of the specified type by checking both its type and the mixin chain.\nThis is the most convenient way to ask \"is this type usable in a context requiring the other type?\"\n\n@return true if this instance is of this type or any of its mixins",
"name" : "instanceOf",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Checks whether this instance is an instance of the specified type by checking both its type and the mixin chain.\nThis is the most convenient way to ask \"is this type usable in a context requiring the other type?\"\n\n@return true if this instance is of this type or any of its mixins\n\n@see ValueType#isA",
"name" : "instanceOf",
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "instanceOf",
"params" : [ {
"name" : "typeNameOrType",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ]
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "typeNameOrType" ]
}
}, {
"type" : "Method",
"name" : "isEmptyObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether all the fields of this instance are empty.",
"name" : "isEmptyObj",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isEmptyObj",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "isSame",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether the specified instance represents exactly the same object as this instance.",
"name" : "isSame",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isSame",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "other" ]
}
}, {
"type" : "Method",
"name" : "fieldValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns value of the given field.\n\n@param field\n          Field to return the value for\n       defaultToEmpty\n          will return default empty value if field is missing",
"name" : "fieldValue",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Returns value of the given field type. Be sure to use the FieldType instance for the exact same type as the type of\nthe obj.\n\n@param field\n          Field to return the value for\n       defaultToEmpty\n          will return default empty value if field is missing\n@return value for the given field",
"name" : "fieldValue",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValue",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
} ]
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "field", "defaultToEmpty" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fieldValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldValue"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all non empty field values. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValues",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldValue"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValues",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldValue"
}
}
}
}, {
"type" : "Method",
"name" : "fieldValuesByOrdinal",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all field values including empty ones as array where value of a field is at corresponding ordinal position.\nUnless `skipTrailingEmpty` parameter is set and there are trailing empty values resulting array has same size as\n#dataFieldTypes",
"name" : "fieldValuesByOrdinal",
"params" : [ {
"name" : "skipTrailingEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesByOrdinal",
"params" : [ {
"name" : "skipTrailingEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"paramNames" : [ "skipTrailingEmpty" ]
}
}, {
"type" : "Method",
"name" : "fieldValuesByFieldType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all non empty field values by field type. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValuesByFieldType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesByFieldType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
}
}, {
"type" : "Method",
"name" : "fieldValuesByFieldName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all non empty field values by field name. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValuesByFieldName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesByFieldName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}
}, {
"type" : "Method",
"name" : "fieldNames",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all data field names including those whose values are empty. Array is ordered by field ordinal.",
"name" : "fieldNames",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldNames",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}
}, {
"type" : "Method",
"name" : "at",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return value of the field at provided ordinal\n\n@param ordinal\n        Integer ordinal of the field in the parent type\n@return value of field at ordinal",
"name" : "at",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "ordinal",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Return value for the given serialized expression\n\n@param expr\n        Serialized expression to obtain the value in the given Obj\n@param failIfNotValid\n        If set, fails if not a valid expression\n@return value obtained as a result of expression evaluation",
"name" : "at",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "expr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
}, {
"name" : "failIfNotValid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "at",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "ordinalOrExpr",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
}, {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
} ]
}
}, {
"name" : "failIfNotValid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "ordinalOrExpr", "failIfNotValid" ]
}
}, {
"type" : "Method",
"name" : "fieldValueAtPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Looks up a single field value by path from this Obj. Field paths are separated by dots so an expression like\n`fieldValueAtPath(\"location.elevation\")` is equivalent to `traverse(\"location\").fieldValue(\"elevation\")` except\nthat it also handles `null`. If path contains any collections then only first element will be traversed,\nunless the collection index is specified in the path.\n\nIf you need to traverse all elements of collection fields use #fieldValuesAtPath instead.\n\n@param fieldPath\n          field names separated by dots\n@param failIfNotFound\n          if true, an error will be thrown if the any of the field types aren't defined\n@param context\n          if an error is thrown, the context returned by calling the lambda will be incorporated\n@return the field or null",
"name" : "fieldValueAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValueAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "fieldPath", "failIfNotFound", "context" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fieldValuesAtPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "VarReferenceType",
"name" : "T"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Looks up all the fields by path from root Obj. If path contains any collections then result will contain all\ntraversals, unless the collection index is specified in the path.\n\n@param fieldPath\n          field names separated by dots\n@param failIfNotFound\n          if true, an error will be thrown if the any of the field types aren't defined\n@param context\n          if an error is thrown, the context returned by calling the lambda will be incorporated\n@return fields as a flat list\n\n@see #fieldValueAtPath",
"name" : "fieldValuesAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "VarReferenceType",
"name" : "T"
}
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "VarReferenceType",
"name" : "T"
}
},
"paramNames" : [ "fieldPath", "failIfNotFound", "context" ]
}
}, {
"type" : "Method",
"name" : "eachFieldValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Perform an action for each non-empty field of this object.\n\n@param action\n          lambda to apply",
"name" : "eachFieldValue",
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Perform an action for each field of this object. Fields are filtered based on provided `spec`.\n\n@param spec\n          which fields to include\n@param action\n          lambda to apply",
"name" : "eachFieldValue",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachFieldValue",
"params" : [ {
"name" : "actionOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"paramNames" : [ "actionOrSpec", "action" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "eachFieldValueWhile",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Perform an action for each field of this object while processing action returns `true`. Fields are filtered based\non provided `spec`.\n\n@param spec\n          which fields to include\n@param action\n          lambda to apply; stop if this `action` returns `false\n@return `true` if iteration was not aborted by lambda i.e. it saw all field values",
"name" : "eachFieldValueWhile",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachFieldValueWhile",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "spec", "action" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "eachRef",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type. For reference fields, this means\nthe field value if non-null and for collections of Obj, this means each element in the collection.\n\n@param action\n          function to be executed for each pair of field type and Obj instance",
"name" : "eachRef",
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type. For reference fields, this means\nthe field value if non-null and for collections of Obj, this means each element in the collection.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param action\n          function to be executed for each pair of field type and Obj instance",
"name" : "eachRef",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRef",
"params" : [ {
"name" : "actionOrIncludeEmpty",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
}, {
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ]
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"paramNames" : [ "actionOrIncludeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "eachRefWhile",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type while processing action returns\n`true`.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param action\n          function to be executed for each pair of field type and Obj instance; stops processing if return `false`\n@return `true` if iteration was not aborted by lambda i.e. it saw all refs",
"name" : "eachRefWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRefWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "includeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "eachRefRecursive",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type or in any child refs.",
"name" : "eachRefRecursive",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRefRecursive",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"paramNames" : [ "includeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "eachRefRecursiveWhile",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type or in any child refs. Continue while\nprocessing action returns `true`.",
"name" : "eachRefRecursiveWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRefRecursiveWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "includeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "mapFieldValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Result of this function call is a copy of current instance with all non empty fields replaced based on results of\nthe `mapper` invocation.\n\n@param action\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValues",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Result of this function call is a copy of current instance with all fields replaced based on results of the\n`mapper` invocation.\n\n@param spec\n          which fields to include\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValues",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapFieldValues",
"params" : [ {
"name" : "mapperOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "convertValueOrMapper",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ]
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "mapperOrSpec", "convertValueOrMapper", "convertValue" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapFieldValuesAsync",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing HttpRequest>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Result of this function call is a copy of current instance with all non empty fields replaced based on results of\nthe asynchronous `mapper` invocation.\n\n@param action\n          lambda to apply for every field value to produce a new value for that fields\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValuesAsync",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing HttpRequest>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Result of this function call is a copy of current instance with all fields replaced based on results of the\nasynchronous `mapper` invocation.\n\n@param spec\n          which fields to include\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValuesAsync",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing HttpRequest>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"name" : "mapFieldValuesAsync",
"params" : [ {
"name" : "mapperOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "convertValueOrMapper",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
} ]
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing HttpRequest>",
"hadDeclaredVarBindings" : true
},
"paramNames" : [ "mapperOrSpec", "convertValueOrMapper", "convertValue" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapFieldValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Result of this function call is a copy of current instance with specified field value replaced based on result of\nthe `mapper` invocation.\n@param field\n          field being mapped\n@param includeEmpty\n          if set, invokes mapper for fields with empty value\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValue",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapFieldValue",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "field", "includeEmpty", "mapper", "convertValue" ]
}
}, {
"type" : "Method",
"name" : "mapRefs",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Executes the specified lambda against each referenced Obj instance and replaces it's value with result of this\nlambda application.\n\nResult of this function call is a copy of current instance with all references replaced based on results of the\n`mapper` invocation.\n\n@param action\n          function to be executed for each pair of field type and Obj instance\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapRefs",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Executes the specified lambda against each referenced Obj instance and replaces it's value with result of this\nlambda application.\n\nResult of this function call is a copy of current instance with all references replaced based on results of the\n`mapper` invocation.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param mapper\n          function to be executed for each pair of field type and Obj instance for producing new reference value\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapRefs",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapRefs",
"params" : [ {
"name" : "mapperOrIncludeEmpty",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
}, {
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ]
}
}, {
"name" : "convertValueOrMapper",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
} ]
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "mapperOrIncludeEmpty", "convertValueOrMapper", "convertValue" ]
}
}, {
"type" : "Method",
"name" : "foldFieldValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Result of this function is application of `folder` lambda to every non empty field value where `accumulator`\nargument is a result of previous application. Initial value of `accumulator` will be `null`.\n\nThis function is useful for calculating aggregate values based on all current non empty field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Result of this function is application of `folder` lambda to every non empty field value where `accumulator`\nargument is a result of previous application. Initial value of `accumulator` is provided via `initial` parameter.\n\nThis function is useful for calculating aggregate values based on all current non empty field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "initial",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Result of this function is application of `folder` lambda to every field value where `accumulator` argument is a\nresult of previous application. Initial value of `accumulator` is provided via `initial` parameter.\n\nThis function is useful for calculating aggregate values based on all field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "initial",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}, {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "folderOrInitialOrInitial",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
}, {
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ]
}
}, {
"name" : "folderOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "folderOrInitialOrInitial", "folderOrSpec", "folder" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "evalProjection",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "AnyType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Evaluates given projection expression over this instance.",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
}, {
"name" : "resultType",
"valueType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "AnyType"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Evaluates given projection over this instance and returns results as json.",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "JsonType",
"name" : "json"
},
"inline" : true,
"member" : true,
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Evaluates given projection over this instance and returns results as instance of the new Obj.",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
}, {
"name" : "resultType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
},
"inline" : true,
"member" : true,
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
}, {
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
} ]
}
}, {
"name" : "resultTypeOrBindingsOrResultType",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
}, {
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
} ]
}
}, {
"name" : "bindingsOrOptionsOrBindings",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ]
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "AnyType"
},
"paramNames" : [ "projection", "resultTypeOrBindingsOrResultType", "bindingsOrOptionsOrBindings", "options" ]
}
}, {
"type" : "Method",
"name" : "validateObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjResult"
}
} ]
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Populates all missing default values and throws error if any constraint it violated.",
"name" : "validateObj",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Validate that the Obj fields are set according to all the required rules.",
"name" : "validateObj",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjSpec"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjResult"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "validateObj",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjSpec"
}
} ],
"returnType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjResult"
}
} ]
},
"paramNames" : [ "spec" ]
}
}, {
"type" : "Method",
"name" : "withField",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the provided field in it. The name must correspond to an existing field\ndefined on this type or its mixins. The value must be of the correct type if doNotConvert flag is true.\n\n@param field\n          name of the field\n@param value\n          of the field\n@param doNotConvert\n          if true, do not attempt to convert the value to match the field's type\n@return new Obj",
"name" : "withField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the provided field in it. The name must correspond to an existing field\ndefined on this type or its mixins. The value must be of the correct type if doNotConvert flag is true.\n\n@param field\n          the field\n@param value\n          of the field\n@param doNotConvert\n          if true, do not attempt to convert the value to match the field's type\n@return new Obj",
"name" : "withField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
} ]
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "field", "value", "doNotConvert" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "withFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the provided fields in it. The name must correspond to an existing fields\ndefined on this type or its mixins. The values must be of the correct type if doNotConvert flag is true.\n\n@param fields\n          map of fields name/values\n@param doNotConvert\n          if true, attempt to convert the values to match the fields' type\n@return new Obj",
"name" : "withFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "fields", "doNotConvert" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "withFieldAtPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj with the value at the specified path field. If the value is null, the final field is removed.\n\nImmutable objects may return the same instance if the field being set or removed does not actually represent a\nchange to the existing object.\n\n@param path\n          path to set value at\n@param value\n          value to set\n@param doNotConvert\n          if true, attempt to convert the values to match the fields' type\n@param doNotCreateIfMissing\n          true indicates that any empty reference along the path will not set the value\n@return new Obj",
"name" : "withFieldAtPath",
"params" : [ {
"name" : "path",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "doNotCreateIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withFieldAtPath",
"params" : [ {
"name" : "path",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "doNotCreateIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "path", "value", "doNotConvert", "doNotCreateIfMissing" ]
}
}, {
"type" : "Method",
"name" : "withoutField",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the field with the provided name.\n\nImmutable objects may return the same instance if the field being removed is not present in the existing object.\n\n@param name\n          of the field to remove\n@return new Obj with removed field",
"name" : "withoutField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the field with the provided field type.\n\nImmutable objects may return the same instance if the field being removed is not present in the existing object.\n\n@param field\n          of the field to remove\n@return new Obj with removed field",
"name" : "withoutField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
} ]
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "field" ]
}
}, {
"type" : "Method",
"name" : "withoutFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the fields with the provided names.\n\nImmutable objects may return the same instance if the fields being removed are not present in the existing object.\n\n@param names\n          of the fields to remove\n@return new Obj with removed fields",
"name" : "withoutFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "withoutFieldsByType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the fields with the provided field types. Be sure to use the FieldType instance for the\nexact same type as the type of the obj to respect the \"ordinal\" of the field type\n\nImmutable objects may return the same instance if the fields being removed are not present in the existing object.\n\n@param fields\n          of the fields to remove\n@return new Obj with removed fields",
"name" : "withoutFieldsByType",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutFieldsByType",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "withDefaults",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the default values (if defined) for all empty fields. This is implemented by\ncalling {@link FieldType#defaultValue defaultValue} for a field if it is not already set and\n{@link FieldType#hasDefault has a default}. It will also set {@see ValueType#initialValue initial values} for\nfields with required primitive ValueTypes (E.g. x: `!int32` -> will be set to 0). Note that this will not overwrite\nfields that have already been set.\n\n{@link FunctionParam#validateArg} will call {@link #withDefaults} for {@link Spec}s passed as arguments to methods.\nAs a result, methods should be implemented assuming all default values are set on `Spec` arguments.\n\n@param includeEmptyRefsWithDefaults\n          it `true` then missing / empty child references that have fields with defaults will also be instantiated\n@param defaultFields\n          If not empty, a list of default field paths to populate.  Any default fields not specified in the\n          array will be ignored.\n@return new Obj\n\n@see FieldType#defaultValueConst\n@see FieldType#defaultValue",
"name" : "withDefaults",
"params" : [ {
"name" : "includeEmptyRefsWithDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "defaultFields",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withDefaults",
"params" : [ {
"name" : "includeEmptyRefsWithDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "defaultFields",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "includeEmptyRefsWithDefaults", "defaultFields" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mergeObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Merges all the fields of the provided Obj into this instance, producing a new Obj of the same type as this one.\nIn case of conflicts, fields of other instance take precedence unless otherwise specified by the fieldPathMergeSpec\n\n@param other\n          object\n@param fieldPathMergeSpec\n          mapping of fields of the object to the respective merge annotations\n@return the new merged Obj",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "fieldPathMergeSpec",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Merges all the fields of the provided Obj into this instance, producing a new Obj of the same type as this one.\nIn case of conflicts, fields of other instance take precedence.\n\n@param other\n          object\n@param otherFieldsFilter\n          only fields of otherFieldsFilter type from other are merged into this obj.\n@return the new merged Obj",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "otherFieldsFilter",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Merge the fields of this Obj with corresponding fields on other Obj using the provided lambda. This means that\nfields that exist on other Obj and do not exist on this Obj will not be added to final Obj.\n@param deep\n       if set to true then traverse reference and collection fields and merge corresponding fields or elements with\n       the same key or index.",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 2
}, {
"type" : "MethodType",
"doc" : "Merge the fields of this Obj with corresponding fields on other Obj using the provided lambda. This means that\nfields that exist other Obj and do not exist on this Obj will not be added to final Obj or evaluated. Does not\ntraverse child reference and collection fields.",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 3
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "fieldPathMergeSpecOrOtherFieldsFilterOrDeepOrMerger",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ]
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "other", "fieldPathMergeSpecOrOtherFieldsFilterOrDeepOrMerger", "merger" ]
}
}, {
"type" : "Method",
"name" : "mergeAndExpandObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Create new Obj with all non-null fields of this and other. Fields that are non null in both apply merger lambda.\nFields that non null in only one of this and other will be in the resulting Obj without change.",
"name" : "mergeAndExpandObj",
"genericVars" : [ {
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeAndExpandObj",
"genericVars" : [ {
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"paramNames" : [ "other", "merger" ]
}
}, {
"type" : "Method",
"name" : "mergeJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "mergeJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "json" ]
}
}, {
"type" : "Method",
"name" : "mergeChildren",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Merge the obj references within the current obj\n@param deep\n       If set, traverses the reference fields within the obj as well for a deep merge\n@param objKey\n       lambda specifying how to obtain the key for the Obj while determining which Objs to merge\n@param filter\n       Field paths that need to be filtered from this merge\n@return Obj with child references merged",
"name" : "mergeChildren",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "objKey",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "child",
"valueType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "filter",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeChildren",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "objKey",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "child",
"valueType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "filter",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "deep", "objKey", "filter" ]
}
}, {
"type" : "Method",
"name" : "sumObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds the numeric Obj fields with the other Objs respective fields.\nIf deep is set it will traverse reference and collection fields and sum corresponding numeric fields in\nreferences with same name and collection elements at same index or key.",
"name" : "sumObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "sumObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "other", "deep" ]
}
}, {
"type" : "Method",
"name" : "singletonArray",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "HttpRequest",
"mixing" : true
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Build an array of the correct type with a single element which is this instance.\n\n@return new array instance with this as only element.",
"name" : "singletonArray",
"returnType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "HttpRequest",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"name" : "singletonArray",
"returnType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "HttpRequest",
"mixing" : true
}
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "array",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "HttpRequest",
"mixing" : true
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an array of instances of this type.",
"name" : "array",
"params" : [ {
"name" : "elements",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "HttpRequest",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "array",
"params" : [ {
"name" : "elements",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "HttpRequest",
"mixing" : true
}
},
"paramNames" : [ "elements" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "arrayBuilder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "ArrayBuilder<mixing HttpRequest>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an array of instances of this type.",
"name" : "arrayBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "ArrayBuilder<mixing HttpRequest>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "arrayBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "ArrayBuilder<mixing HttpRequest>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "singletonSet",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "SetType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "HttpRequest",
"mixing" : true
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Build an set of the correct type with a single element which is this instance.\n\n@return new array instance with this as only element.",
"name" : "singletonSet",
"returnType" : {
"type" : "SetType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "HttpRequest",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"name" : "singletonSet",
"returnType" : {
"type" : "SetType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "HttpRequest",
"mixing" : true
}
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "setBuilder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<mixing HttpRequest>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates a set of instances of this type.",
"name" : "setBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<mixing HttpRequest>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "setBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<mixing HttpRequest>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapBuilder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<string, mixing HttpRequest>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Create a map of string to elements of this type.",
"name" : "mapBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<string, mixing HttpRequest>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<string, mixing HttpRequest>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapBuilderOf",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<any, mixing HttpRequest>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Create a map with the given key type and elements of this type.",
"name" : "mapBuilderOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<any, mixing HttpRequest>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapBuilderOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<any, mixing HttpRequest>",
"hadDeclaredVarBindings" : true
},
"paramNames" : [ "keyType" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "myReferenceType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myReferenceType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myReferenceType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
}
}
}, {
"type" : "Method",
"name" : "myMapTypeOf",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myMapTypeOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myMapTypeOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"paramNames" : [ "keyType" ]
}
}, {
"type" : "Method",
"name" : "myMapType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myMapType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myMapType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
}
}
}, {
"type" : "Method",
"name" : "myArrayType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myArrayType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myArrayType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
}
}
}, {
"type" : "Method",
"name" : "mySetType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "mySetType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mySetType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
}
}
}, {
"type" : "Method",
"name" : "myStreamType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myStreamType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myStreamType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
}
}
}, {
"type" : "Method",
"name" : "toBuilder",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing HttpRequest>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return new ObjBuilder with initial state set to fields of this instance.",
"name" : "toBuilder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing HttpRequest>",
"hadDeclaredVarBindings" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toBuilder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing HttpRequest>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "builder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing HttpRequest>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return new ObjBuilder of this instance.",
"name" : "builder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing HttpRequest>",
"hadDeclaredVarBindings" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "builder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing HttpRequest>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fromFields",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type from provided fields\n@param fields\n           Fields to construct the instance of the obj with\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0) populated\n\n@see withDefaults",
"name" : "fromFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "fields", "withDefaults" ]
}
}, {
"type" : "Method",
"name" : "make",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type with no non-default field values unless explicitly specified by passing param true\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0)\n           populated\n\n@see withDefaults",
"name" : "make",
"params" : [ {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Construct an instance from provided fields\n@param fields\n           Fields (in the format <field_name, value>) to construct an instance of the obj. Note that \"type\" as a\n           field_name will be considered as the actual Obj's type, e.g. Obj.make({\"type\": \"Panda\"}) is equivalent\n           to Panda.make()\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32\n           -> 0) populated. Passing an empty value for a field will result in the default field value being set if\n           the field does not {@link ValueModifier#PRESERVES_EMPTY preserve empty} and {@link FieldType#hasDefault\n           has a default value}.\n\n\n@see fromFields\n@see beforeMake\n@see afterMake\n@see withDefaults",
"name" : "make",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : " Construct an instance of this type from provided fields. Note it is more efficient to use #fromFields and other overloads\n\n ```js\n User.make({\n   email: 'joe@smith.com',\n   realName: 'Joe Smith'\n })\n\n Obj.make({\n   type: 'User',\n   email: 'joe@smith.com',\n   realName: 'Joe Smith'\n })\n ```\n\n ```py\n c3.User.make({\n   \"email\": 'joe@smith.com',\n   \"realName\": 'Joe Smith'\n })\n\n c3.Obj.make({\n   \"type\": 'User',\n   \"email\": 'joe@smith.com',\n   \"realName\": 'Joe Smith'\n })\n\n c3.User(email='joe@smith.com', realName='Joe Smith')\n\n c3.Obj(type='User', email='joe@smith.com', realName='Joe Smith')\n```\n\n Note that this is **not** the same as the [serialization format](serdeser.c3doc). This is a convenient way to\n specify fields and values in the \"JSON like\" form supported by each language, but the usual serialization rules,\n such as {@link Ann.Ser} do not apply.\n @param fields\n            Fields to construct the instance of the obj with\n @param withDefaults\n            If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0) populated\n\n @see fromFields\n @see beforeMake\n @see afterMake\n @see withDefaults",
"name" : "make",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "make",
"params" : [ {
"name" : "withDefaultsOrFieldsOrFields",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "withDefaultsOrFieldsOrFields", "withDefaults" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "remake",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type from provided instance of a subtype or a \"duck type\".",
"name" : "remake",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "failIfExtraOrInvalidFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "remake",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "failIfExtraOrInvalidFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "other", "failIfExtraOrInvalidFields" ]
}
}, {
"type" : "Method",
"name" : "remakeAs",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an obj of the new type with all fields that exist on the original obj that are defined in the new type\nconverted and copied to the new obj instance. Note, that checking assignability and conversion of field values\ncould be costly if types have different value types for same fields.\n\n@param type\n        Type of new obj to return\n@return new obj of the requested type with all fields present in the original obj that are defined in the new type\n        converted and copied to it",
"name" : "remakeAs",
"genericVars" : [ {
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "remakeAs",
"genericVars" : [ {
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"paramNames" : [ "type" ]
}
}, {
"type" : "Method",
"name" : "beforeMake",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : true,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : false,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Optional override that will be called every time instance of this type is created.\n\n\nNote that it introduces additional overhead so should only be implemented for low volume data.",
"name" : "beforeMake",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"private" : true,
"optional" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "beforeMake",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "afterMake",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Optional override that will be called after every instance creation.\n\nNote that it introduces additional overhead so should only be implemented for low volume data.",
"name" : "afterMake",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "afterMake",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
}
}
}, {
"type" : "Method",
"name" : "cachedEmptyInst",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an empty inst using `MyType.make()` and caches it. Avoid recreating multiple copies of the spec for\nevery action dispatch. The cached inst can also be used for comparing whether the object is an empty or not\nWill only create empty instance for immutable Obj e.g. if an Obj is Mutable, this method will throw an error\n\n@see ValueType#defaultEmptyValue",
"name" : "cachedEmptyInst",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "cachedEmptyInst",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
}
}
}, {
"type" : "Method",
"name" : "toData",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Data"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Represent the current obj instance as {@link Data}",
"name" : "toData",
"returnType" : {
"type" : "ReferenceType",
"name" : "Data"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toData",
"returnType" : {
"type" : "ReferenceType",
"name" : "Data"
}
}
}, {
"type" : "Method",
"name" : "header",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns the header value for a header containing a single value.\n\n@param @required name\n          The header name, case insensitive\n@param dflt\n          The default value to return if the header does not exist\n@return The header value, or values concatenated together by ', ' if multiple, or dflt if not found.",
"name" : "header",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "dflt",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "header",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "dflt",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "name", "dflt" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "headers",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns the header values for a header containing potentially multiple values.\n\n@param @required name\n          the header name, case insensitive\n@return The header values array if header is found, else empty array.",
"name" : "headers",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "headers",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"paramNames" : [ "name" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "allHeaders",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns the headers map with the lower-case header and list of values",
"name" : "allHeaders",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "allHeaders",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "allHeadersMerged",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns headers map with keys of the lower-case header and value the result of the predicate. If predicate is not\nprovided, it will combine all headers with a \", \" except it will skip the set-cookie header if its present.\n\n@param merger\n          the optional function used to turn the array of header values to a string value. If the predicate returns\n          an empty value, it will not be added to the output.\n@return The headers map with keys of the lower-case header and value the result of the predicate",
"name" : "allHeadersMerged",
"params" : [ {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "header",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"name" : "values",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "allHeadersMerged",
"params" : [ {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "header",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"name" : "values",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"paramNames" : [ "merger" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "findFirstHeaderValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns the first header value satisfied by the given predicate.\n\n@param name\n          the header name (case-insensitive)\n@param predicate\n          the condition used to find the header value. If null the first header value found will be used\n@return The first matching header value for name or null if not found.",
"name" : "findFirstHeaderValue",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "predicate",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "v",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "findFirstHeaderValue",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "predicate",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "v",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "name", "predicate" ]
}
}, {
"type" : "Method",
"name" : "findAllHeaderValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns the header values satisfied by the given predicate.\n\n@param name\n          the header name (case-insensitive)\n@param predicate\n          the condition used to find the header values. If null the all header values for name will be returned\n@return All matching header values for name or null if not found.",
"name" : "findAllHeaderValues",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "predicate",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "v",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "findAllHeaderValues",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "predicate",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "v",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"paramNames" : [ "name", "predicate" ]
}
}, {
"type" : "Method",
"name" : "contentType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "The content type for these headers.",
"name" : "contentType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "contentType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "contentEncoding",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "The content encoding for these headers.",
"name" : "contentEncoding",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "contentEncoding",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "cookieValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Gets the cookie value from Http headers by a given cookie key.\n\n@param key\n          cookie key\n@return The cookie value or null if not found.",
"name" : "cookieValue",
"params" : [ {
"name" : "key",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "cookieValue",
"params" : [ {
"name" : "key",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "key" ]
}
}, {
"type" : "Method",
"name" : "replaceHeader",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Sets the header to (only) the specified value. This will wipe out any prior setting of this header, replacing it\nwith just this value. This is useful to _change_ a header value, instead of adding another value.\n\n@param name\n          header name (case-insensitive)\n@param value\n          replacement header value\n@return The new {@link WithHttpHeaders} object with name and value applied\n\n@see #withHeader\n@see #withoutHeader",
"name" : "replaceHeader",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "replaceHeader",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "name", "value" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withHeader",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds a header value into the existing headers. If called multiple times with the same header name, all values\nwill be added in the order they were called with duplicates removed.\n\n@param name\n          header name (case-insensitive)\n@param value\n          additional header value\n@return The new {@link WithHttpHeaders} object with name and value applied\n\n@see #replaceHeader\n@see #withoutHeader",
"name" : "withHeader",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withHeader",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "name", "value" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withoutHeader",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Removes all values from the existing header.\n\n@param name\n          header name (case-insensitive)\n@return The new {@link WithHttpHeaders} object with header removed\n\n@see #withHeader\n@see #replaceHeader",
"name" : "withoutHeader",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutHeader",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "name" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withHeaders",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Puts multiple header values into the existing headers. If the map has keys that collide in a case-insensitive way,\nthe order of the values may not be preserved, but duplicate values will be removed.\n\n@param headers\n          a map where the key is a header and value is one or many string values for that header.\n@return A modified {@link WithHttpHeaders} object with the headers applied",
"name" : "withHeaders",
"params" : [ {
"name" : "headers",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ]
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withHeaders",
"params" : [ {
"name" : "headers",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ]
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "headers" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withJsonHeaders",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds \"Accept\" and \"ContentType\" headers as \"application/json\".",
"name" : "withJsonHeaders",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withJsonHeaders",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
}
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withActionEngineHeader",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Add a \"X-C3-Action-Engine\" header appropriate to the current execution environment.",
"name" : "withActionEngineHeader",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withActionEngineHeader",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
}
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withAuthHeader",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Add Authorization header to this HTTP header.",
"name" : "withAuthHeader",
"params" : [ {
"name" : "auth",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Authorization"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withAuthHeader",
"params" : [ {
"name" : "auth",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Authorization"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "auth" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withContentType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds a content type to this HTTP header. Will silently not add contentType if it is empty.",
"name" : "withContentType",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withContentType",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "contentType" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withContentEncoding",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds a content encoding type to this HTTP header. Will silently not add contentEncoding if it is empty.",
"name" : "withContentEncoding",
"params" : [ {
"name" : "contentEncoding",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentEncoding"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withContentEncoding",
"params" : [ {
"name" : "contentEncoding",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentEncoding"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "contentEncoding" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "body",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : true,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Content"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "The entity body as {@link Content} for the request. Required for POST and PUT; ignored by GET.\nFor usage examples, see {@link HttpRequest.c3poly.md#body}.",
"name" : "body",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Content"
},
"cached" : true,
"inline" : true,
"member" : true,
"property" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "body",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Content"
}
}
}, {
"type" : "Method",
"name" : "hasBody",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "HttpRequest" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "HttpRequest"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Checks body is present.",
"name" : "hasBody",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasBody",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
},
"$nearestImplementedOn" : "HttpRequest"
}, {
"type" : "Method",
"name" : "readBodyString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "HttpRequest" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "HttpRequest"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Read the entity body as String.",
"name" : "readBodyString",
"params" : [ {
"name" : "failIfNotText",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "readBodyString",
"params" : [ {
"name" : "failIfNotText",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
},
"paramNames" : [ "failIfNotText" ]
},
"$nearestImplementedOn" : "HttpRequest"
}, {
"type" : "Method",
"name" : "withBody",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "HttpRequest" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "HttpRequest"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds a body from the {@link Content} to this HTTP request. This sets the #encodedBody field as well as the\n`Content-Type` and `Content-Encoding` headers from the values in the content.",
"name" : "withBody",
"params" : [ {
"name" : "body",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Content"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Adds a body from the binary value, content type, and encoding. This sets the #encodedBody field as well as the\n`Content-Type` and `Content-Encoding` headers to the specified values.",
"name" : "withBody",
"params" : [ {
"name" : "encodedBody",
"valueType" : {
"type" : "BinaryType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "binary"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
}, {
"name" : "contentEncoding",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "ContentEncoding"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withBody",
"params" : [ {
"name" : "bodyOrEncodedBody",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Content"
}
}, {
"valueType" : {
"type" : "BinaryType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "binary"
}
} ]
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
}, {
"name" : "contentEncoding",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "ContentEncoding"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "bodyOrEncodedBody", "contentType", "contentEncoding" ]
},
"$nearestImplementedOn" : "HttpRequest"
}, {
"type" : "Method",
"name" : "withBodyString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "HttpRequest" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "HttpRequest"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds a body from the string value, content type, and encoding. This sets the #encodedBody field as well as the\n`Content-Type` and `Content-Encoding` headers to the specified values.",
"name" : "withBodyString",
"params" : [ {
"name" : "body",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
}, {
"name" : "contentEncoding",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "ContentEncoding"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withBodyString",
"params" : [ {
"name" : "body",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
}, {
"name" : "contentEncoding",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "ContentEncoding"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"paramNames" : [ "body", "contentType", "contentEncoding" ]
},
"$nearestImplementedOn" : "HttpRequest"
}, {
"type" : "Method",
"name" : "queryString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return the query string for a GET request. This will not include the leading `?` and will be null if there is none\nat all.",
"name" : "queryString",
"returnType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "queryString",
"returnType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "queryParam",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return all values for one single query parameter, one value for each time the param is used or assigned. If the\nusage is without an equal sign, it will have a null value in the array.",
"name" : "queryParam",
"params" : [ {
"name" : "param",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "queryParam",
"params" : [ {
"name" : "param",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
}
},
"paramNames" : [ "param" ]
}
}, {
"type" : "Method",
"name" : "postParamContent",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Content"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return all values for one single POST parameter, one value for each time the param is used or assigned.\nThis supports the content types `application/x-www-form-urlencoded` and `multipart/form-data` only.\n\nFor `application/x-www-form-urlencoded`, if the usage is without an equal sign, it will have a null value in the\narray.\n\nThis method returns the {@link Content} instances, which preserve the content type specified in the\n`multipart/form-data` chunks.",
"name" : "postParamContent",
"params" : [ {
"name" : "param",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Content"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "postParamContent",
"params" : [ {
"name" : "param",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Content"
}
},
"paramNames" : [ "param" ]
}
}, {
"type" : "Method",
"name" : "postParamData",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "BinaryType",
"modifier" : "PRESERVES_EMPTY",
"name" : "binary"
}
} ]
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return all values for one single POST parameter, one value for each time the param is used or assigned.\nThis supports the content types `application/x-www-form-urlencoded` and `multipart/form-data` only.\n\nFor `application/x-www-form-urlencoded`, if the usage is without an equal sign, it will have a null value in the\narray. If the content type is needed, use #postParamContent instead.\n\nFor `multipart/form-data`, the values will be binary if the individual chunk's Content-Type is non-text.",
"name" : "postParamData",
"params" : [ {
"name" : "param",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "BinaryType",
"modifier" : "PRESERVES_EMPTY",
"name" : "binary"
}
} ]
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "postParamData",
"params" : [ {
"name" : "param",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "BinaryType",
"modifier" : "PRESERVES_EMPTY",
"name" : "binary"
}
} ]
}
},
"paramNames" : [ "param" ]
}
}, {
"type" : "Method",
"name" : "sendAsync",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<HttpResponse>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "HttpRequest" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "HttpRequest"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Sends this HTTP request to target URI asynchronously.",
"name" : "sendAsync",
"params" : [ {
"name" : "timeout",
"valueType" : {
"type" : "ReferenceType",
"name" : "Duration"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<HttpResponse>",
"hadDeclaredVarBindings" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "sendAsync",
"params" : [ {
"name" : "timeout",
"valueType" : {
"type" : "ReferenceType",
"name" : "Duration"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<HttpResponse>",
"hadDeclaredVarBindings" : true
},
"paramNames" : [ "timeout" ]
},
"$nearestImplementedOn" : "HttpRequest"
}, {
"type" : "Method",
"name" : "sendSync",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "HttpResponse"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "HttpRequest" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "HttpRequest"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Sends this HTTP request to target URI synchronously (if supported by the runtime environment).",
"name" : "sendSync",
"params" : [ {
"name" : "timeout",
"valueType" : {
"type" : "ReferenceType",
"name" : "Duration"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "HttpResponse"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "sendSync",
"params" : [ {
"name" : "timeout",
"valueType" : {
"type" : "ReferenceType",
"name" : "Duration"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "HttpResponse"
},
"paramNames" : [ "timeout" ]
},
"$nearestImplementedOn" : "HttpRequest"
}, {
"type" : "Method",
"name" : "responseFromValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates HttpResponse to this request based on provided C3 value",
"name" : "responseFromValue",
"params" : [ {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "valueType",
"valueType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "responseFromValue",
"params" : [ {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "valueType",
"valueType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"paramNames" : [ "value", "valueType" ]
}
}, {
"type" : "Method",
"name" : "responseFromContent",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates HttpResponse to this request based on provided content",
"name" : "responseFromContent",
"params" : [ {
"name" : "content",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Content"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "responseFromContent",
"params" : [ {
"name" : "content",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Content"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"paramNames" : [ "content" ]
}
}, {
"type" : "Method",
"name" : "emptyResponse",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an empty HttpResponse to this request",
"name" : "emptyResponse",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "emptyResponse",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
}
}
}, {
"type" : "Method",
"name" : "redirectResponse",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates 302 Found Redirect HttpResponse to this request",
"name" : "redirectResponse",
"params" : [ {
"name" : "url",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Url"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "redirectResponse",
"params" : [ {
"name" : "url",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Url"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"paramNames" : [ "url" ]
}
}, {
"type" : "Method",
"name" : "notFoundResponse",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates 404 Not Found HttpResponse to this request",
"name" : "notFoundResponse",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "notFoundResponse",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
}
}
}, {
"type" : "Method",
"name" : "errorResponse",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an error HttpResponse to this request",
"name" : "errorResponse",
"params" : [ {
"name" : "err",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Error"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "errorResponse",
"params" : [ {
"name" : "err",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Error"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"paramNames" : [ "err" ]
}
}, {
"type" : "Method",
"name" : "contentMeta",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ContentMeta"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates {@link ContentMeta} from headers in this request",
"name" : "contentMeta",
"params" : [ {
"name" : "contentLocation",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ContentMeta"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "contentMeta",
"params" : [ {
"name" : "contentLocation",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ContentMeta"
},
"paramNames" : [ "contentLocation" ]
}
}, {
"type" : "Method",
"name" : "toJava",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'org.apache.http.client.methods.HttpUriRequest'"
} ]
} ]
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toJava",
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'org.apache.http.client.methods.HttpUriRequest'"
} ]
} ]
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJava",
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'org.apache.http.client.methods.HttpUriRequest'"
} ]
} ]
}
}
}, {
"type" : "Method",
"name" : "toObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an Obj from this request's query string, parsing values from the query string as fields of the specified\ntype. Query parameters that don't correspond to fields are ignored and conversion failures are also ignored unless\nthe `failIfInvalid` parameter is true.\n\n@param type the Obj type to construct\n@param failIfInvalid if true, throw an error if any conversions fail",
"name" : "toObj",
"genericVars" : [ {
"name" : "O"
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "failIfInvalid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toObj",
"genericVars" : [ {
"name" : "O"
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "failIfInvalid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O"
},
"paramNames" : [ "type", "failIfInvalid" ]
}
}, {
"type" : "Method",
"name" : "queryToObj",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an Obj from the specified query string, parsing values from the query string as fields of the specified\ntype. The query string should be standard format, without the leading `?`. Query parameters that don't correspond\nto fields are ignored and conversion failures are also ignored unless the `failIfInvalid` parameter is true.\n\n@param type the Obj type to construct\n@param query the query string to parse\n@param failIfInvalid if true, throw an error if any conversions fail\n\n@see #queryFromObj",
"name" : "queryToObj",
"genericVars" : [ {
"name" : "O"
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "query",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfInvalid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O"
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "queryToObj",
"genericVars" : [ {
"name" : "O"
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "query",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfInvalid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O"
},
"paramNames" : [ "type", "query", "failIfInvalid" ]
}
}, {
"type" : "Method",
"name" : "queryFromObj",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct a query string from the specified Obj instance. The query string is in standard format, without the\nleading `?`.\n\n@param inst the Obj inst as the source\n@return produced query string (may be empty, but not null)\n\n@see #queryToObj",
"name" : "queryFromObj",
"params" : [ {
"name" : "inst",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "queryFromObj",
"params" : [ {
"name" : "inst",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "PRESERVES_EMPTY",
"name" : "string"
},
"paramNames" : [ "inst" ]
}
}, {
"type" : "Method",
"name" : "fromJava",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "fromJava",
"params" : [ {
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'java.lang.Object'"
} ]
} ],
"name" : "request",
"valueType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest"
},
"private" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromJava",
"params" : [ {
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'java.lang.Object'"
} ]
} ],
"name" : "request",
"valueType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest"
},
"paramNames" : [ "request" ]
}
} ],
"hasSourceCode" : {
"js-ide-vscode-client-node" : true
}
});
let ACTION_ENGINE = "js-client";
function hasBody() {
return this.encodedBody != null && this.encodedBody.byteLength > 0;
}
function readBodyString() {
if (this.encodedBody != null) {
const encoder = new C3.$TextDecoder();
return encoder.decode(this.encodedBody);
}
}
function withBody(...args) {
let body;
let contentType, contentEncoding;
if (args[0] instanceof ArrayBuffer || ArrayBuffer.isView(args[0])) {
body = args[0];
contentType = args[1];
contentEncoding = args[2];
} else if (args[0] != null) {
body = args[0].readEncoded();
contentType = args[0].contentType;
contentEncoding = args[0].contentEncoding;
} else {
contentType = args[1];
contentEncoding = args[2];
}
if (body != null && contentType == null) {
contentType = _header(this, 'Content-Type') ?? 'application/octet-stream';
}
return this.withEncodedBody(body)
.withContentType(contentType)
.withContentEncoding(contentEncoding);
}
function withBodyString(entity, contentType, contentEncoding) {
if (contentType == null) {
contentType = _header(this, 'Content-Type') ?? 'text/plain';
}
const encoder = new C3.$TextEncoder();
return this.withBody(encoder.encode(entity), contentType);
}
function _extraHeaders(req) {
return {};
}
function _header(req, name) {
return req.header(name);
}
function _headers(req) {
let headers = _extraHeaders(req);
req.allHeaders().forEach((v, p) => {
if (v != null){
headers[p] = req.header(p);
}
});
return headers;
}
function _hasAuthz(req) {
return !!req.header('authorization', '');
}
function sendAsync(_timeout) {
const self = this;
let req = new C3.$JsHttpRequest(self.method || 'GET', self.url, _headers(self), self.encodedBody);
return req.sendAsync().then(function (res) {
return _buildResponse(self, res);
});
}
function sendSync(_timeout) {
const self = this;
let req = new C3.$JsHttpRequest(self.method || 'GET', self.url, _headers(self), self.encodedBody);
return _buildResponse(self, req.sendSync());
}
function _buildResponse(req, res) {
let response = {
request: req,
statusCode: res.statusCode,
reasonPhrase: res.reasonPhrase,
elapsedMs: res.elapsedMs,
_headers: new Map(),
};
if (res.headers != null) {
Object.keys(res.headers).forEach(p => response._headers.set(p.toLowerCase(), [res.headers[p]]));
}
if (res.response != null) {
if (res.responseType === 'arraybuffer') {
response._body = res.response;
} else {
const encoder = new C3.$TextEncoder();
response._body = encoder.encode(res.responseText).buffer;
response.entity = res.responseText;
}
}
if (req.connection) {
req.connection._logHttpRequest(req.url, res.elapsedMs);
let HttpResponse = req.connection._loadType('HttpResponse', true, true);
return HttpResponse.make(response);
} else if (typeof C3.HttpResponse === 'object') {
return C3.HttpResponse.make(response);
} else {
return response;
}
}
ACTION_ENGINE = 'js-client-node';
"use strict";
function $Builder(type, inst) {
let fields = {};
this.$type = type;
this.$setup = function (_inst) {};
this.$findType = function (type, _fields) { return type; };
this.$makeField = function (ft, value) { return value; };
this.$afterMake = function (inst) { return inst; };
if (inst != null) {
Object.keys(inst).forEach(fn => fields[fn] = inst[fn]);
}
Object.defineProperties(this, {
$objType: { value: type },
$onbuild: { value: undefined, writable: true },
$fields: { value: fields, configurable: true },
$refs: { value: {}, configurable: true },
$arrays: { value: {}, configurable: true },
$sets: { value: {}, configurable: true },
$maps: { value: {}, configurable: true },
$builder: { value: true },
});
}
$Builder.prototype.a = function a(field, element, doNotConvert) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isArray()) {
throw Err.invalidCall('ObjBuilder.a', `non-array field ${field.name}`);
}
let b = this.$arrays[field.name];
if (b == null) {
b = this.$fields[field.name];
if (b == null || !b.$builder) {
b = this.$arrays[field.name] = vt.makeBuilder(b);
}
}
if (arguments.length == 1) {
return b;
} else if (arguments.length == 2 || arguments.length == 3) {
b.add(element);
return this;
} else {
throw Err.invalidCall('ObjBuilder.a', 'expected field and element');
}
};
$Builder.prototype.clear = function clear() {
Object.defineProperty(this, '$fields', { value: {}, configurable: true });
Object.defineProperty(this, "$refs", { value: {}, configurable: true });
Object.defineProperty(this, "$arrays", { value: {}, configurable: true });
Object.defineProperty(this, "$sets", { value: {}, configurable: true });
Object.defineProperty(this, "$maps", { value: {}, configurable: true });
};
$Builder.prototype.constrain = function constrain() {
throw new Error('Unsupported operation ObjBuilder.constrain for JavaScript.');
};
$Builder.prototype.current = function current() {
let init = {};
Object.keys(this.$fields).forEach(p => {
let v = this.$fields[p];
if (v != null && v.$builder)
v = v.current();
init[p] = v;
});
return this.$objType.make(init);
};
$Builder.prototype.isEmpty = function isEmpty() {
return Object.keys(this.$fields).length === 0 &&
Object.keys(this.$refs).length === 0 &&
Object.keys(this.$arrays).length === 0 &&
Object.keys(this.$sets).length === 0 &&
Object.keys(this.$maps).length === 0;
};
$Builder.prototype.m = function m(field, key, element, doNotConvert) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isMap()) {
throw new Error(`Invalid call to ObjBuilder.m: non-map field ${field.name}.`);
}
let b = this.$maps[field.name];
if (b == null) {
b = this.$fields[field.name];
if (b == null || !b.$builder) {
b = this.$maps[field.name] = vt.makeBuilder(b);
}
}
if (arguments.length == 1) {
return b;
} else if (arguments.length == 3 || arguments.length == 4) {
b.put(key, element);
return this;
} else {
throw new Error(`Invalid call to ObjBuilder.m: expected field, key and value.`);
}
};
$Builder.prototype.mergeJson = function mergeJson(json) {
if (json != null) {
Object.keys(json).forEach(fn => this.v(fn, json[fn], false));
}
return this;
};
$Builder.prototype.mergeObj = function mergeObj(other, otherFieldsFilter) {
if (other == null) {
return this;
}
if (arguments.length == 1) {
if (this.objType() == other.type()) {
other.eachFieldValue((ft, v) => this.v(ft, v));
} else {
other.eachFieldValue((ft, v) => this.v(this.objType().fieldType(ft.name), v));
}
return this;
} else if (arguments.length == 2) {
if (other.instanceOf(otherFieldsFilter)) {
const tm = otherFieldsFilter.meta();
other.eachFieldValue((ft, v) => {
if (tm.fieldType(ft.name) != null)
this.v(ft, v);
});
}
return this;
}
throw new Error(`Invalid call to ObjBuilder.mergeObj: expected other and otherFieldsFilter.`);
};
$Builder.prototype.objType = function objType() {
return this.$objType;
};
$Builder.prototype.r = function r(field) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isReference()) {
throw new Error(`Invalid call to ObjBuilder.r: non-reference field ${field.name}.`);
}
let type = vt.dereference(true);
let b = this.$refs[field.name];
if (b == null) {
if (b == null || !b.$builder) {
b = this.$refs[field.name] = type.builder().mergeObj(b);
}
}
return b;
};
$Builder.prototype.s = function s(field, element, doNotConvert) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isSet()) {
throw Err.invalidCall('ObjBuilder.a', `non-array field ${field.name}`);
}
let b = this.$sets[field.name];
if (b == null) {
b = this.$fields[field.name];
if (b == null || !b.$builder) {
b = this.$sets[field.name] = vt.makeBuilder(b);
}
}
if (arguments.length == 1) {
return b;
} else if (arguments.length == 2 || arguments.length == 3) {
b.add(element);
return this;
} else {
throw Err.invalidCall('ObjBuilder.s', 'expected field and element');
}
};
$Builder.prototype.setFields = function setFields(fields, doNotConvert) {
if (fields != null) {
for (let [name, v] of fields) {
const ft = this.$objType.meta().fieldType(name, true);
if (v == null) {
delete this.$fields[ft.name];
} else {
this.$fields[ft.name] = v;
}
}
}
return this;
};
$Builder.prototype.v = function v(field, value, doNotConvert) {
if (arguments.length < 2) {
throw new Error(`Invalid call to ObjBuilder.v: expected field and value.`);
}
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
this.$fields[field.name] = value;
return this;
};
$Builder.prototype.build = function build() {
const type = this.$findType(this.$type, this.$fields);
let inst = Object.create(type.$objProto);
this.$setup(inst);
Object.keys(this.$refs).forEach(fn => {
this.$fields[fn] = this.$refs[fn].build();
});
Object.keys(this.$arrays).forEach(fn => {
this.$fields[fn] = this.$arrays[fn].build();
});
Object.keys(this.$sets).forEach(fn => {
this.$fields[fn] = this.$sets[fn].build();
});
Object.keys(this.$maps).forEach(fn => {
this.$fields[fn] = this.$maps[fn].build();
});
Object.keys(this.$fields).forEach(fn => {
let ft = type.$init.fieldTypes.find(fieldType => fieldType.name === fn && !fieldType.constant);
if (ft && inst[fn] === undefined && this.$fields[fn] != null) {
inst[fn] = this.$makeField(ft, this.$fields[fn]);
}
});
type.$init.fieldTypes.forEach(ft => {
if (!ft.constant && !_hasOwnProperty(inst, ft.name)) {
let vt = ft.valueType;
if (vt.modifier !== 'PRESERVES_EMPTY') {
let v = this.$makeField(ft, null);
if (v != null) {
inst[ft.name] = v;
}
}
}
});
inst = this.$afterMake(inst);
Object.freeze(inst);
if (this.$onbuild) {
this.$onbuild(inst);
}
return inst;
};
$Builder.prototype.type = function type() { return $type; };
$Builder.prototype.v = function v(field, value, doNotConvert) {
if (arguments.length < 2) {
throw new Error('Invalid call to ObjBuilder.v: expected field and value.');
}
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
this.$fields[field.name] = value;
return this;
};
$Builder.prototype._headers = function (v) {
if (v == null) {
delete this.$fields._headers;
} else {
this.$fields._headers = v;
}
return this;
};
$Builder.prototype.client = function (v) {
if (v == null) {
delete this.$fields.client;
} else {
this.$fields.client = v;
}
return this;
};
$Builder.prototype.method = function (v) {
if (v == null) {
delete this.$fields.method;
} else {
this.$fields.method = v;
}
return this;
};
$Builder.prototype.url = function (v) {
if (v == null) {
delete this.$fields.url;
} else {
this.$fields.url = v;
}
return this;
};
$Builder.prototype.encodedBody = function (v) {
if (v == null) {
delete this.$fields.encodedBody;
} else {
this.$fields.encodedBody = v;
}
return this;
};
let $logger;
function log() {
if ($logger == null) {
$logger = C3.Logger.for($type.name());
}
return $logger;
};
const $type = new Type$Proto($conn, $init);
const $proto = new (function HttpRequest() {});
Object.defineProperty($proto, '$conn', { value: $conn });
Object.defineProperties($type, {
$objProto: { value: $proto },
$withType: { value: true }
});
Object.defineProperty($type, Symbol.hasInstance, { value: function(inst) { return inst != null && inst.$c3inst && inst.$c3inst.meta().isA(this); } });
$proto.sendAsync = sendAsync;
$proto.withBodyString = withBodyString;
$proto.readBodyString = readBodyString;
$proto.hasBody = hasBody;
$proto.withBody = withBody;
$proto.sendSync = sendSync;
$type.buildArray = function buildArray(builder) {
const b = this.arrayBuilder();
builder(b);
return b.build();
};
$type.buildMap = function buildMap(builder) {
const b = this.mapBuilder();
builder(b);
return b.build();
};
$type.builder = function builder(inst) { return new $Builder(this, inst); };
Object.defineProperty($type.builder, '$std', { value: true });
$type._instantiate = function _instantiate(fields) {
return this.builder(fields).build();
};
$type.buildSet = function buildSet(builder) {
const b = this.setBuilder();
builder(b);
return b.build();
};
$proto.type = function type() { return $type; };
$proto.log = log;
$proto.with_headers = function(v) { return this.type().builder(this)._headers(v).build(); };
$proto.without_headers = function() { return this.type().builder(this)._headers().build(); };
$proto.withClient = function(v) { return this.type().builder(this).client(v).build(); };
$proto.withoutClient = function() { return this.type().builder(this).client().build(); };
$proto.withMethod = function(v) { return this.type().builder(this).method(v).build(); };
$proto.withoutMethod = function() { return this.type().builder(this).method().build(); };
$proto.withUrl = function(v) { return this.type().builder(this).url(v).build(); };
$proto.withoutUrl = function() { return this.type().builder(this).url().build(); };
$proto.withEncodedBody = function(v) { return this.type().builder(this).encodedBody(v).build(); };
$proto.withoutEncodedBody = function() { return this.type().builder(this).encodedBody().build(); };
$proto.toJSON = function toJSON() { return this.toTypedJson(); };
Object.freeze($type);
Object.freeze($proto);
return $type;
})());
$conn._registerType((function() {
const $init = _deepFreeze({
"type" : "TypeMeta",
"metadataPath" : "platform/src/http/WithHttpHeaders.c3typ",
"package" : "platform",
"packageSubPath" : "http",
"name" : "WithHttpHeaders",
"doc" : "**WithHttpHeaders** handles HTTP headers for both requests and responses according to the http specification.\nMost notably this type ensures headers are case-insensitive and handles other special cases (such as `Set-Cookie`).\n\n@see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers",
"declaredFieldTypes" : [ {
"doc" : "Returns the header value for a header containing a single value.\n\n@param @required name\n          The header name, case insensitive\n@param dflt\n          The default value to return if the header does not exist\n@return The header value, or values concatenated together by ', ' if multiple, or dflt if not found.",
"name" : "header",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "dflt",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Returns the header values for a header containing potentially multiple values.\n\n@param @required name\n          the header name, case insensitive\n@return The header values array if header is found, else empty array.",
"name" : "headers",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Returns the headers map with the lower-case header and list of values",
"name" : "allHeaders",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Returns headers map with keys of the lower-case header and value the result of the predicate. If predicate is not\nprovided, it will combine all headers with a \", \" except it will skip the set-cookie header if its present.\n\n@param merger\n          the optional function used to turn the array of header values to a string value. If the predicate returns\n          an empty value, it will not be added to the output.\n@return The headers map with keys of the lower-case header and value the result of the predicate",
"name" : "allHeadersMerged",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "header",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"name" : "values",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Returns the first header value satisfied by the given predicate.\n\n@param name\n          the header name (case-insensitive)\n@param predicate\n          the condition used to find the header value. If null the first header value found will be used\n@return The first matching header value for name or null if not found.",
"name" : "findFirstHeaderValue",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "predicate",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "v",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true
}
}, {
"doc" : "Returns the header values satisfied by the given predicate.\n\n@param name\n          the header name (case-insensitive)\n@param predicate\n          the condition used to find the header values. If null the all header values for name will be returned\n@return All matching header values for name or null if not found.",
"name" : "findAllHeaderValues",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "predicate",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "v",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"member" : true
}
}, {
"doc" : "The content type for these headers.",
"name" : "contentType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true
}
}, {
"doc" : "The content encoding for these headers.",
"name" : "contentEncoding",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true
}
}, {
"doc" : "Gets the cookie value from Http headers by a given cookie key.\n\n@param key\n          cookie key\n@return The cookie value or null if not found.",
"name" : "cookieValue",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "key",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true
}
}, {
"doc" : "Sets the header to (only) the specified value. This will wipe out any prior setting of this header, replacing it\nwith just this value. This is useful to _change_ a header value, instead of adding another value.\n\n@param name\n          header name (case-insensitive)\n@param value\n          replacement header value\n@return The new {@link WithHttpHeaders} object with name and value applied\n\n@see #withHeader\n@see #withoutHeader",
"name" : "replaceHeader",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Adds a header value into the existing headers. If called multiple times with the same header name, all values\nwill be added in the order they were called with duplicates removed.\n\n@param name\n          header name (case-insensitive)\n@param value\n          additional header value\n@return The new {@link WithHttpHeaders} object with name and value applied\n\n@see #replaceHeader\n@see #withoutHeader",
"name" : "withHeader",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Removes all values from the existing header.\n\n@param name\n          header name (case-insensitive)\n@return The new {@link WithHttpHeaders} object with header removed\n\n@see #withHeader\n@see #replaceHeader",
"name" : "withoutHeader",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Puts multiple header values into the existing headers. If the map has keys that collide in a case-insensitive way,\nthe order of the values may not be preserved, but duplicate values will be removed.\n\n@param headers\n          a map where the key is a header and value is one or many string values for that header.\n@return A modified {@link WithHttpHeaders} object with the headers applied",
"name" : "withHeaders",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "headers",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ]
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Adds \"Accept\" and \"ContentType\" headers as \"application/json\".",
"name" : "withJsonHeaders",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Add a \"X-C3-Action-Engine\" header appropriate to the current execution environment.",
"name" : "withActionEngineHeader",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Add Authorization header to this HTTP header.",
"name" : "withAuthHeader",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "auth",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Authorization"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Adds a content type to this HTTP header. Will silently not add contentType if it is empty.",
"name" : "withContentType",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Adds a content encoding type to this HTTP header. Will silently not add contentEncoding if it is empty.",
"name" : "withContentEncoding",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "contentEncoding",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "ContentEncoding"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "The internally used case-insensitive HTTP headers.",
"name" : "_headers",
"schemaSuffix" : "HDRS",
"private" : true,
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}
} ],
"isWithType" : true,
"isObj" : true,
"isMutable" : false,
"isStateful" : false,
"isSingleton" : false,
"isDefaultInstance" : false,
"isAbstract" : false,
"hasEventStream" : false,
"isGeneric" : false,
"isNativeRemix" : false,
"hasVarBindings" : false,
"prototypeName" : "WithHttpHeaders",
"typeSerName" : "type",
"hasSerNameFields" : false,
"annotations" : {
"type" : "Annotations"
},
"mixins" : [ "Obj", "Serializable", "Value", "Fingerprintable", "MemoryMeasurable", "WithType" ],
"referenceType" : {
"type" : "ReferenceType",
"name" : "WithHttpHeaders"
},
"mixinsWithSourceCode" : {
"js-ide-vscode-client-node" : [ "Obj", "WithType" ]
},
"fieldTypes" : [ {
"type" : "FieldType",
"doc" : "The internally used case-insensitive HTTP headers.",
"name" : "_headers",
"schemaSuffix" : "HDRS",
"private" : true,
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"isNumber" : false,
"instanceType" : "Map<string, [string]>"
}
} ],
"methods" : [ {
"type" : "Method",
"name" : "toJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a JSON object.\n\n@return JSON object representation\n\n@see #fromJson",
"name" : "toJson",
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"name" : "toJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"name" : "toJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
} ]
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ]
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"paramNames" : [ "include", "exclude" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "toTypedJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a _typed_ JSON object.\n@param omitTopLevelType\n       Whether to leave out `type: {{ type of this serializable instance }}` as the **first** key-value pair in\n       the outer level of the produced json.\n@param runtime\n       If provided, then any special serialization logic required for the {@link ImplLanguage.Runtime} will be\n       performed. **NOTE** This argument is ignored if `typed` is not `true`. @see Ann.Ser\n\n\n@return JSON object representation\n\n@see #fromJson\n@see #toJson\n@see serdeser.c3doc\n@see JsonType",
"name" : "toTypedJson",
"params" : [ {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"name" : "toTypedJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"name" : "toTypedJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toTypedJson",
"params" : [ {
"name" : "omitTopLevelTypeOrIncludeOrInclude",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
} ]
}
}, {
"name" : "actionRequirementOrExcludeOrExclude",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
}, {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
} ]
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"paramNames" : [ "omitTopLevelTypeOrIncludeOrInclude", "actionRequirementOrExcludeOrExclude" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "toJsonString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toJsonString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized JSON string.\n\n@return JSON object as string",
"name" : "toJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "pretty" ]
}
}, {
"type" : "Method",
"name" : "toTypedJsonString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toTypedJsonString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"name" : "toTypedJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toTypedJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "pretty", "omitTopLevelType" ]
}
}, {
"type" : "Method",
"name" : "toJsString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toJsString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized JavaScript object literal.\n\n@return JavaScript object literal string",
"name" : "toJsString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJsString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "withType" ]
}
}, {
"type" : "Method",
"name" : "toXmlString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toXmlString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized XML string.\n\n@return XML element as string\n\n@see #fromXmlString",
"name" : "toXmlString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toXmlString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "withType" ]
}
}, {
"type" : "Method",
"name" : "serialize",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a string serialized representation of the object.\n\n@return string serialized object representation",
"name" : "serialize",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "serialize",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "contentType" ]
}
}, {
"type" : "Method",
"name" : "fromJson",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the JSON-based representation and reconstruct the corresponding object.\n\nfromJson is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which may be\na type that mixes in the type on which it is called). This means that the resulting object's type will be isA the\ncalled-on type, but perhaps not identical. In particular, `Obj.fromJson` works for any actual type and will return\nan instance of the correct type.\n\n@see #toJson",
"name" : "fromJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "WithHttpHeaders",
"mixing" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "json" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fromJsonString",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the JSON-based representation and reconstruct the corresponding object.\n\nfromJsonString is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which may be\na type that mixes in the type on which it is called). This means that the resulting object's type will be isA the\ncalled-on type, but perhaps not identical. In particular, `Obj.fromJsonString` works for any actual type and will return\nan instance of the correct type.\n\n@see #toJsonString",
"name" : "fromJsonString",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "WithHttpHeaders",
"mixing" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromJsonString",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "json" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fromXmlString",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the XML-based representation and reconstruct the corresponding object.\n\nfromXmlString is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which\nmay be a type that mixes in the type on which it is called). This means that the resulting object's type will be\nisA the called type, but perhaps not identical. In particular, `Obj.fromXmlString` works for any actual type and\nwill return an instance of the correct type.\n\n@see #toXmlString",
"name" : "fromXmlString",
"params" : [ {
"name" : "xml",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "WithHttpHeaders",
"mixing" : true
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromXmlString",
"params" : [ {
"name" : "xml",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "xml" ]
}
}, {
"type" : "Method",
"name" : "deserialize",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load from contentType representation and reconstruct the corresponding object.\n\nfromString is be called on the type be deserialized and must reconstruct an object of the appropriate type\n(which may be a type that mixes in the type on which it is called). This means that the resulting object's type\nwill be isA the called-on type, but perhaps not identical. In particular, `fromString` works for any actual\ntype and will return an instance of the correct type.",
"name" : "deserialize",
"params" : [ {
"name" : "contentStr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "WithHttpHeaders",
"mixing" : true
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "deserialize",
"params" : [ {
"name" : "contentStr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "contentStr", "contentType" ]
}
}, {
"type" : "Method",
"name" : "fingerprint",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Produce a checksum that can easily be compared to determine if two objects are definitely different. Note that\nthere is a slight possibility that two objects with the same fingerprint will actually differ.\n\nThe fingerprint recurses into field values, including collections and referenced Objs. The handling of nested\n{@link Identified identified} references (typically entities) differ in that _only_ the `id` field is included\nunless the allIdentifiedRefFields option is specified.\n\nIf the object graph may contain recursive embedded object references, the trackRecursiveRefs option may be used.\nHowever, maintaining the list of visited objects is costly so this should not be done unnecessarily.\n\n@param allIdentifiedRefFields\n          if `true`, fingerprint individual fields of persistable references, not just the `id`\n@param trackRecursiveRefs\n          if `true`, a set of referenced objects is maintained to avoid infinite recursion\n@param traversedRefs\n          only considered together with trackRecursiveRefs and if provided then all traversed references are\n          checked against and added to it\n@return integer fingerprint\n\n@see https://en.wikipedia.org/wiki/Fingerprint_(computing)",
"name" : "fingerprint",
"params" : [ {
"name" : "allIdentifiedRefFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "trackRecursiveRefs",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "traversedRefs",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<Obj>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fingerprint",
"params" : [ {
"name" : "allIdentifiedRefFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "trackRecursiveRefs",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "traversedRefs",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<Obj>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"paramNames" : [ "allIdentifiedRefFields", "trackRecursiveRefs", "traversedRefs" ]
}
}, {
"type" : "Method",
"name" : "retainedMemory",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Measures retained memory by this instance.\n\n@param deep\n       if true and this instance contains references to other objects also measures memory retained by those\n@param allMeasured\n       if set then will skip instances that are in the set and will add instances that where measured by this call\n@return retained memory in bytes for this instances",
"name" : "retainedMemory",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "allMeasured",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<any>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "retainedMemory",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "allMeasured",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<any>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"paramNames" : [ "deep", "allMeasured" ]
}
}, {
"type" : "Method",
"name" : "type",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "C3 Type of this instance.",
"name" : "type",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "type",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "replaceType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns new instance with all references to old type, including result of #type, replaced with new type. If new\ntype does not contain fields from old or field value types are not convertable then drops the field.\n\nThis method is used during live metadata update",
"name" : "replaceType",
"params" : [ {
"name" : "old",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "new",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "replaceType",
"params" : [ {
"name" : "old",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "new",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "old", "new" ]
}
}, {
"type" : "Method",
"name" : "super",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithType" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithType"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : " Produce a calling proxy that represents the content of all Obj type's mixins, but not the type itself. This is\n useful for redispatching **member** methods reimplemented on this type to a parent implementation:\n ```js\n function toString() {\n   return this.super().toString() + ', x=' + this.x;\n }\n ```\n\n ```py\n def toString(this):\n    return this.super().toString() + ', x=' + this.x\n```\n\n To redispatch **static** methods, see {@link Type#super}.\n\n Note that this not the same as the language-specific `super` keyword because it works through the type system and\n supports multiple mixins. It behaves like the Python `super()` function, except called on the instance rather than\n globally.\n\n If `mixin` is the implementing type in a client implementation, this will delegate the call to the server.\n This can be used to create a local implementation \"around\" the server implementation for additional caching or\n other local state management.\n\n @param mixin if specified, this mixin is used instead or an error is thrown\n @return \"super\" calling proxy for this object\n\n @see Type.super",
"name" : "super",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "ReferenceType",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "super",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "ReferenceType",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"paramNames" : [ "mixin" ]
},
"$nearestImplementedOn" : "WithType"
}, {
"type" : "Method",
"name" : "instanceOf",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Checks whether this Obj is an instance of the specified type by checking both its type and the mixin chain.\nThis is the most convenient way to ask \"is this type usable in a context requiring the other type?\"\n\n@return true if this instance is of this type or any of its mixins",
"name" : "instanceOf",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Checks whether this instance is an instance of the specified type by checking both its type and the mixin chain.\nThis is the most convenient way to ask \"is this type usable in a context requiring the other type?\"\n\n@return true if this instance is of this type or any of its mixins\n\n@see ValueType#isA",
"name" : "instanceOf",
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "instanceOf",
"params" : [ {
"name" : "typeNameOrType",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ]
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "typeNameOrType" ]
}
}, {
"type" : "Method",
"name" : "isEmptyObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether all the fields of this instance are empty.",
"name" : "isEmptyObj",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isEmptyObj",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "isSame",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether the specified instance represents exactly the same object as this instance.",
"name" : "isSame",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isSame",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "other" ]
}
}, {
"type" : "Method",
"name" : "fieldValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns value of the given field.\n\n@param field\n          Field to return the value for\n       defaultToEmpty\n          will return default empty value if field is missing",
"name" : "fieldValue",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Returns value of the given field type. Be sure to use the FieldType instance for the exact same type as the type of\nthe obj.\n\n@param field\n          Field to return the value for\n       defaultToEmpty\n          will return default empty value if field is missing\n@return value for the given field",
"name" : "fieldValue",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValue",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
} ]
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "field", "defaultToEmpty" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fieldValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldValue"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all non empty field values. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValues",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldValue"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValues",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldValue"
}
}
}
}, {
"type" : "Method",
"name" : "fieldValuesByOrdinal",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all field values including empty ones as array where value of a field is at corresponding ordinal position.\nUnless `skipTrailingEmpty` parameter is set and there are trailing empty values resulting array has same size as\n#dataFieldTypes",
"name" : "fieldValuesByOrdinal",
"params" : [ {
"name" : "skipTrailingEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesByOrdinal",
"params" : [ {
"name" : "skipTrailingEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"paramNames" : [ "skipTrailingEmpty" ]
}
}, {
"type" : "Method",
"name" : "fieldValuesByFieldType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all non empty field values by field type. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValuesByFieldType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesByFieldType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
}
}, {
"type" : "Method",
"name" : "fieldValuesByFieldName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all non empty field values by field name. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValuesByFieldName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesByFieldName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}
}, {
"type" : "Method",
"name" : "fieldNames",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all data field names including those whose values are empty. Array is ordered by field ordinal.",
"name" : "fieldNames",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldNames",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}
}, {
"type" : "Method",
"name" : "at",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return value of the field at provided ordinal\n\n@param ordinal\n        Integer ordinal of the field in the parent type\n@return value of field at ordinal",
"name" : "at",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "ordinal",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Return value for the given serialized expression\n\n@param expr\n        Serialized expression to obtain the value in the given Obj\n@param failIfNotValid\n        If set, fails if not a valid expression\n@return value obtained as a result of expression evaluation",
"name" : "at",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "expr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
}, {
"name" : "failIfNotValid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "at",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "ordinalOrExpr",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
}, {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
} ]
}
}, {
"name" : "failIfNotValid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "ordinalOrExpr", "failIfNotValid" ]
}
}, {
"type" : "Method",
"name" : "fieldValueAtPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Looks up a single field value by path from this Obj. Field paths are separated by dots so an expression like\n`fieldValueAtPath(\"location.elevation\")` is equivalent to `traverse(\"location\").fieldValue(\"elevation\")` except\nthat it also handles `null`. If path contains any collections then only first element will be traversed,\nunless the collection index is specified in the path.\n\nIf you need to traverse all elements of collection fields use #fieldValuesAtPath instead.\n\n@param fieldPath\n          field names separated by dots\n@param failIfNotFound\n          if true, an error will be thrown if the any of the field types aren't defined\n@param context\n          if an error is thrown, the context returned by calling the lambda will be incorporated\n@return the field or null",
"name" : "fieldValueAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValueAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "fieldPath", "failIfNotFound", "context" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fieldValuesAtPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "VarReferenceType",
"name" : "T"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Looks up all the fields by path from root Obj. If path contains any collections then result will contain all\ntraversals, unless the collection index is specified in the path.\n\n@param fieldPath\n          field names separated by dots\n@param failIfNotFound\n          if true, an error will be thrown if the any of the field types aren't defined\n@param context\n          if an error is thrown, the context returned by calling the lambda will be incorporated\n@return fields as a flat list\n\n@see #fieldValueAtPath",
"name" : "fieldValuesAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "VarReferenceType",
"name" : "T"
}
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "VarReferenceType",
"name" : "T"
}
},
"paramNames" : [ "fieldPath", "failIfNotFound", "context" ]
}
}, {
"type" : "Method",
"name" : "eachFieldValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Perform an action for each non-empty field of this object.\n\n@param action\n          lambda to apply",
"name" : "eachFieldValue",
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Perform an action for each field of this object. Fields are filtered based on provided `spec`.\n\n@param spec\n          which fields to include\n@param action\n          lambda to apply",
"name" : "eachFieldValue",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachFieldValue",
"params" : [ {
"name" : "actionOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"paramNames" : [ "actionOrSpec", "action" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "eachFieldValueWhile",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Perform an action for each field of this object while processing action returns `true`. Fields are filtered based\non provided `spec`.\n\n@param spec\n          which fields to include\n@param action\n          lambda to apply; stop if this `action` returns `false\n@return `true` if iteration was not aborted by lambda i.e. it saw all field values",
"name" : "eachFieldValueWhile",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachFieldValueWhile",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "spec", "action" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "eachRef",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type. For reference fields, this means\nthe field value if non-null and for collections of Obj, this means each element in the collection.\n\n@param action\n          function to be executed for each pair of field type and Obj instance",
"name" : "eachRef",
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type. For reference fields, this means\nthe field value if non-null and for collections of Obj, this means each element in the collection.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param action\n          function to be executed for each pair of field type and Obj instance",
"name" : "eachRef",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRef",
"params" : [ {
"name" : "actionOrIncludeEmpty",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
}, {
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ]
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"paramNames" : [ "actionOrIncludeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "eachRefWhile",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type while processing action returns\n`true`.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param action\n          function to be executed for each pair of field type and Obj instance; stops processing if return `false`\n@return `true` if iteration was not aborted by lambda i.e. it saw all refs",
"name" : "eachRefWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRefWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "includeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "eachRefRecursive",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type or in any child refs.",
"name" : "eachRefRecursive",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRefRecursive",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"paramNames" : [ "includeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "eachRefRecursiveWhile",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type or in any child refs. Continue while\nprocessing action returns `true`.",
"name" : "eachRefRecursiveWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRefRecursiveWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "includeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "mapFieldValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Result of this function call is a copy of current instance with all non empty fields replaced based on results of\nthe `mapper` invocation.\n\n@param action\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValues",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Result of this function call is a copy of current instance with all fields replaced based on results of the\n`mapper` invocation.\n\n@param spec\n          which fields to include\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValues",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapFieldValues",
"params" : [ {
"name" : "mapperOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "convertValueOrMapper",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ]
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "mapperOrSpec", "convertValueOrMapper", "convertValue" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapFieldValuesAsync",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing WithHttpHeaders>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Result of this function call is a copy of current instance with all non empty fields replaced based on results of\nthe asynchronous `mapper` invocation.\n\n@param action\n          lambda to apply for every field value to produce a new value for that fields\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValuesAsync",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing WithHttpHeaders>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Result of this function call is a copy of current instance with all fields replaced based on results of the\nasynchronous `mapper` invocation.\n\n@param spec\n          which fields to include\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValuesAsync",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing WithHttpHeaders>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"name" : "mapFieldValuesAsync",
"params" : [ {
"name" : "mapperOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "convertValueOrMapper",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
} ]
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing WithHttpHeaders>",
"hadDeclaredVarBindings" : true
},
"paramNames" : [ "mapperOrSpec", "convertValueOrMapper", "convertValue" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapFieldValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Result of this function call is a copy of current instance with specified field value replaced based on result of\nthe `mapper` invocation.\n@param field\n          field being mapped\n@param includeEmpty\n          if set, invokes mapper for fields with empty value\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValue",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapFieldValue",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "field", "includeEmpty", "mapper", "convertValue" ]
}
}, {
"type" : "Method",
"name" : "mapRefs",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Executes the specified lambda against each referenced Obj instance and replaces it's value with result of this\nlambda application.\n\nResult of this function call is a copy of current instance with all references replaced based on results of the\n`mapper` invocation.\n\n@param action\n          function to be executed for each pair of field type and Obj instance\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapRefs",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Executes the specified lambda against each referenced Obj instance and replaces it's value with result of this\nlambda application.\n\nResult of this function call is a copy of current instance with all references replaced based on results of the\n`mapper` invocation.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param mapper\n          function to be executed for each pair of field type and Obj instance for producing new reference value\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapRefs",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapRefs",
"params" : [ {
"name" : "mapperOrIncludeEmpty",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
}, {
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ]
}
}, {
"name" : "convertValueOrMapper",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
} ]
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "mapperOrIncludeEmpty", "convertValueOrMapper", "convertValue" ]
}
}, {
"type" : "Method",
"name" : "foldFieldValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Result of this function is application of `folder` lambda to every non empty field value where `accumulator`\nargument is a result of previous application. Initial value of `accumulator` will be `null`.\n\nThis function is useful for calculating aggregate values based on all current non empty field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Result of this function is application of `folder` lambda to every non empty field value where `accumulator`\nargument is a result of previous application. Initial value of `accumulator` is provided via `initial` parameter.\n\nThis function is useful for calculating aggregate values based on all current non empty field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "initial",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Result of this function is application of `folder` lambda to every field value where `accumulator` argument is a\nresult of previous application. Initial value of `accumulator` is provided via `initial` parameter.\n\nThis function is useful for calculating aggregate values based on all field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "initial",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}, {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "folderOrInitialOrInitial",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
}, {
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ]
}
}, {
"name" : "folderOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "folderOrInitialOrInitial", "folderOrSpec", "folder" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "evalProjection",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "AnyType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Evaluates given projection expression over this instance.",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
}, {
"name" : "resultType",
"valueType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "AnyType"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Evaluates given projection over this instance and returns results as json.",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "JsonType",
"name" : "json"
},
"inline" : true,
"member" : true,
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Evaluates given projection over this instance and returns results as instance of the new Obj.",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
}, {
"name" : "resultType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
},
"inline" : true,
"member" : true,
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
}, {
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
} ]
}
}, {
"name" : "resultTypeOrBindingsOrResultType",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
}, {
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
} ]
}
}, {
"name" : "bindingsOrOptionsOrBindings",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ]
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "AnyType"
},
"paramNames" : [ "projection", "resultTypeOrBindingsOrResultType", "bindingsOrOptionsOrBindings", "options" ]
}
}, {
"type" : "Method",
"name" : "validateObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjResult"
}
} ]
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Populates all missing default values and throws error if any constraint it violated.",
"name" : "validateObj",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Validate that the Obj fields are set according to all the required rules.",
"name" : "validateObj",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjSpec"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjResult"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "validateObj",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjSpec"
}
} ],
"returnType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjResult"
}
} ]
},
"paramNames" : [ "spec" ]
}
}, {
"type" : "Method",
"name" : "withField",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the provided field in it. The name must correspond to an existing field\ndefined on this type or its mixins. The value must be of the correct type if doNotConvert flag is true.\n\n@param field\n          name of the field\n@param value\n          of the field\n@param doNotConvert\n          if true, do not attempt to convert the value to match the field's type\n@return new Obj",
"name" : "withField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the provided field in it. The name must correspond to an existing field\ndefined on this type or its mixins. The value must be of the correct type if doNotConvert flag is true.\n\n@param field\n          the field\n@param value\n          of the field\n@param doNotConvert\n          if true, do not attempt to convert the value to match the field's type\n@return new Obj",
"name" : "withField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
} ]
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "field", "value", "doNotConvert" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "withFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the provided fields in it. The name must correspond to an existing fields\ndefined on this type or its mixins. The values must be of the correct type if doNotConvert flag is true.\n\n@param fields\n          map of fields name/values\n@param doNotConvert\n          if true, attempt to convert the values to match the fields' type\n@return new Obj",
"name" : "withFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "fields", "doNotConvert" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "withFieldAtPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj with the value at the specified path field. If the value is null, the final field is removed.\n\nImmutable objects may return the same instance if the field being set or removed does not actually represent a\nchange to the existing object.\n\n@param path\n          path to set value at\n@param value\n          value to set\n@param doNotConvert\n          if true, attempt to convert the values to match the fields' type\n@param doNotCreateIfMissing\n          true indicates that any empty reference along the path will not set the value\n@return new Obj",
"name" : "withFieldAtPath",
"params" : [ {
"name" : "path",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "doNotCreateIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withFieldAtPath",
"params" : [ {
"name" : "path",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "doNotCreateIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "path", "value", "doNotConvert", "doNotCreateIfMissing" ]
}
}, {
"type" : "Method",
"name" : "withoutField",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the field with the provided name.\n\nImmutable objects may return the same instance if the field being removed is not present in the existing object.\n\n@param name\n          of the field to remove\n@return new Obj with removed field",
"name" : "withoutField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the field with the provided field type.\n\nImmutable objects may return the same instance if the field being removed is not present in the existing object.\n\n@param field\n          of the field to remove\n@return new Obj with removed field",
"name" : "withoutField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
} ]
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "field" ]
}
}, {
"type" : "Method",
"name" : "withoutFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the fields with the provided names.\n\nImmutable objects may return the same instance if the fields being removed are not present in the existing object.\n\n@param names\n          of the fields to remove\n@return new Obj with removed fields",
"name" : "withoutFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "withoutFieldsByType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the fields with the provided field types. Be sure to use the FieldType instance for the\nexact same type as the type of the obj to respect the \"ordinal\" of the field type\n\nImmutable objects may return the same instance if the fields being removed are not present in the existing object.\n\n@param fields\n          of the fields to remove\n@return new Obj with removed fields",
"name" : "withoutFieldsByType",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutFieldsByType",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "withDefaults",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the default values (if defined) for all empty fields. This is implemented by\ncalling {@link FieldType#defaultValue defaultValue} for a field if it is not already set and\n{@link FieldType#hasDefault has a default}. It will also set {@see ValueType#initialValue initial values} for\nfields with required primitive ValueTypes (E.g. x: `!int32` -> will be set to 0). Note that this will not overwrite\nfields that have already been set.\n\n{@link FunctionParam#validateArg} will call {@link #withDefaults} for {@link Spec}s passed as arguments to methods.\nAs a result, methods should be implemented assuming all default values are set on `Spec` arguments.\n\n@param includeEmptyRefsWithDefaults\n          it `true` then missing / empty child references that have fields with defaults will also be instantiated\n@param defaultFields\n          If not empty, a list of default field paths to populate.  Any default fields not specified in the\n          array will be ignored.\n@return new Obj\n\n@see FieldType#defaultValueConst\n@see FieldType#defaultValue",
"name" : "withDefaults",
"params" : [ {
"name" : "includeEmptyRefsWithDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "defaultFields",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withDefaults",
"params" : [ {
"name" : "includeEmptyRefsWithDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "defaultFields",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "includeEmptyRefsWithDefaults", "defaultFields" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mergeObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Merges all the fields of the provided Obj into this instance, producing a new Obj of the same type as this one.\nIn case of conflicts, fields of other instance take precedence unless otherwise specified by the fieldPathMergeSpec\n\n@param other\n          object\n@param fieldPathMergeSpec\n          mapping of fields of the object to the respective merge annotations\n@return the new merged Obj",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "fieldPathMergeSpec",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Merges all the fields of the provided Obj into this instance, producing a new Obj of the same type as this one.\nIn case of conflicts, fields of other instance take precedence.\n\n@param other\n          object\n@param otherFieldsFilter\n          only fields of otherFieldsFilter type from other are merged into this obj.\n@return the new merged Obj",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "otherFieldsFilter",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Merge the fields of this Obj with corresponding fields on other Obj using the provided lambda. This means that\nfields that exist on other Obj and do not exist on this Obj will not be added to final Obj.\n@param deep\n       if set to true then traverse reference and collection fields and merge corresponding fields or elements with\n       the same key or index.",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 2
}, {
"type" : "MethodType",
"doc" : "Merge the fields of this Obj with corresponding fields on other Obj using the provided lambda. This means that\nfields that exist other Obj and do not exist on this Obj will not be added to final Obj or evaluated. Does not\ntraverse child reference and collection fields.",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 3
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "fieldPathMergeSpecOrOtherFieldsFilterOrDeepOrMerger",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ]
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "other", "fieldPathMergeSpecOrOtherFieldsFilterOrDeepOrMerger", "merger" ]
}
}, {
"type" : "Method",
"name" : "mergeAndExpandObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Create new Obj with all non-null fields of this and other. Fields that are non null in both apply merger lambda.\nFields that non null in only one of this and other will be in the resulting Obj without change.",
"name" : "mergeAndExpandObj",
"genericVars" : [ {
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeAndExpandObj",
"genericVars" : [ {
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"paramNames" : [ "other", "merger" ]
}
}, {
"type" : "Method",
"name" : "mergeJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "mergeJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "json" ]
}
}, {
"type" : "Method",
"name" : "mergeChildren",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Merge the obj references within the current obj\n@param deep\n       If set, traverses the reference fields within the obj as well for a deep merge\n@param objKey\n       lambda specifying how to obtain the key for the Obj while determining which Objs to merge\n@param filter\n       Field paths that need to be filtered from this merge\n@return Obj with child references merged",
"name" : "mergeChildren",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "objKey",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "child",
"valueType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "filter",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeChildren",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "objKey",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "child",
"valueType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "filter",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "deep", "objKey", "filter" ]
}
}, {
"type" : "Method",
"name" : "sumObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds the numeric Obj fields with the other Objs respective fields.\nIf deep is set it will traverse reference and collection fields and sum corresponding numeric fields in\nreferences with same name and collection elements at same index or key.",
"name" : "sumObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "sumObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "other", "deep" ]
}
}, {
"type" : "Method",
"name" : "singletonArray",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "WithHttpHeaders",
"mixing" : true
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Build an array of the correct type with a single element which is this instance.\n\n@return new array instance with this as only element.",
"name" : "singletonArray",
"returnType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "WithHttpHeaders",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"name" : "singletonArray",
"returnType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "WithHttpHeaders",
"mixing" : true
}
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "array",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "WithHttpHeaders",
"mixing" : true
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an array of instances of this type.",
"name" : "array",
"params" : [ {
"name" : "elements",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "WithHttpHeaders",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "array",
"params" : [ {
"name" : "elements",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "WithHttpHeaders",
"mixing" : true
}
},
"paramNames" : [ "elements" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "arrayBuilder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "ArrayBuilder<mixing WithHttpHeaders>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an array of instances of this type.",
"name" : "arrayBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "ArrayBuilder<mixing WithHttpHeaders>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "arrayBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "ArrayBuilder<mixing WithHttpHeaders>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "singletonSet",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "SetType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "WithHttpHeaders",
"mixing" : true
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Build an set of the correct type with a single element which is this instance.\n\n@return new array instance with this as only element.",
"name" : "singletonSet",
"returnType" : {
"type" : "SetType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "WithHttpHeaders",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"name" : "singletonSet",
"returnType" : {
"type" : "SetType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "WithHttpHeaders",
"mixing" : true
}
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "setBuilder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<mixing WithHttpHeaders>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates a set of instances of this type.",
"name" : "setBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<mixing WithHttpHeaders>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "setBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<mixing WithHttpHeaders>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapBuilder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<string, mixing WithHttpHeaders>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Create a map of string to elements of this type.",
"name" : "mapBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<string, mixing WithHttpHeaders>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<string, mixing WithHttpHeaders>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapBuilderOf",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<any, mixing WithHttpHeaders>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Create a map with the given key type and elements of this type.",
"name" : "mapBuilderOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<any, mixing WithHttpHeaders>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapBuilderOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<any, mixing WithHttpHeaders>",
"hadDeclaredVarBindings" : true
},
"paramNames" : [ "keyType" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "myReferenceType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myReferenceType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myReferenceType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
}
}
}, {
"type" : "Method",
"name" : "myMapTypeOf",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myMapTypeOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myMapTypeOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"paramNames" : [ "keyType" ]
}
}, {
"type" : "Method",
"name" : "myMapType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myMapType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myMapType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
}
}
}, {
"type" : "Method",
"name" : "myArrayType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myArrayType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myArrayType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
}
}
}, {
"type" : "Method",
"name" : "mySetType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "mySetType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mySetType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
}
}
}, {
"type" : "Method",
"name" : "myStreamType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myStreamType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myStreamType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
}
}
}, {
"type" : "Method",
"name" : "toBuilder",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing WithHttpHeaders>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return new ObjBuilder with initial state set to fields of this instance.",
"name" : "toBuilder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing WithHttpHeaders>",
"hadDeclaredVarBindings" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toBuilder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing WithHttpHeaders>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "builder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing WithHttpHeaders>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return new ObjBuilder of this instance.",
"name" : "builder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing WithHttpHeaders>",
"hadDeclaredVarBindings" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "builder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing WithHttpHeaders>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fromFields",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type from provided fields\n@param fields\n           Fields to construct the instance of the obj with\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0) populated\n\n@see withDefaults",
"name" : "fromFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "fields", "withDefaults" ]
}
}, {
"type" : "Method",
"name" : "make",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type with no non-default field values unless explicitly specified by passing param true\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0)\n           populated\n\n@see withDefaults",
"name" : "make",
"params" : [ {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Construct an instance from provided fields\n@param fields\n           Fields (in the format <field_name, value>) to construct an instance of the obj. Note that \"type\" as a\n           field_name will be considered as the actual Obj's type, e.g. Obj.make({\"type\": \"Panda\"}) is equivalent\n           to Panda.make()\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32\n           -> 0) populated. Passing an empty value for a field will result in the default field value being set if\n           the field does not {@link ValueModifier#PRESERVES_EMPTY preserve empty} and {@link FieldType#hasDefault\n           has a default value}.\n\n\n@see fromFields\n@see beforeMake\n@see afterMake\n@see withDefaults",
"name" : "make",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : " Construct an instance of this type from provided fields. Note it is more efficient to use #fromFields and other overloads\n\n ```js\n User.make({\n   email: 'joe@smith.com',\n   realName: 'Joe Smith'\n })\n\n Obj.make({\n   type: 'User',\n   email: 'joe@smith.com',\n   realName: 'Joe Smith'\n })\n ```\n\n ```py\n c3.User.make({\n   \"email\": 'joe@smith.com',\n   \"realName\": 'Joe Smith'\n })\n\n c3.Obj.make({\n   \"type\": 'User',\n   \"email\": 'joe@smith.com',\n   \"realName\": 'Joe Smith'\n })\n\n c3.User(email='joe@smith.com', realName='Joe Smith')\n\n c3.Obj(type='User', email='joe@smith.com', realName='Joe Smith')\n```\n\n Note that this is **not** the same as the [serialization format](serdeser.c3doc). This is a convenient way to\n specify fields and values in the \"JSON like\" form supported by each language, but the usual serialization rules,\n such as {@link Ann.Ser} do not apply.\n @param fields\n            Fields to construct the instance of the obj with\n @param withDefaults\n            If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0) populated\n\n @see fromFields\n @see beforeMake\n @see afterMake\n @see withDefaults",
"name" : "make",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "make",
"params" : [ {
"name" : "withDefaultsOrFieldsOrFields",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "withDefaultsOrFieldsOrFields", "withDefaults" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "remake",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type from provided instance of a subtype or a \"duck type\".",
"name" : "remake",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "failIfExtraOrInvalidFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "remake",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "failIfExtraOrInvalidFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "other", "failIfExtraOrInvalidFields" ]
}
}, {
"type" : "Method",
"name" : "remakeAs",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an obj of the new type with all fields that exist on the original obj that are defined in the new type\nconverted and copied to the new obj instance. Note, that checking assignability and conversion of field values\ncould be costly if types have different value types for same fields.\n\n@param type\n        Type of new obj to return\n@return new obj of the requested type with all fields present in the original obj that are defined in the new type\n        converted and copied to it",
"name" : "remakeAs",
"genericVars" : [ {
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "remakeAs",
"genericVars" : [ {
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"paramNames" : [ "type" ]
}
}, {
"type" : "Method",
"name" : "beforeMake",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : true,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : false,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Optional override that will be called every time instance of this type is created.\n\n\nNote that it introduces additional overhead so should only be implemented for low volume data.",
"name" : "beforeMake",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"private" : true,
"optional" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "beforeMake",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "afterMake",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : true,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : false,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Optional override that will be called after every instance creation.\n\nNote that it introduces additional overhead so should only be implemented for low volume data.",
"name" : "afterMake",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"private" : true,
"optional" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "afterMake",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
}
}
}, {
"type" : "Method",
"name" : "cachedEmptyInst",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an empty inst using `MyType.make()` and caches it. Avoid recreating multiple copies of the spec for\nevery action dispatch. The cached inst can also be used for comparing whether the object is an empty or not\nWill only create empty instance for immutable Obj e.g. if an Obj is Mutable, this method will throw an error\n\n@see ValueType#defaultEmptyValue",
"name" : "cachedEmptyInst",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "cachedEmptyInst",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
}
}
}, {
"type" : "Method",
"name" : "toData",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Data"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Represent the current obj instance as {@link Data}",
"name" : "toData",
"returnType" : {
"type" : "ReferenceType",
"name" : "Data"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toData",
"returnType" : {
"type" : "ReferenceType",
"name" : "Data"
}
}
}, {
"type" : "Method",
"name" : "header",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns the header value for a header containing a single value.\n\n@param @required name\n          The header name, case insensitive\n@param dflt\n          The default value to return if the header does not exist\n@return The header value, or values concatenated together by ', ' if multiple, or dflt if not found.",
"name" : "header",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "dflt",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "header",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "dflt",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "name", "dflt" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "headers",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns the header values for a header containing potentially multiple values.\n\n@param @required name\n          the header name, case insensitive\n@return The header values array if header is found, else empty array.",
"name" : "headers",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "headers",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"paramNames" : [ "name" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "allHeaders",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns the headers map with the lower-case header and list of values",
"name" : "allHeaders",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "allHeaders",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "allHeadersMerged",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns headers map with keys of the lower-case header and value the result of the predicate. If predicate is not\nprovided, it will combine all headers with a \", \" except it will skip the set-cookie header if its present.\n\n@param merger\n          the optional function used to turn the array of header values to a string value. If the predicate returns\n          an empty value, it will not be added to the output.\n@return The headers map with keys of the lower-case header and value the result of the predicate",
"name" : "allHeadersMerged",
"params" : [ {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "header",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"name" : "values",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "allHeadersMerged",
"params" : [ {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "header",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"name" : "values",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"paramNames" : [ "merger" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "findFirstHeaderValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns the first header value satisfied by the given predicate.\n\n@param name\n          the header name (case-insensitive)\n@param predicate\n          the condition used to find the header value. If null the first header value found will be used\n@return The first matching header value for name or null if not found.",
"name" : "findFirstHeaderValue",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "predicate",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "v",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "findFirstHeaderValue",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "predicate",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "v",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "name", "predicate" ]
}
}, {
"type" : "Method",
"name" : "findAllHeaderValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns the header values satisfied by the given predicate.\n\n@param name\n          the header name (case-insensitive)\n@param predicate\n          the condition used to find the header values. If null the all header values for name will be returned\n@return All matching header values for name or null if not found.",
"name" : "findAllHeaderValues",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "predicate",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "v",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "findAllHeaderValues",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "predicate",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "v",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"paramNames" : [ "name", "predicate" ]
}
}, {
"type" : "Method",
"name" : "contentType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "The content type for these headers.",
"name" : "contentType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "contentType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "contentEncoding",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "The content encoding for these headers.",
"name" : "contentEncoding",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "contentEncoding",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "cookieValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Gets the cookie value from Http headers by a given cookie key.\n\n@param key\n          cookie key\n@return The cookie value or null if not found.",
"name" : "cookieValue",
"params" : [ {
"name" : "key",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "cookieValue",
"params" : [ {
"name" : "key",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "key" ]
}
}, {
"type" : "Method",
"name" : "replaceHeader",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Sets the header to (only) the specified value. This will wipe out any prior setting of this header, replacing it\nwith just this value. This is useful to _change_ a header value, instead of adding another value.\n\n@param name\n          header name (case-insensitive)\n@param value\n          replacement header value\n@return The new {@link WithHttpHeaders} object with name and value applied\n\n@see #withHeader\n@see #withoutHeader",
"name" : "replaceHeader",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "replaceHeader",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "name", "value" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withHeader",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds a header value into the existing headers. If called multiple times with the same header name, all values\nwill be added in the order they were called with duplicates removed.\n\n@param name\n          header name (case-insensitive)\n@param value\n          additional header value\n@return The new {@link WithHttpHeaders} object with name and value applied\n\n@see #replaceHeader\n@see #withoutHeader",
"name" : "withHeader",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withHeader",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "name", "value" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withoutHeader",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Removes all values from the existing header.\n\n@param name\n          header name (case-insensitive)\n@return The new {@link WithHttpHeaders} object with header removed\n\n@see #withHeader\n@see #replaceHeader",
"name" : "withoutHeader",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutHeader",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "name" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withHeaders",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Puts multiple header values into the existing headers. If the map has keys that collide in a case-insensitive way,\nthe order of the values may not be preserved, but duplicate values will be removed.\n\n@param headers\n          a map where the key is a header and value is one or many string values for that header.\n@return A modified {@link WithHttpHeaders} object with the headers applied",
"name" : "withHeaders",
"params" : [ {
"name" : "headers",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ]
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withHeaders",
"params" : [ {
"name" : "headers",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ]
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "headers" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withJsonHeaders",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds \"Accept\" and \"ContentType\" headers as \"application/json\".",
"name" : "withJsonHeaders",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withJsonHeaders",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
}
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withActionEngineHeader",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Add a \"X-C3-Action-Engine\" header appropriate to the current execution environment.",
"name" : "withActionEngineHeader",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withActionEngineHeader",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
}
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withAuthHeader",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Add Authorization header to this HTTP header.",
"name" : "withAuthHeader",
"params" : [ {
"name" : "auth",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Authorization"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withAuthHeader",
"params" : [ {
"name" : "auth",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Authorization"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "auth" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withContentType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds a content type to this HTTP header. Will silently not add contentType if it is empty.",
"name" : "withContentType",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withContentType",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "contentType" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withContentEncoding",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds a content encoding type to this HTTP header. Will silently not add contentEncoding if it is empty.",
"name" : "withContentEncoding",
"params" : [ {
"name" : "contentEncoding",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentEncoding"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withContentEncoding",
"params" : [ {
"name" : "contentEncoding",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentEncoding"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithHttpHeaders",
"mixing" : true
},
"paramNames" : [ "contentEncoding" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
} ],
"hasSourceCode" : {
"js-ide-vscode-client-node" : true
}
});
function allHeaders() {
return new Map(this._headers);
}
function allHeadersMerged(merger) {
if (merger == null) merger = (header, vals) => {
if ("set-cookie" == header) return null;
return vals.join(", ");
}
let merged = new Map;
for (let [header, vals] of this._headers) {
let m = merger(header, vals);
if (m != null) merged.set(header, m);
}
return merged;
}
function header(name, dflt) {
if ("set-cookie" == name?.toLowerCase()) {
throw new Error("Unsupported header Set-Cookie for WithHttpHeaders.header. Use WithHttpHeaders.headers instead.")
}
let values = this.headers(name);
if (values.length === 0) {
return dflt;
}
return values.join(", ");
}
function headers(name) {
return this._headers?.get(name?.toLowerCase()) || [];
}
function replaceHeader(name, value) {
_validateHeaderName(name);
_validateHeaderValue(value);
let _headers = new Map(this._headers);
_headers.set(name.toLowerCase(), [value]);
return this.with_headers(_headers);
}
function withHeader(name, value) {
_validateHeaderName(name);
let values = this.headers(name);
if (value != null && value !== '' && !values.includes(value)) {
values = values.concat([value]);
}
if (values.length === 0) {
return this;
}
let _headers = new Map(this._headers);
_headers.set(name.toLowerCase(), values);
return this.with_headers(_headers);
}
function withoutHeader(name) {
_validateHeaderName(name);
let _headers = new Map(this._headers);
_headers.delete(name.toLowerCase());
return this.with_headers(_headers);
}
function withHeaders(headers) {
let _headers = new Map(this._headers);
if (headers != null) {
if (!(headers instanceof Map)) {
headers = new Map(Object.entries(headers));
}
headers.forEach((vals, key) => {
_validateHeaderName(key);
let keyLowerCase = key.toLowerCase();
vals = typeof(vals) === 'string' ? [vals]: vals;
let newValues = (_headers.get(keyLowerCase) ?? []).concat(vals);
let existingValues = new Set();
newValues = newValues.filter(v => {
if (!existingValues.has(v)) {
existingValues.add(v);
return true;
}
return false;
});
if (newValues.length > 0) {
_headers.set(keyLowerCase, newValues);
}
});
}
return this.with_headers(_headers);
}
function withContentEncoding(contentEncoding) {
return !contentEncoding ? this: this.withHeader("Content-Encoding", contentEncoding);
}
function withContentType(contentType) {
return !contentType ? this: this.withHeader("Content-Type", contentType);
}
function withJsonHeaders() {
return this.withContentType('application/json').withHeader("Accept", 'application/json');
}
function withAuthHeader(auth) {
return this.withHeader("Authorization", auth);
}
function withActionEngineHeader() {
if (this?.$conn?.$actionEngine != null) {
return this.withHeader("X-C3-Action-Engine", this.$conn.$actionEngine);
}
return this;
}
function cookieValue(key) {
let values = this.headers('Set-Cookie');
for (let value of values) {
let r = /^([^=]+)="([^"]*)"(;.*)?$/.exec(value) || /^([^=]+)=([^;]*)(;.*)?$/.exec(value);
if (r && r[1] == key) {
return r[2];
}
}
}
function contentType() {
return this.header("Content-Type");
}
function contentEncoding() {
return this.header("Content-Encoding");
}
function _validateHeaderName(name) {
if (name == null || name.trim() === '') {
throw new Error(`Invalid value ${name} for http header, it must not be empty.`);
}
}
function _validateHeaderValue(value) {
if (value == null || value.trim() === '') {
throw new Error(`Invalid value ${name} for http header, it must not be empty.`);
}
}
"use strict";
function $Builder(type, inst) {
let fields = {};
this.$type = type;
this.$setup = function (_inst) {};
this.$findType = function (type, _fields) { return type; };
this.$makeField = function (ft, value) { return value; };
this.$afterMake = function (inst) { return inst; };
if (inst != null) {
Object.keys(inst).forEach(fn => fields[fn] = inst[fn]);
}
Object.defineProperties(this, {
$objType: { value: type },
$onbuild: { value: undefined, writable: true },
$fields: { value: fields, configurable: true },
$refs: { value: {}, configurable: true },
$arrays: { value: {}, configurable: true },
$sets: { value: {}, configurable: true },
$maps: { value: {}, configurable: true },
$builder: { value: true },
});
}
$Builder.prototype.a = function a(field, element, doNotConvert) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isArray()) {
throw Err.invalidCall('ObjBuilder.a', `non-array field ${field.name}`);
}
let b = this.$arrays[field.name];
if (b == null) {
b = this.$fields[field.name];
if (b == null || !b.$builder) {
b = this.$arrays[field.name] = vt.makeBuilder(b);
}
}
if (arguments.length == 1) {
return b;
} else if (arguments.length == 2 || arguments.length == 3) {
b.add(element);
return this;
} else {
throw Err.invalidCall('ObjBuilder.a', 'expected field and element');
}
};
$Builder.prototype.clear = function clear() {
Object.defineProperty(this, '$fields', { value: {}, configurable: true });
Object.defineProperty(this, "$refs", { value: {}, configurable: true });
Object.defineProperty(this, "$arrays", { value: {}, configurable: true });
Object.defineProperty(this, "$sets", { value: {}, configurable: true });
Object.defineProperty(this, "$maps", { value: {}, configurable: true });
};
$Builder.prototype.constrain = function constrain() {
throw new Error('Unsupported operation ObjBuilder.constrain for JavaScript.');
};
$Builder.prototype.current = function current() {
let init = {};
Object.keys(this.$fields).forEach(p => {
let v = this.$fields[p];
if (v != null && v.$builder)
v = v.current();
init[p] = v;
});
return this.$objType.make(init);
};
$Builder.prototype.isEmpty = function isEmpty() {
return Object.keys(this.$fields).length === 0 &&
Object.keys(this.$refs).length === 0 &&
Object.keys(this.$arrays).length === 0 &&
Object.keys(this.$sets).length === 0 &&
Object.keys(this.$maps).length === 0;
};
$Builder.prototype.m = function m(field, key, element, doNotConvert) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isMap()) {
throw new Error(`Invalid call to ObjBuilder.m: non-map field ${field.name}.`);
}
let b = this.$maps[field.name];
if (b == null) {
b = this.$fields[field.name];
if (b == null || !b.$builder) {
b = this.$maps[field.name] = vt.makeBuilder(b);
}
}
if (arguments.length == 1) {
return b;
} else if (arguments.length == 3 || arguments.length == 4) {
b.put(key, element);
return this;
} else {
throw new Error(`Invalid call to ObjBuilder.m: expected field, key and value.`);
}
};
$Builder.prototype.mergeJson = function mergeJson(json) {
if (json != null) {
Object.keys(json).forEach(fn => this.v(fn, json[fn], false));
}
return this;
};
$Builder.prototype.mergeObj = function mergeObj(other, otherFieldsFilter) {
if (other == null) {
return this;
}
if (arguments.length == 1) {
if (this.objType() == other.type()) {
other.eachFieldValue((ft, v) => this.v(ft, v));
} else {
other.eachFieldValue((ft, v) => this.v(this.objType().fieldType(ft.name), v));
}
return this;
} else if (arguments.length == 2) {
if (other.instanceOf(otherFieldsFilter)) {
const tm = otherFieldsFilter.meta();
other.eachFieldValue((ft, v) => {
if (tm.fieldType(ft.name) != null)
this.v(ft, v);
});
}
return this;
}
throw new Error(`Invalid call to ObjBuilder.mergeObj: expected other and otherFieldsFilter.`);
};
$Builder.prototype.objType = function objType() {
return this.$objType;
};
$Builder.prototype.r = function r(field) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isReference()) {
throw new Error(`Invalid call to ObjBuilder.r: non-reference field ${field.name}.`);
}
let type = vt.dereference(true);
let b = this.$refs[field.name];
if (b == null) {
if (b == null || !b.$builder) {
b = this.$refs[field.name] = type.builder().mergeObj(b);
}
}
return b;
};
$Builder.prototype.s = function s(field, element, doNotConvert) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isSet()) {
throw Err.invalidCall('ObjBuilder.a', `non-array field ${field.name}`);
}
let b = this.$sets[field.name];
if (b == null) {
b = this.$fields[field.name];
if (b == null || !b.$builder) {
b = this.$sets[field.name] = vt.makeBuilder(b);
}
}
if (arguments.length == 1) {
return b;
} else if (arguments.length == 2 || arguments.length == 3) {
b.add(element);
return this;
} else {
throw Err.invalidCall('ObjBuilder.s', 'expected field and element');
}
};
$Builder.prototype.setFields = function setFields(fields, doNotConvert) {
if (fields != null) {
for (let [name, v] of fields) {
const ft = this.$objType.meta().fieldType(name, true);
if (v == null) {
delete this.$fields[ft.name];
} else {
this.$fields[ft.name] = v;
}
}
}
return this;
};
$Builder.prototype.v = function v(field, value, doNotConvert) {
if (arguments.length < 2) {
throw new Error(`Invalid call to ObjBuilder.v: expected field and value.`);
}
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
this.$fields[field.name] = value;
return this;
};
$Builder.prototype.build = function build() {
const type = this.$findType(this.$type, this.$fields);
let inst = Object.create(type.$objProto);
this.$setup(inst);
Object.keys(this.$refs).forEach(fn => {
this.$fields[fn] = this.$refs[fn].build();
});
Object.keys(this.$arrays).forEach(fn => {
this.$fields[fn] = this.$arrays[fn].build();
});
Object.keys(this.$sets).forEach(fn => {
this.$fields[fn] = this.$sets[fn].build();
});
Object.keys(this.$maps).forEach(fn => {
this.$fields[fn] = this.$maps[fn].build();
});
Object.keys(this.$fields).forEach(fn => {
let ft = type.$init.fieldTypes.find(fieldType => fieldType.name === fn && !fieldType.constant);
if (ft && inst[fn] === undefined && this.$fields[fn] != null) {
inst[fn] = this.$makeField(ft, this.$fields[fn]);
}
});
type.$init.fieldTypes.forEach(ft => {
if (!ft.constant && !_hasOwnProperty(inst, ft.name)) {
let vt = ft.valueType;
if (vt.modifier !== 'PRESERVES_EMPTY') {
let v = this.$makeField(ft, null);
if (v != null) {
inst[ft.name] = v;
}
}
}
});
inst = this.$afterMake(inst);
Object.freeze(inst);
if (this.$onbuild) {
this.$onbuild(inst);
}
return inst;
};
$Builder.prototype.type = function type() { return $type; };
$Builder.prototype.v = function v(field, value, doNotConvert) {
if (arguments.length < 2) {
throw new Error('Invalid call to ObjBuilder.v: expected field and value.');
}
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
this.$fields[field.name] = value;
return this;
};
$Builder.prototype._headers = function (v) {
if (v == null) {
delete this.$fields._headers;
} else {
this.$fields._headers = v;
}
return this;
};
let $logger;
function log() {
if ($logger == null) {
$logger = C3.Logger.for($type.name());
}
return $logger;
};
const $type = new Type$Proto($conn, $init);
const $proto = new (function WithHttpHeaders() {});
Object.defineProperty($proto, '$conn', { value: $conn });
Object.defineProperties($type, {
$objProto: { value: $proto },
$withType: { value: true }
});
Object.defineProperty($type, Symbol.hasInstance, { value: function(inst) { return inst != null && inst.$c3inst && inst.$c3inst.meta().isA(this); } });
function withoutHeader_(name) {
return Ctx.call((t, a) => withoutHeader.apply(t, a), $type, 'withoutHeader', this, name);
}
_impl(withoutHeader_, withoutHeader);
$proto.withoutHeader = withoutHeader_;
function replaceHeader_(name, value) {
return Ctx.call((t, a) => replaceHeader.apply(t, a), $type, 'replaceHeader', this, name, value);
}
_impl(replaceHeader_, replaceHeader);
$proto.replaceHeader = replaceHeader_;
function withContentEncoding_(contentEncoding) {
return Ctx.call((t, a) => withContentEncoding.apply(t, a), $type, 'withContentEncoding', this, contentEncoding);
}
_impl(withContentEncoding_, withContentEncoding);
$proto.withContentEncoding = withContentEncoding_;
function header_(name, dflt) {
return Ctx.call((t, a) => header.apply(t, a), $type, 'header', this, name, dflt);
}
_impl(header_, header);
$proto.header = header_;
function withActionEngineHeader_() {
return Ctx.call((t, a) => withActionEngineHeader.apply(t, a), $type, 'withActionEngineHeader', this);
}
_impl(withActionEngineHeader_, withActionEngineHeader);
$proto.withActionEngineHeader = withActionEngineHeader_;
function withContentType_(contentType) {
return Ctx.call((t, a) => withContentType.apply(t, a), $type, 'withContentType', this, contentType);
}
_impl(withContentType_, withContentType);
$proto.withContentType = withContentType_;
function allHeaders_() {
return Ctx.call((t, a) => allHeaders.apply(t, a), $type, 'allHeaders', this);
}
_impl(allHeaders_, allHeaders);
$proto.allHeaders = allHeaders_;
function headers_(name) {
return Ctx.call((t, a) => headers.apply(t, a), $type, 'headers', this, name);
}
_impl(headers_, headers);
$proto.headers = headers_;
function allHeadersMerged_(merger) {
return Ctx.call((t, a) => allHeadersMerged.apply(t, a), $type, 'allHeadersMerged', this, merger);
}
_impl(allHeadersMerged_, allHeadersMerged);
$proto.allHeadersMerged = allHeadersMerged_;
function withHeaders_(headers) {
return Ctx.call((t, a) => withHeaders.apply(t, a), $type, 'withHeaders', this, headers);
}
_impl(withHeaders_, withHeaders);
$proto.withHeaders = withHeaders_;
function withJsonHeaders_() {
return Ctx.call((t, a) => withJsonHeaders.apply(t, a), $type, 'withJsonHeaders', this);
}
_impl(withJsonHeaders_, withJsonHeaders);
$proto.withJsonHeaders = withJsonHeaders_;
function withHeader_(name, value) {
return Ctx.call((t, a) => withHeader.apply(t, a), $type, 'withHeader', this, name, value);
}
_impl(withHeader_, withHeader);
$proto.withHeader = withHeader_;
function withAuthHeader_(auth) {
return Ctx.call((t, a) => withAuthHeader.apply(t, a), $type, 'withAuthHeader', this, auth);
}
_impl(withAuthHeader_, withAuthHeader);
$proto.withAuthHeader = withAuthHeader_;
$type.buildArray = function buildArray(builder) {
const b = this.arrayBuilder();
builder(b);
return b.build();
};
$type.buildMap = function buildMap(builder) {
const b = this.mapBuilder();
builder(b);
return b.build();
};
$type.builder = function builder(inst) { return new $Builder(this, inst); };
Object.defineProperty($type.builder, '$std', { value: true });
$type._instantiate = function _instantiate(fields) {
return this.builder(fields).build();
};
$type.buildSet = function buildSet(builder) {
const b = this.setBuilder();
builder(b);
return b.build();
};
$proto.type = function type() { return $type; };
$proto.log = log;
$proto.with_headers = function(v) { return this.type().builder(this)._headers(v).build(); };
$proto.without_headers = function() { return this.type().builder(this)._headers().build(); };
$proto.toJSON = function toJSON() { return this.toTypedJson(); };
Object.freeze($type);
Object.freeze($proto);
return $type;
})());
$conn._registerType((function() {
const $init = _deepFreeze({
"type" : "TypeMeta",
"metadataPath" : "platform/src/typesys/value/Obj.c3typ",
"package" : "platform",
"packageSubPath" : "typesys.value",
"name" : "Obj",
"doc" : "The `Obj` type is the a default mixin type for most of the declared types; so for most of the actual types `isA(Obj)`\nis true. In particular, Obj provides support for fields and ways to instantiate instances with fields.\n\nNote however type can be a {@link Value} - and in that case `isA(Obj)` will be `false`. Unlike `Obj` `Value`s don't\nhave fields. E.g. `type Array mixes Value` so it does not have methods like `fieldValue`.\n\nEach `Obj` is an instance of some C3 Type. Metadata regarding parent {@link Type) can be retrieved with the\n#type method.\n\nObj has built-in support for fields, which represent values set on the instance. Note that each field corresponds\nto a {@link FieldType field type} defined on the type, but only fields which have values set will be present.\nSo \"field types\" represent metadata about possible fields and \"fields\" store the actual values on a single\ninstance of an Obj.\n\nFor code that needs to examine Obj instances generically, going through the field interfaces (#fieldValue and\n#eachFieldValue) provides a way to operate on objects of unknown type. However, most often the code understands the\ntypes it expects to operate on and should use the direct accessors appropriate to the language.\n\nJava:\n```java\nobj.location()\nobj.fieldValue(\"location\")\n```\n\nJavaScript/Python:\n```javascript\nobj.location\nobj.fieldValue(\"location\")\n```\n\nFields which are not set are generally null. The exception is for collections which are always instantiated as\n\"empty\". This allows the code to avoid an if check for null and just chain down into the collection using functional\npatterns. Note that all collections support the {@link Collection#isEmpty isEmpty} method if code wants to handle\ncollections with no elements specially.\n\nNote that some values are not \"Objs\" in the sense that they don't correspond to a type. For example, a primitive\ninteger (`int`) is *not* an Obj since all language bindings treat it as separate thing from an \"Object\".  If desired,\nit can be boxed as as an Obj using {@link Boxed}. {@link Collection Collections} are also declared via types, but do\nnot mixin Obj.\n\nSome methods are declared as \"abstract\" here, which means they must be implemented by specific types if needed.\nTypes that have no implementation of abstract methods (and are not themselves declared abstract) can be created,\nbut those abstract methods cannot be called.\n\n@see Field\n@see Type\n@see ReferenceType\n@see Boxed",
"declaredAbstract" : true,
"declaredMixinRefTypes" : [ {
"name" : "Serializable"
}, {
"name" : "Fingerprintable"
}, {
"name" : "MemoryMeasurable"
}, {
"name" : "WithType"
}, {
"name" : "Value"
} ],
"declaredFieldTypes" : [ {
"name" : "type",
"valueType" : {
"type" : "InheritedValueType",
"actionRequirementNames" : [ "java", "py", "js" ]
}
}, {
"doc" : "Checks whether this Obj is an instance of the specified type by checking both its type and the mixin chain.\nThis is the most convenient way to ask \"is this type usable in a context requiring the other type?\"\n\n@return true if this instance is of this type or any of its mixins",
"name" : "instanceOf",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ]
}
}, {
"doc" : "Checks whether this instance is an instance of the specified type by checking both its type and the mixin chain.\nThis is the most convenient way to ask \"is this type usable in a context requiring the other type?\"\n\n@return true if this instance is of this type or any of its mixins\n\n@see ValueType#isA",
"name" : "instanceOf",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ]
}
}, {
"doc" : "Whether all the fields of this instance are empty.",
"name" : "isEmptyObj",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Whether the specified instance represents exactly the same object as this instance.",
"name" : "isSame",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true
}
}, {
"doc" : "Returns value of the given field.\n\n@param field\n          Field to return the value for\n       defaultToEmpty\n          will return default empty value if field is missing",
"name" : "fieldValue",
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Returns value of the given field type. Be sure to use the FieldType instance for the exact same type as the type of\nthe obj.\n\n@param field\n          Field to return the value for\n       defaultToEmpty\n          will return default empty value if field is missing\n@return value for the given field",
"name" : "fieldValue",
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Returns all non empty field values. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValues",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldValue"
}
},
"inline" : true,
"member" : true
}
}, {
"doc" : "Returns all field values including empty ones as array where value of a field is at corresponding ordinal position.\nUnless `skipTrailingEmpty` parameter is set and there are trailing empty values resulting array has same size as\n#dataFieldTypes",
"name" : "fieldValuesByOrdinal",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "skipTrailingEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true
}
}, {
"doc" : "Returns all non empty field values by field type. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValuesByFieldType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true
}
}, {
"doc" : "Returns all non empty field values by field name. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValuesByFieldName",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ]
}
}, {
"doc" : "Returns all data field names including those whose values are empty. Array is ordered by field ordinal.",
"name" : "fieldNames",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"inline" : true,
"member" : true
}
}, {
"doc" : "Return value of the field at provided ordinal\n\n@param ordinal\n        Integer ordinal of the field in the parent type\n@return value of field at ordinal",
"name" : "at",
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "ordinal",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true
}
}, {
"doc" : "Return value for the given serialized expression\n\n@param expr\n        Serialized expression to obtain the value in the given Obj\n@param failIfNotValid\n        If set, fails if not a valid expression\n@return value obtained as a result of expression evaluation",
"name" : "at",
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "expr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Expr"
}
}
}, {
"name" : "failIfNotValid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true
}
}, {
"doc" : "Looks up a single field value by path from this Obj. Field paths are separated by dots so an expression like\n`fieldValueAtPath(\"location.elevation\")` is equivalent to `traverse(\"location\").fieldValue(\"elevation\")` except\nthat it also handles `null`. If path contains any collections then only first element will be traversed,\nunless the collection index is specified in the path.\n\nIf you need to traverse all elements of collection fields use #fieldValuesAtPath instead.\n\n@param fieldPath\n          field names separated by dots\n@param failIfNotFound\n          if true, an error will be thrown if the any of the field types aren't defined\n@param context\n          if an error is thrown, the context returned by calling the lambda will be incorporated\n@return the field or null",
"name" : "fieldValueAtPath",
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Looks up all the fields by path from root Obj. If path contains any collections then result will contain all\ntraversals, unless the collection index is specified in the path.\n\n@param fieldPath\n          field names separated by dots\n@param failIfNotFound\n          if true, an error will be thrown if the any of the field types aren't defined\n@param context\n          if an error is thrown, the context returned by calling the lambda will be incorporated\n@return fields as a flat list\n\n@see #fieldValueAtPath",
"name" : "fieldValuesAtPath",
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
}
},
"final" : true,
"inline" : true,
"member" : true
}
}, {
"doc" : "Perform an action for each non-empty field of this object.\n\n@param action\n          lambda to apply",
"name" : "eachFieldValue",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Perform an action for each field of this object. Fields are filtered based on provided `spec`.\n\n@param spec\n          which fields to include\n@param action\n          lambda to apply",
"name" : "eachFieldValue",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Perform an action for each field of this object while processing action returns `true`. Fields are filtered based\non provided `spec`.\n\n@param spec\n          which fields to include\n@param action\n          lambda to apply; stop if this `action` returns `false\n@return `true` if iteration was not aborted by lambda i.e. it saw all field values",
"name" : "eachFieldValueWhile",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Execute the specified lambda against each referenced Obj instance in this type. For reference fields, this means\nthe field value if non-null and for collections of Obj, this means each element in the collection.\n\n@param action\n          function to be executed for each pair of field type and Obj instance",
"name" : "eachRef",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true
}
}, {
"doc" : "Execute the specified lambda against each referenced Obj instance in this type. For reference fields, this means\nthe field value if non-null and for collections of Obj, this means each element in the collection.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param action\n          function to be executed for each pair of field type and Obj instance",
"name" : "eachRef",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true
}
}, {
"doc" : "Execute the specified lambda against each referenced Obj instance in this type while processing action returns\n`true`.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param action\n          function to be executed for each pair of field type and Obj instance; stops processing if return `false`\n@return `true` if iteration was not aborted by lambda i.e. it saw all refs",
"name" : "eachRefWhile",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true
}
}, {
"doc" : "Execute the specified lambda against each referenced Obj instance in this type or in any child refs.",
"name" : "eachRefRecursive",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true
}
}, {
"doc" : "Execute the specified lambda against each referenced Obj instance in this type or in any child refs. Continue while\nprocessing action returns `true`.",
"name" : "eachRefRecursiveWhile",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true
}
}, {
"doc" : "Result of this function call is a copy of current instance with all non empty fields replaced based on results of\nthe `mapper` invocation.\n\n@param action\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValues",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Result of this function call is a copy of current instance with all non empty fields replaced based on results of\nthe asynchronous `mapper` invocation.\n\n@param action\n          lambda to apply for every field value to produce a new value for that fields\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValuesAsync",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Promise",
"refVarBindings" : [ {
"type" : "AnyType"
} ]
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise",
"refVarBindings" : [ {
"type" : "DeclaredReferenceType",
"name" : "Obj",
"mixing" : true
} ]
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Result of this function call is a copy of current instance with all fields replaced based on results of the\n`mapper` invocation.\n\n@param spec\n          which fields to include\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValues",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Result of this function call is a copy of current instance with all fields replaced based on results of the\nasynchronous `mapper` invocation.\n\n@param spec\n          which fields to include\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValuesAsync",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Promise",
"refVarBindings" : [ {
"type" : "AnyType"
} ]
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise",
"refVarBindings" : [ {
"type" : "DeclaredReferenceType",
"name" : "Obj",
"mixing" : true
} ]
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Result of this function call is a copy of current instance with specified field value replaced based on result of\nthe `mapper` invocation.\n@param field\n          field being mapped\n@param includeEmpty\n          if set, invokes mapper for fields with empty value\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValue",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
}
}, {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true
}
}, {
"doc" : "Executes the specified lambda against each referenced Obj instance and replaces it's value with result of this\nlambda application.\n\nResult of this function call is a copy of current instance with all references replaced based on results of the\n`mapper` invocation.\n\n@param action\n          function to be executed for each pair of field type and Obj instance\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapRefs",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Obj"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true
}
}, {
"doc" : "Executes the specified lambda against each referenced Obj instance and replaces it's value with result of this\nlambda application.\n\nResult of this function call is a copy of current instance with all references replaced based on results of the\n`mapper` invocation.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param mapper\n          function to be executed for each pair of field type and Obj instance for producing new reference value\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapRefs",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Obj"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true
}
}, {
"doc" : "Result of this function is application of `folder` lambda to every non empty field value where `accumulator`\nargument is a result of previous application. Initial value of `accumulator` will be `null`.\n\nThis function is useful for calculating aggregate values based on all current non empty field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Result of this function is application of `folder` lambda to every non empty field value where `accumulator`\nargument is a result of previous application. Initial value of `accumulator` is provided via `initial` parameter.\n\nThis function is useful for calculating aggregate values based on all current non empty field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "initial",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Result of this function is application of `folder` lambda to every field value where `accumulator` argument is a\nresult of previous application. Initial value of `accumulator` is provided via `initial` parameter.\n\nThis function is useful for calculating aggregate values based on all field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "initial",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
}
}, {
"name" : "spec",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Evaluates given projection expression over this instance.",
"name" : "evalProjection",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Expr"
}
}
}, {
"name" : "resultType",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "ValueType"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "AnyType"
},
"inline" : true,
"member" : true
}
}, {
"doc" : "Evaluates given projection over this instance and returns results as json.",
"name" : "evalProjection",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "JsonType",
"name" : "json"
},
"inline" : true,
"member" : true
}
}, {
"doc" : "Evaluates given projection over this instance and returns results as instance of the new Obj.",
"name" : "evalProjection",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
}, {
"name" : "resultType",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Obj"
},
"inline" : true,
"member" : true
}
}, {
"doc" : "Populates all missing default values and throws error if any constraint it violated.",
"name" : "validateObj",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true
}
}, {
"doc" : "Validate that the Obj fields are set according to all the required rules.",
"name" : "validateObj",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjSpec"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjResult"
},
"final" : true,
"inline" : true,
"member" : true
}
}, {
"doc" : "Builds a new Obj instance by adding the provided field in it. The name must correspond to an existing field\ndefined on this type or its mixins. The value must be of the correct type if doNotConvert flag is true.\n\n@param field\n          name of the field\n@param value\n          of the field\n@param doNotConvert\n          if true, do not attempt to convert the value to match the field's type\n@return new Obj",
"name" : "withField",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ]
}
}, {
"doc" : "Builds a new Obj instance by adding the provided field in it. The name must correspond to an existing field\ndefined on this type or its mixins. The value must be of the correct type if doNotConvert flag is true.\n\n@param field\n          the field\n@param value\n          of the field\n@param doNotConvert\n          if true, do not attempt to convert the value to match the field's type\n@return new Obj",
"name" : "withField",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ]
}
}, {
"doc" : "Builds a new Obj instance by adding the provided fields in it. The name must correspond to an existing fields\ndefined on this type or its mixins. The values must be of the correct type if doNotConvert flag is true.\n\n@param fields\n          map of fields name/values\n@param doNotConvert\n          if true, attempt to convert the values to match the fields' type\n@return new Obj",
"name" : "withFields",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ]
}
}, {
"doc" : "Builds a new Obj with the value at the specified path field. If the value is null, the final field is removed.\n\nImmutable objects may return the same instance if the field being set or removed does not actually represent a\nchange to the existing object.\n\n@param path\n          path to set value at\n@param value\n          value to set\n@param doNotConvert\n          if true, attempt to convert the values to match the fields' type\n@param doNotCreateIfMissing\n          true indicates that any empty reference along the path will not set the value\n@return new Obj",
"name" : "withFieldAtPath",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "path",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "doNotCreateIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true
}
}, {
"doc" : "Builds a new Obj, removing the field with the provided name.\n\nImmutable objects may return the same instance if the field being removed is not present in the existing object.\n\n@param name\n          of the field to remove\n@return new Obj with removed field",
"name" : "withoutField",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ]
}
}, {
"doc" : "Builds a new Obj, removing the field with the provided field type.\n\nImmutable objects may return the same instance if the field being removed is not present in the existing object.\n\n@param field\n          of the field to remove\n@return new Obj with removed field",
"name" : "withoutField",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ]
}
}, {
"doc" : "Builds a new Obj, removing the fields with the provided names.\n\nImmutable objects may return the same instance if the fields being removed are not present in the existing object.\n\n@param names\n          of the fields to remove\n@return new Obj with removed fields",
"name" : "withoutFields",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ]
}
}, {
"doc" : "Builds a new Obj, removing the fields with the provided field types. Be sure to use the FieldType instance for the\nexact same type as the type of the obj to respect the \"ordinal\" of the field type\n\nImmutable objects may return the same instance if the fields being removed are not present in the existing object.\n\n@param fields\n          of the fields to remove\n@return new Obj with removed fields",
"name" : "withoutFieldsByType",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true
}
}, {
"doc" : "Builds a new Obj instance by adding the default values (if defined) for all empty fields. This is implemented by\ncalling {@link FieldType#defaultValue defaultValue} for a field if it is not already set and\n{@link FieldType#hasDefault has a default}. It will also set {@see ValueType#initialValue initial values} for\nfields with required primitive ValueTypes (E.g. x: `!int32` -> will be set to 0). Note that this will not overwrite\nfields that have already been set.\n\n{@link FunctionParam#validateArg} will call {@link #withDefaults} for {@link Spec}s passed as arguments to methods.\nAs a result, methods should be implemented assuming all default values are set on `Spec` arguments.\n\n@param includeEmptyRefsWithDefaults\n          it `true` then missing / empty child references that have fields with defaults will also be instantiated\n@param defaultFields\n          If not empty, a list of default field paths to populate.  Any default fields not specified in the\n          array will be ignored.\n@return new Obj\n\n@see FieldType#defaultValueConst\n@see FieldType#defaultValue",
"name" : "withDefaults",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "includeEmptyRefsWithDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "defaultFields",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Merges all the fields of the provided Obj into this instance, producing a new Obj of the same type as this one.\nIn case of conflicts, fields of other instance take precedence unless otherwise specified by the fieldPathMergeSpec\n\n@param other\n          object\n@param fieldPathMergeSpec\n          mapping of fields of the object to the respective merge annotations\n@return the new merged Obj",
"name" : "mergeObj",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "fieldPathMergeSpec",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"inline" : true,
"member" : true
}
}, {
"doc" : "Merges all the fields of the provided Obj into this instance, producing a new Obj of the same type as this one.\nIn case of conflicts, fields of other instance take precedence.\n\n@param other\n          object\n@param otherFieldsFilter\n          only fields of otherFieldsFilter type from other are merged into this obj.\n@return the new merged Obj",
"name" : "mergeObj",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "otherFieldsFilter",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"inline" : true,
"member" : true
}
}, {
"doc" : "Merge the fields of this Obj with corresponding fields on other Obj using the provided lambda. This means that\nfields that exist on other Obj and do not exist on this Obj will not be added to final Obj.\n@param deep\n       if set to true then traverse reference and collection fields and merge corresponding fields or elements with\n       the same key or index.",
"name" : "mergeObj",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFp",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"inline" : true,
"member" : true
}
}, {
"doc" : "Merge the fields of this Obj with corresponding fields on other Obj using the provided lambda. This means that\nfields that exist other Obj and do not exist on this Obj will not be added to final Obj or evaluated. Does not\ntraverse child reference and collection fields.",
"name" : "mergeObj",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"inline" : true,
"member" : true
}
}, {
"doc" : "Create new Obj with all non-null fields of this and other. Fields that are non null in both apply merger lambda.\nFields that non null in only one of this and other will be in the resulting Obj without change.",
"name" : "mergeAndExpandObj",
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "R",
"restriction" : {
"type" : "DeclaredReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "R"
},
"inline" : true,
"member" : true
}
}, {
"name" : "mergeJson",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"inline" : true,
"member" : true
}
}, {
"doc" : "Merge the obj references within the current obj\n@param deep\n       If set, traverses the reference fields within the obj as well for a deep merge\n@param objKey\n       lambda specifying how to obtain the key for the Obj while determining which Objs to merge\n@param filter\n       Field paths that need to be filtered from this merge\n@return Obj with child references merged",
"name" : "mergeChildren",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "objKey",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "child",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "filter",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldPath"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"inline" : true,
"member" : true
}
}, {
"doc" : "Adds the numeric Obj fields with the other Objs respective fields.\nIf deep is set it will traverse reference and collection fields and sum corresponding numeric fields in\nreferences with same name and collection elements at same index or key.",
"name" : "sumObj",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"inline" : true,
"member" : true
}
}, {
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Build an array of the correct type with a single element which is this instance.\n\n@return new array instance with this as only element.",
"name" : "singletonArray",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "Obj",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Creates an array of instances of this type.",
"name" : "array",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "elements",
"valueType" : {
"type" : "AnyType"
},
"varArgs" : true
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "Obj",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Creates an array of instances of this type.",
"name" : "arrayBuilder",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "ArrayBuilder",
"refVarBindings" : [ {
"type" : "DeclaredReferenceType",
"name" : "Obj",
"mixing" : true
} ]
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Build an set of the correct type with a single element which is this instance.\n\n@return new array instance with this as only element.",
"name" : "singletonSet",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "SetType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "Obj",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Creates a set of instances of this type.",
"name" : "setBuilder",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "SetBuilder",
"refVarBindings" : [ {
"type" : "DeclaredReferenceType",
"name" : "Obj",
"mixing" : true
} ]
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Create a map of string to elements of this type.",
"name" : "mapBuilder",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "MapBuilder",
"refVarBindings" : [ {
"type" : "StringType",
"name" : "string"
}, {
"type" : "DeclaredReferenceType",
"name" : "Obj",
"mixing" : true
} ]
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Create a map with the given key type and elements of this type.",
"name" : "mapBuilderOf",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "MapBuilder",
"refVarBindings" : [ {
"type" : "AnyType"
}, {
"type" : "DeclaredReferenceType",
"name" : "Obj",
"mixing" : true
} ]
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"name" : "myReferenceType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
},
"final" : true,
"inline" : true
}
}, {
"name" : "myMapTypeOf",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"final" : true,
"inline" : true
}
}, {
"name" : "myMapType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"final" : true,
"inline" : true
}
}, {
"name" : "myArrayType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
},
"final" : true,
"inline" : true
}
}, {
"name" : "mySetType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
},
"final" : true,
"inline" : true
}
}, {
"name" : "myStreamType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
},
"final" : true,
"inline" : true
}
}, {
"doc" : "Convert the internal object representation to a JSON object.\n\n@return JSON object representation\n\n@see #fromJson",
"name" : "toJson",
"valueType" : {
"type" : "InheritedValueType",
"actionRequirementNames" : [ "java", "py", "js" ]
}
}, {
"name" : "toJson",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Include"
}
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Exclude"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ]
}
}, {
"name" : "toJson",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "Include"
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "Exclude"
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ]
}
}, {
"name" : "toTypedJson",
"valueType" : {
"type" : "InheritedValueType",
"actionRequirementNames" : [ "java", "py", "js" ]
}
}, {
"name" : "toTypedJson",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Include"
}
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Exclude"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ]
}
}, {
"name" : "toTypedJson",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "Include"
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "Exclude"
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ]
}
}, {
"doc" : "Convert the internal object representation to a serialized JSON string.\n\n@return JSON object as string",
"name" : "toJsonString",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true
}
}, {
"name" : "toJsonString",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true
}
}, {
"name" : "toTypedJsonString",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true
}
}, {
"name" : "toTypedJsonString",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true
}
}, {
"doc" : "Convert the internal object representation to a serialized JavaScript object literal.\n\n@return JavaScript object literal string",
"name" : "toJsString",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true
}
}, {
"name" : "toJsString",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true
}
}, {
"doc" : "Convert the internal object representation to a serialized XML string.\n\n@return XML element as string\n\n@see #fromXmlString",
"name" : "toXmlString",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true
}
}, {
"name" : "toXmlString",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true
}
}, {
"doc" : "Load the JSON-based representation and reconstruct the corresponding object.\n\nfromJson is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which may be\na type that mixes in the type on which it is called). This means that the resulting object's type will be isA the\ncalled-on type, but perhaps not identical. In particular, `Obj.fromJson` works for any actual type and will return\nan instance of the correct type.\n\n@see #toJson",
"name" : "fromJson",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Obj",
"mixing" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "py", "js" ]
}
}, {
"doc" : "Load the JSON-based representation and reconstruct the corresponding object.\n\nfromJsonString is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which may be\na type that mixes in the type on which it is called). This means that the resulting object's type will be isA the\ncalled-on type, but perhaps not identical. In particular, `Obj.fromJsonString` works for any actual type and will return\nan instance of the correct type.\n\n@see #toJsonString",
"name" : "fromJsonString",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Obj",
"mixing" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Load the XML-based representation and reconstruct the corresponding object.\n\nfromXmlString is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which\nmay be a type that mixes in the type on which it is called). This means that the resulting object's type will be\nisA the called type, but perhaps not identical. In particular, `Obj.fromXmlString` works for any actual type and\nwill return an instance of the correct type.\n\n@see #toXmlString",
"name" : "fromXmlString",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "xml",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Obj",
"mixing" : true
},
"inline" : true
}
}, {
"doc" : "@return new ObjBuilder with initial state set to fields of this instance.",
"name" : "toBuilder",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder",
"refVarBindings" : [ {
"type" : "DeclaredReferenceType",
"name" : "Obj",
"mixing" : true
} ]
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "@return new ObjBuilder of this instance.",
"name" : "builder",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder",
"refVarBindings" : [ {
"type" : "DeclaredReferenceType",
"name" : "Obj",
"mixing" : true
} ]
},
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Construct an instance of this type from provided fields\n@param fields\n           Fields to construct the instance of the obj with\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0) populated\n\n@see withDefaults",
"name" : "fromFields",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java" ]
}
}, {
"doc" : "Construct an instance of this type with no non-default field values unless explicitly specified by passing param true\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0)\n           populated\n\n@see withDefaults",
"name" : "make",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ]
}
}, {
"doc" : "Construct an instance from provided fields\n@param fields\n           Fields (in the format <field_name, value>) to construct an instance of the obj. Note that \"type\" as a\n           field_name will be considered as the actual Obj's type, e.g. Obj.make({\"type\": \"Panda\"}) is equivalent\n           to Panda.make()\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32\n           -> 0) populated. Passing an empty value for a field will result in the default field value being set if\n           the field does not {@link ValueModifier#PRESERVES_EMPTY preserve empty} and {@link FieldType#hasDefault\n           has a default value}.\n\n\n@see fromFields\n@see beforeMake\n@see afterMake\n@see withDefaults",
"name" : "make",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ]
}
}, {
"doc" : " Construct an instance of this type from provided fields. Note it is more efficient to use #fromFields and other overloads\n\n ```js\n User.make({\n   email: 'joe@smith.com',\n   realName: 'Joe Smith'\n })\n\n Obj.make({\n   type: 'User',\n   email: 'joe@smith.com',\n   realName: 'Joe Smith'\n })\n ```\n\n ```py\n c3.User.make({\n   \"email\": 'joe@smith.com',\n   \"realName\": 'Joe Smith'\n })\n\n c3.Obj.make({\n   \"type\": 'User',\n   \"email\": 'joe@smith.com',\n   \"realName\": 'Joe Smith'\n })\n\n c3.User(email='joe@smith.com', realName='Joe Smith')\n\n c3.Obj(type='User', email='joe@smith.com', realName='Joe Smith')\n```\n\n Note that this is **not** the same as the [serialization format](serdeser.c3doc). This is a convenient way to\n specify fields and values in the \"JSON like\" form supported by each language, but the usual serialization rules,\n such as {@link Ann.Ser} do not apply.\n @param fields\n            Fields to construct the instance of the obj with\n @param withDefaults\n            If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0) populated\n\n @see fromFields\n @see beforeMake\n @see afterMake\n @see withDefaults",
"name" : "make",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ]
}
}, {
"doc" : "Construct an instance of this type from provided instance of a subtype or a \"duck type\".",
"name" : "remake",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "failIfExtraOrInvalidFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true
}
}, {
"doc" : "Creates an obj of the new type with all fields that exist on the original obj that are defined in the new type\nconverted and copied to the new obj instance. Note, that checking assignability and conversion of field values\ncould be costly if types have different value types for same fields.\n\n@param type\n        Type of new obj to return\n@return new obj of the requested type with all fields present in the original obj that are defined in the new type\n        converted and copied to it",
"name" : "remakeAs",
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "O",
"restriction" : {
"type" : "DeclaredReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O"
},
"final" : true,
"inline" : true,
"member" : true
}
}, {
"doc" : "Optional override that will be called every time instance of this type is created.\n\n\nNote that it introduces additional overhead so should only be implemented for low volume data.",
"name" : "beforeMake",
"private" : true,
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"optional" : true,
"inline" : true
}
}, {
"doc" : "Optional override that will be called after every instance creation.\n\nNote that it introduces additional overhead so should only be implemented for low volume data.",
"name" : "afterMake",
"private" : true,
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"optional" : true,
"inline" : true,
"member" : true
}
}, {
"doc" : "Creates an empty inst using `MyType.make()` and caches it. Avoid recreating multiple copies of the spec for\nevery action dispatch. The cached inst can also be used for comparing whether the object is an empty or not\nWill only create empty instance for immutable Obj e.g. if an Obj is Mutable, this method will throw an error\n\n@see ValueType#defaultEmptyValue",
"name" : "cachedEmptyInst",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
}
}
}, {
"doc" : "Represent the current obj instance as {@link Data}",
"name" : "toData",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Data"
},
"inline" : true,
"member" : true
}
}, {
"name" : "fingerprint",
"valueType" : {
"type" : "InheritedValueType"
}
}, {
"name" : "replaceType",
"valueType" : {
"type" : "InheritedValueType"
}
}, {
"name" : "retainedMemory",
"valueType" : {
"type" : "InheritedValueType"
}
} ],
"isWithType" : true,
"isObj" : true,
"isMutable" : false,
"isStateful" : false,
"isSingleton" : false,
"isDefaultInstance" : false,
"isAbstract" : true,
"hasEventStream" : false,
"isGeneric" : false,
"isNativeRemix" : false,
"hasVarBindings" : false,
"prototypeName" : "Obj",
"typeSerName" : "type",
"hasSerNameFields" : false,
"annotations" : {
"type" : "Annotations"
},
"mixins" : [ "Serializable", "Value", "Fingerprintable", "MemoryMeasurable", "WithType" ],
"referenceType" : {
"type" : "ReferenceType",
"name" : "Obj"
},
"mixinsWithSourceCode" : {
"js-ide-vscode-client-node" : [ "WithType" ]
},
"methods" : [ {
"type" : "Method",
"name" : "toJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a JSON object.\n\n@return JSON object representation\n\n@see #fromJson",
"name" : "toJson",
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"name" : "toJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"name" : "toJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
} ]
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ]
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"paramNames" : [ "include", "exclude" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "toTypedJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a _typed_ JSON object.\n@param omitTopLevelType\n       Whether to leave out `type: {{ type of this serializable instance }}` as the **first** key-value pair in\n       the outer level of the produced json.\n@param runtime\n       If provided, then any special serialization logic required for the {@link ImplLanguage.Runtime} will be\n       performed. **NOTE** This argument is ignored if `typed` is not `true`. @see Ann.Ser\n\n\n@return JSON object representation\n\n@see #fromJson\n@see #toJson\n@see serdeser.c3doc\n@see JsonType",
"name" : "toTypedJson",
"params" : [ {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"name" : "toTypedJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"name" : "toTypedJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toTypedJson",
"params" : [ {
"name" : "omitTopLevelTypeOrIncludeOrInclude",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
} ]
}
}, {
"name" : "actionRequirementOrExcludeOrExclude",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
}, {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
} ]
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"paramNames" : [ "omitTopLevelTypeOrIncludeOrInclude", "actionRequirementOrExcludeOrExclude" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "toJsonString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toJsonString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized JSON string.\n\n@return JSON object as string",
"name" : "toJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "pretty" ]
}
}, {
"type" : "Method",
"name" : "toTypedJsonString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toTypedJsonString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"name" : "toTypedJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toTypedJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "pretty", "omitTopLevelType" ]
}
}, {
"type" : "Method",
"name" : "toJsString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toJsString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized JavaScript object literal.\n\n@return JavaScript object literal string",
"name" : "toJsString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJsString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "withType" ]
}
}, {
"type" : "Method",
"name" : "toXmlString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toXmlString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized XML string.\n\n@return XML element as string\n\n@see #fromXmlString",
"name" : "toXmlString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toXmlString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "withType" ]
}
}, {
"type" : "Method",
"name" : "serialize",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a string serialized representation of the object.\n\n@return string serialized object representation",
"name" : "serialize",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "serialize",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "contentType" ]
}
}, {
"type" : "Method",
"name" : "fromJson",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Obj",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the JSON-based representation and reconstruct the corresponding object.\n\nfromJson is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which may be\na type that mixes in the type on which it is called). This means that the resulting object's type will be isA the\ncalled-on type, but perhaps not identical. In particular, `Obj.fromJson` works for any actual type and will return\nan instance of the correct type.\n\n@see #toJson",
"name" : "fromJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj",
"mixing" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj",
"mixing" : true
},
"paramNames" : [ "json" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fromJsonString",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Obj",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the JSON-based representation and reconstruct the corresponding object.\n\nfromJsonString is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which may be\na type that mixes in the type on which it is called). This means that the resulting object's type will be isA the\ncalled-on type, but perhaps not identical. In particular, `Obj.fromJsonString` works for any actual type and will return\nan instance of the correct type.\n\n@see #toJsonString",
"name" : "fromJsonString",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj",
"mixing" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromJsonString",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj",
"mixing" : true
},
"paramNames" : [ "json" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fromXmlString",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Obj",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the XML-based representation and reconstruct the corresponding object.\n\nfromXmlString is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which\nmay be a type that mixes in the type on which it is called). This means that the resulting object's type will be\nisA the called type, but perhaps not identical. In particular, `Obj.fromXmlString` works for any actual type and\nwill return an instance of the correct type.\n\n@see #toXmlString",
"name" : "fromXmlString",
"params" : [ {
"name" : "xml",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj",
"mixing" : true
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromXmlString",
"params" : [ {
"name" : "xml",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj",
"mixing" : true
},
"paramNames" : [ "xml" ]
}
}, {
"type" : "Method",
"name" : "deserialize",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Obj",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load from contentType representation and reconstruct the corresponding object.\n\nfromString is be called on the type be deserialized and must reconstruct an object of the appropriate type\n(which may be a type that mixes in the type on which it is called). This means that the resulting object's type\nwill be isA the called-on type, but perhaps not identical. In particular, `fromString` works for any actual\ntype and will return an instance of the correct type.",
"name" : "deserialize",
"params" : [ {
"name" : "contentStr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "deserialize",
"params" : [ {
"name" : "contentStr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj",
"mixing" : true
},
"paramNames" : [ "contentStr", "contentType" ]
}
}, {
"type" : "Method",
"name" : "fingerprint",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Produce a checksum that can easily be compared to determine if two objects are definitely different. Note that\nthere is a slight possibility that two objects with the same fingerprint will actually differ.\n\nThe fingerprint recurses into field values, including collections and referenced Objs. The handling of nested\n{@link Identified identified} references (typically entities) differ in that _only_ the `id` field is included\nunless the allIdentifiedRefFields option is specified.\n\nIf the object graph may contain recursive embedded object references, the trackRecursiveRefs option may be used.\nHowever, maintaining the list of visited objects is costly so this should not be done unnecessarily.\n\n@param allIdentifiedRefFields\n          if `true`, fingerprint individual fields of persistable references, not just the `id`\n@param trackRecursiveRefs\n          if `true`, a set of referenced objects is maintained to avoid infinite recursion\n@param traversedRefs\n          only considered together with trackRecursiveRefs and if provided then all traversed references are\n          checked against and added to it\n@return integer fingerprint\n\n@see https://en.wikipedia.org/wiki/Fingerprint_(computing)",
"name" : "fingerprint",
"params" : [ {
"name" : "allIdentifiedRefFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "trackRecursiveRefs",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "traversedRefs",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<Obj>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fingerprint",
"params" : [ {
"name" : "allIdentifiedRefFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "trackRecursiveRefs",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "traversedRefs",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<Obj>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"paramNames" : [ "allIdentifiedRefFields", "trackRecursiveRefs", "traversedRefs" ]
}
}, {
"type" : "Method",
"name" : "retainedMemory",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Measures retained memory by this instance.\n\n@param deep\n       if true and this instance contains references to other objects also measures memory retained by those\n@param allMeasured\n       if set then will skip instances that are in the set and will add instances that where measured by this call\n@return retained memory in bytes for this instances",
"name" : "retainedMemory",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "allMeasured",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<any>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "retainedMemory",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "allMeasured",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<any>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"paramNames" : [ "deep", "allMeasured" ]
}
}, {
"type" : "Method",
"name" : "type",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "C3 Type of this instance.",
"name" : "type",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "type",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "replaceType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns new instance with all references to old type, including result of #type, replaced with new type. If new\ntype does not contain fields from old or field value types are not convertable then drops the field.\n\nThis method is used during live metadata update",
"name" : "replaceType",
"params" : [ {
"name" : "old",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "new",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "replaceType",
"params" : [ {
"name" : "old",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "new",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"paramNames" : [ "old", "new" ]
}
}, {
"type" : "Method",
"name" : "super",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithType" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithType"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : " Produce a calling proxy that represents the content of all Obj type's mixins, but not the type itself. This is\n useful for redispatching **member** methods reimplemented on this type to a parent implementation:\n ```js\n function toString() {\n   return this.super().toString() + ', x=' + this.x;\n }\n ```\n\n ```py\n def toString(this):\n    return this.super().toString() + ', x=' + this.x\n```\n\n To redispatch **static** methods, see {@link Type#super}.\n\n Note that this not the same as the language-specific `super` keyword because it works through the type system and\n supports multiple mixins. It behaves like the Python `super()` function, except called on the instance rather than\n globally.\n\n If `mixin` is the implementing type in a client implementation, this will delegate the call to the server.\n This can be used to create a local implementation \"around\" the server implementation for additional caching or\n other local state management.\n\n @param mixin if specified, this mixin is used instead or an error is thrown\n @return \"super\" calling proxy for this object\n\n @see Type.super",
"name" : "super",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "ReferenceType",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "super",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "ReferenceType",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"paramNames" : [ "mixin" ]
},
"$nearestImplementedOn" : "WithType"
}, {
"type" : "Method",
"name" : "instanceOf",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Checks whether this Obj is an instance of the specified type by checking both its type and the mixin chain.\nThis is the most convenient way to ask \"is this type usable in a context requiring the other type?\"\n\n@return true if this instance is of this type or any of its mixins",
"name" : "instanceOf",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Checks whether this instance is an instance of the specified type by checking both its type and the mixin chain.\nThis is the most convenient way to ask \"is this type usable in a context requiring the other type?\"\n\n@return true if this instance is of this type or any of its mixins\n\n@see ValueType#isA",
"name" : "instanceOf",
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "instanceOf",
"params" : [ {
"name" : "typeNameOrType",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ]
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "typeNameOrType" ]
}
}, {
"type" : "Method",
"name" : "isEmptyObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether all the fields of this instance are empty.",
"name" : "isEmptyObj",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isEmptyObj",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "isSame",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether the specified instance represents exactly the same object as this instance.",
"name" : "isSame",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isSame",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "other" ]
}
}, {
"type" : "Method",
"name" : "fieldValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns value of the given field.\n\n@param field\n          Field to return the value for\n       defaultToEmpty\n          will return default empty value if field is missing",
"name" : "fieldValue",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Returns value of the given field type. Be sure to use the FieldType instance for the exact same type as the type of\nthe obj.\n\n@param field\n          Field to return the value for\n       defaultToEmpty\n          will return default empty value if field is missing\n@return value for the given field",
"name" : "fieldValue",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValue",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
} ]
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "field", "defaultToEmpty" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fieldValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldValue"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all non empty field values. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValues",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldValue"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValues",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldValue"
}
}
}
}, {
"type" : "Method",
"name" : "fieldValuesByOrdinal",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all field values including empty ones as array where value of a field is at corresponding ordinal position.\nUnless `skipTrailingEmpty` parameter is set and there are trailing empty values resulting array has same size as\n#dataFieldTypes",
"name" : "fieldValuesByOrdinal",
"params" : [ {
"name" : "skipTrailingEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesByOrdinal",
"params" : [ {
"name" : "skipTrailingEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"paramNames" : [ "skipTrailingEmpty" ]
}
}, {
"type" : "Method",
"name" : "fieldValuesByFieldType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all non empty field values by field type. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValuesByFieldType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesByFieldType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
}
}, {
"type" : "Method",
"name" : "fieldValuesByFieldName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all non empty field values by field name. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValuesByFieldName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesByFieldName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}
}, {
"type" : "Method",
"name" : "fieldNames",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all data field names including those whose values are empty. Array is ordered by field ordinal.",
"name" : "fieldNames",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldNames",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}
}, {
"type" : "Method",
"name" : "at",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return value of the field at provided ordinal\n\n@param ordinal\n        Integer ordinal of the field in the parent type\n@return value of field at ordinal",
"name" : "at",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "ordinal",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Return value for the given serialized expression\n\n@param expr\n        Serialized expression to obtain the value in the given Obj\n@param failIfNotValid\n        If set, fails if not a valid expression\n@return value obtained as a result of expression evaluation",
"name" : "at",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "expr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
}, {
"name" : "failIfNotValid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "at",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "ordinalOrExpr",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
}, {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
} ]
}
}, {
"name" : "failIfNotValid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "ordinalOrExpr", "failIfNotValid" ]
}
}, {
"type" : "Method",
"name" : "fieldValueAtPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Looks up a single field value by path from this Obj. Field paths are separated by dots so an expression like\n`fieldValueAtPath(\"location.elevation\")` is equivalent to `traverse(\"location\").fieldValue(\"elevation\")` except\nthat it also handles `null`. If path contains any collections then only first element will be traversed,\nunless the collection index is specified in the path.\n\nIf you need to traverse all elements of collection fields use #fieldValuesAtPath instead.\n\n@param fieldPath\n          field names separated by dots\n@param failIfNotFound\n          if true, an error will be thrown if the any of the field types aren't defined\n@param context\n          if an error is thrown, the context returned by calling the lambda will be incorporated\n@return the field or null",
"name" : "fieldValueAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValueAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "fieldPath", "failIfNotFound", "context" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fieldValuesAtPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "VarReferenceType",
"name" : "T"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Looks up all the fields by path from root Obj. If path contains any collections then result will contain all\ntraversals, unless the collection index is specified in the path.\n\n@param fieldPath\n          field names separated by dots\n@param failIfNotFound\n          if true, an error will be thrown if the any of the field types aren't defined\n@param context\n          if an error is thrown, the context returned by calling the lambda will be incorporated\n@return fields as a flat list\n\n@see #fieldValueAtPath",
"name" : "fieldValuesAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "VarReferenceType",
"name" : "T"
}
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "VarReferenceType",
"name" : "T"
}
},
"paramNames" : [ "fieldPath", "failIfNotFound", "context" ]
}
}, {
"type" : "Method",
"name" : "eachFieldValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Perform an action for each non-empty field of this object.\n\n@param action\n          lambda to apply",
"name" : "eachFieldValue",
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Perform an action for each field of this object. Fields are filtered based on provided `spec`.\n\n@param spec\n          which fields to include\n@param action\n          lambda to apply",
"name" : "eachFieldValue",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachFieldValue",
"params" : [ {
"name" : "actionOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"paramNames" : [ "actionOrSpec", "action" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "eachFieldValueWhile",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Perform an action for each field of this object while processing action returns `true`. Fields are filtered based\non provided `spec`.\n\n@param spec\n          which fields to include\n@param action\n          lambda to apply; stop if this `action` returns `false\n@return `true` if iteration was not aborted by lambda i.e. it saw all field values",
"name" : "eachFieldValueWhile",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachFieldValueWhile",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "spec", "action" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "eachRef",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type. For reference fields, this means\nthe field value if non-null and for collections of Obj, this means each element in the collection.\n\n@param action\n          function to be executed for each pair of field type and Obj instance",
"name" : "eachRef",
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type. For reference fields, this means\nthe field value if non-null and for collections of Obj, this means each element in the collection.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param action\n          function to be executed for each pair of field type and Obj instance",
"name" : "eachRef",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRef",
"params" : [ {
"name" : "actionOrIncludeEmpty",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
}, {
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ]
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"paramNames" : [ "actionOrIncludeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "eachRefWhile",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type while processing action returns\n`true`.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param action\n          function to be executed for each pair of field type and Obj instance; stops processing if return `false`\n@return `true` if iteration was not aborted by lambda i.e. it saw all refs",
"name" : "eachRefWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRefWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "includeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "eachRefRecursive",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type or in any child refs.",
"name" : "eachRefRecursive",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRefRecursive",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"paramNames" : [ "includeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "eachRefRecursiveWhile",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type or in any child refs. Continue while\nprocessing action returns `true`.",
"name" : "eachRefRecursiveWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRefRecursiveWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "includeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "mapFieldValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Result of this function call is a copy of current instance with all non empty fields replaced based on results of\nthe `mapper` invocation.\n\n@param action\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValues",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Result of this function call is a copy of current instance with all fields replaced based on results of the\n`mapper` invocation.\n\n@param spec\n          which fields to include\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValues",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapFieldValues",
"params" : [ {
"name" : "mapperOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "convertValueOrMapper",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ]
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"paramNames" : [ "mapperOrSpec", "convertValueOrMapper", "convertValue" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapFieldValuesAsync",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing Obj>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Result of this function call is a copy of current instance with all non empty fields replaced based on results of\nthe asynchronous `mapper` invocation.\n\n@param action\n          lambda to apply for every field value to produce a new value for that fields\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValuesAsync",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing Obj>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Result of this function call is a copy of current instance with all fields replaced based on results of the\nasynchronous `mapper` invocation.\n\n@param spec\n          which fields to include\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValuesAsync",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing Obj>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"name" : "mapFieldValuesAsync",
"params" : [ {
"name" : "mapperOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "convertValueOrMapper",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
} ]
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing Obj>",
"hadDeclaredVarBindings" : true
},
"paramNames" : [ "mapperOrSpec", "convertValueOrMapper", "convertValue" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapFieldValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Result of this function call is a copy of current instance with specified field value replaced based on result of\nthe `mapper` invocation.\n@param field\n          field being mapped\n@param includeEmpty\n          if set, invokes mapper for fields with empty value\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValue",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapFieldValue",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"paramNames" : [ "field", "includeEmpty", "mapper", "convertValue" ]
}
}, {
"type" : "Method",
"name" : "mapRefs",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Executes the specified lambda against each referenced Obj instance and replaces it's value with result of this\nlambda application.\n\nResult of this function call is a copy of current instance with all references replaced based on results of the\n`mapper` invocation.\n\n@param action\n          function to be executed for each pair of field type and Obj instance\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapRefs",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Executes the specified lambda against each referenced Obj instance and replaces it's value with result of this\nlambda application.\n\nResult of this function call is a copy of current instance with all references replaced based on results of the\n`mapper` invocation.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param mapper\n          function to be executed for each pair of field type and Obj instance for producing new reference value\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapRefs",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapRefs",
"params" : [ {
"name" : "mapperOrIncludeEmpty",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
}, {
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ]
}
}, {
"name" : "convertValueOrMapper",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
} ]
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"paramNames" : [ "mapperOrIncludeEmpty", "convertValueOrMapper", "convertValue" ]
}
}, {
"type" : "Method",
"name" : "foldFieldValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Result of this function is application of `folder` lambda to every non empty field value where `accumulator`\nargument is a result of previous application. Initial value of `accumulator` will be `null`.\n\nThis function is useful for calculating aggregate values based on all current non empty field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Result of this function is application of `folder` lambda to every non empty field value where `accumulator`\nargument is a result of previous application. Initial value of `accumulator` is provided via `initial` parameter.\n\nThis function is useful for calculating aggregate values based on all current non empty field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "initial",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Result of this function is application of `folder` lambda to every field value where `accumulator` argument is a\nresult of previous application. Initial value of `accumulator` is provided via `initial` parameter.\n\nThis function is useful for calculating aggregate values based on all field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "initial",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}, {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "folderOrInitialOrInitial",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
}, {
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ]
}
}, {
"name" : "folderOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "folderOrInitialOrInitial", "folderOrSpec", "folder" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "evalProjection",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "AnyType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Evaluates given projection expression over this instance.",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
}, {
"name" : "resultType",
"valueType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "AnyType"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Evaluates given projection over this instance and returns results as json.",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "JsonType",
"name" : "json"
},
"inline" : true,
"member" : true,
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Evaluates given projection over this instance and returns results as instance of the new Obj.",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
}, {
"name" : "resultType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
},
"inline" : true,
"member" : true,
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
}, {
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
} ]
}
}, {
"name" : "resultTypeOrBindingsOrResultType",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
}, {
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
} ]
}
}, {
"name" : "bindingsOrOptionsOrBindings",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ]
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "AnyType"
},
"paramNames" : [ "projection", "resultTypeOrBindingsOrResultType", "bindingsOrOptionsOrBindings", "options" ]
}
}, {
"type" : "Method",
"name" : "validateObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjResult"
}
} ]
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Populates all missing default values and throws error if any constraint it violated.",
"name" : "validateObj",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Validate that the Obj fields are set according to all the required rules.",
"name" : "validateObj",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjSpec"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjResult"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "validateObj",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjSpec"
}
} ],
"returnType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjResult"
}
} ]
},
"paramNames" : [ "spec" ]
}
}, {
"type" : "Method",
"name" : "withField",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the provided field in it. The name must correspond to an existing field\ndefined on this type or its mixins. The value must be of the correct type if doNotConvert flag is true.\n\n@param field\n          name of the field\n@param value\n          of the field\n@param doNotConvert\n          if true, do not attempt to convert the value to match the field's type\n@return new Obj",
"name" : "withField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the provided field in it. The name must correspond to an existing field\ndefined on this type or its mixins. The value must be of the correct type if doNotConvert flag is true.\n\n@param field\n          the field\n@param value\n          of the field\n@param doNotConvert\n          if true, do not attempt to convert the value to match the field's type\n@return new Obj",
"name" : "withField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
} ]
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"paramNames" : [ "field", "value", "doNotConvert" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "withFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the provided fields in it. The name must correspond to an existing fields\ndefined on this type or its mixins. The values must be of the correct type if doNotConvert flag is true.\n\n@param fields\n          map of fields name/values\n@param doNotConvert\n          if true, attempt to convert the values to match the fields' type\n@return new Obj",
"name" : "withFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"paramNames" : [ "fields", "doNotConvert" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "withFieldAtPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj with the value at the specified path field. If the value is null, the final field is removed.\n\nImmutable objects may return the same instance if the field being set or removed does not actually represent a\nchange to the existing object.\n\n@param path\n          path to set value at\n@param value\n          value to set\n@param doNotConvert\n          if true, attempt to convert the values to match the fields' type\n@param doNotCreateIfMissing\n          true indicates that any empty reference along the path will not set the value\n@return new Obj",
"name" : "withFieldAtPath",
"params" : [ {
"name" : "path",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "doNotCreateIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withFieldAtPath",
"params" : [ {
"name" : "path",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "doNotCreateIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"paramNames" : [ "path", "value", "doNotConvert", "doNotCreateIfMissing" ]
}
}, {
"type" : "Method",
"name" : "withoutField",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the field with the provided name.\n\nImmutable objects may return the same instance if the field being removed is not present in the existing object.\n\n@param name\n          of the field to remove\n@return new Obj with removed field",
"name" : "withoutField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the field with the provided field type.\n\nImmutable objects may return the same instance if the field being removed is not present in the existing object.\n\n@param field\n          of the field to remove\n@return new Obj with removed field",
"name" : "withoutField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
} ]
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"paramNames" : [ "field" ]
}
}, {
"type" : "Method",
"name" : "withoutFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the fields with the provided names.\n\nImmutable objects may return the same instance if the fields being removed are not present in the existing object.\n\n@param names\n          of the fields to remove\n@return new Obj with removed fields",
"name" : "withoutFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "withoutFieldsByType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the fields with the provided field types. Be sure to use the FieldType instance for the\nexact same type as the type of the obj to respect the \"ordinal\" of the field type\n\nImmutable objects may return the same instance if the fields being removed are not present in the existing object.\n\n@param fields\n          of the fields to remove\n@return new Obj with removed fields",
"name" : "withoutFieldsByType",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutFieldsByType",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "withDefaults",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the default values (if defined) for all empty fields. This is implemented by\ncalling {@link FieldType#defaultValue defaultValue} for a field if it is not already set and\n{@link FieldType#hasDefault has a default}. It will also set {@see ValueType#initialValue initial values} for\nfields with required primitive ValueTypes (E.g. x: `!int32` -> will be set to 0). Note that this will not overwrite\nfields that have already been set.\n\n{@link FunctionParam#validateArg} will call {@link #withDefaults} for {@link Spec}s passed as arguments to methods.\nAs a result, methods should be implemented assuming all default values are set on `Spec` arguments.\n\n@param includeEmptyRefsWithDefaults\n          it `true` then missing / empty child references that have fields with defaults will also be instantiated\n@param defaultFields\n          If not empty, a list of default field paths to populate.  Any default fields not specified in the\n          array will be ignored.\n@return new Obj\n\n@see FieldType#defaultValueConst\n@see FieldType#defaultValue",
"name" : "withDefaults",
"params" : [ {
"name" : "includeEmptyRefsWithDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "defaultFields",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withDefaults",
"params" : [ {
"name" : "includeEmptyRefsWithDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "defaultFields",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"paramNames" : [ "includeEmptyRefsWithDefaults", "defaultFields" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mergeObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Merges all the fields of the provided Obj into this instance, producing a new Obj of the same type as this one.\nIn case of conflicts, fields of other instance take precedence unless otherwise specified by the fieldPathMergeSpec\n\n@param other\n          object\n@param fieldPathMergeSpec\n          mapping of fields of the object to the respective merge annotations\n@return the new merged Obj",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "fieldPathMergeSpec",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Merges all the fields of the provided Obj into this instance, producing a new Obj of the same type as this one.\nIn case of conflicts, fields of other instance take precedence.\n\n@param other\n          object\n@param otherFieldsFilter\n          only fields of otherFieldsFilter type from other are merged into this obj.\n@return the new merged Obj",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "otherFieldsFilter",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Merge the fields of this Obj with corresponding fields on other Obj using the provided lambda. This means that\nfields that exist on other Obj and do not exist on this Obj will not be added to final Obj.\n@param deep\n       if set to true then traverse reference and collection fields and merge corresponding fields or elements with\n       the same key or index.",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 2
}, {
"type" : "MethodType",
"doc" : "Merge the fields of this Obj with corresponding fields on other Obj using the provided lambda. This means that\nfields that exist other Obj and do not exist on this Obj will not be added to final Obj or evaluated. Does not\ntraverse child reference and collection fields.",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 3
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "fieldPathMergeSpecOrOtherFieldsFilterOrDeepOrMerger",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ]
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"paramNames" : [ "other", "fieldPathMergeSpecOrOtherFieldsFilterOrDeepOrMerger", "merger" ]
}
}, {
"type" : "Method",
"name" : "mergeAndExpandObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Create new Obj with all non-null fields of this and other. Fields that are non null in both apply merger lambda.\nFields that non null in only one of this and other will be in the resulting Obj without change.",
"name" : "mergeAndExpandObj",
"genericVars" : [ {
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeAndExpandObj",
"genericVars" : [ {
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"paramNames" : [ "other", "merger" ]
}
}, {
"type" : "Method",
"name" : "mergeJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "mergeJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"paramNames" : [ "json" ]
}
}, {
"type" : "Method",
"name" : "mergeChildren",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Merge the obj references within the current obj\n@param deep\n       If set, traverses the reference fields within the obj as well for a deep merge\n@param objKey\n       lambda specifying how to obtain the key for the Obj while determining which Objs to merge\n@param filter\n       Field paths that need to be filtered from this merge\n@return Obj with child references merged",
"name" : "mergeChildren",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "objKey",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "child",
"valueType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "filter",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeChildren",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "objKey",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "child",
"valueType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "filter",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"paramNames" : [ "deep", "objKey", "filter" ]
}
}, {
"type" : "Method",
"name" : "sumObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds the numeric Obj fields with the other Objs respective fields.\nIf deep is set it will traverse reference and collection fields and sum corresponding numeric fields in\nreferences with same name and collection elements at same index or key.",
"name" : "sumObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "sumObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"paramNames" : [ "other", "deep" ]
}
}, {
"type" : "Method",
"name" : "singletonArray",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "Obj",
"mixing" : true
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Build an array of the correct type with a single element which is this instance.\n\n@return new array instance with this as only element.",
"name" : "singletonArray",
"returnType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "Obj",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"name" : "singletonArray",
"returnType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "Obj",
"mixing" : true
}
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "array",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Obj",
"mixing" : true
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an array of instances of this type.",
"name" : "array",
"params" : [ {
"name" : "elements",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Obj",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "array",
"params" : [ {
"name" : "elements",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Obj",
"mixing" : true
}
},
"paramNames" : [ "elements" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "arrayBuilder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "ArrayBuilder<mixing Obj>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an array of instances of this type.",
"name" : "arrayBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "ArrayBuilder<mixing Obj>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "arrayBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "ArrayBuilder<mixing Obj>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "singletonSet",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "SetType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "Obj",
"mixing" : true
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Build an set of the correct type with a single element which is this instance.\n\n@return new array instance with this as only element.",
"name" : "singletonSet",
"returnType" : {
"type" : "SetType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "Obj",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"name" : "singletonSet",
"returnType" : {
"type" : "SetType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "Obj",
"mixing" : true
}
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "setBuilder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<mixing Obj>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates a set of instances of this type.",
"name" : "setBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<mixing Obj>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "setBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<mixing Obj>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapBuilder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<string, mixing Obj>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Create a map of string to elements of this type.",
"name" : "mapBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<string, mixing Obj>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<string, mixing Obj>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapBuilderOf",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<any, mixing Obj>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Create a map with the given key type and elements of this type.",
"name" : "mapBuilderOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<any, mixing Obj>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapBuilderOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<any, mixing Obj>",
"hadDeclaredVarBindings" : true
},
"paramNames" : [ "keyType" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "myReferenceType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myReferenceType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myReferenceType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
}
}
}, {
"type" : "Method",
"name" : "myMapTypeOf",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myMapTypeOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myMapTypeOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"paramNames" : [ "keyType" ]
}
}, {
"type" : "Method",
"name" : "myMapType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myMapType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myMapType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
}
}
}, {
"type" : "Method",
"name" : "myArrayType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myArrayType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myArrayType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
}
}
}, {
"type" : "Method",
"name" : "mySetType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "mySetType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mySetType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
}
}
}, {
"type" : "Method",
"name" : "myStreamType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myStreamType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myStreamType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
}
}
}, {
"type" : "Method",
"name" : "toBuilder",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing Obj>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return new ObjBuilder with initial state set to fields of this instance.",
"name" : "toBuilder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing Obj>",
"hadDeclaredVarBindings" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toBuilder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing Obj>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "builder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing Obj>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return new ObjBuilder of this instance.",
"name" : "builder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing Obj>",
"hadDeclaredVarBindings" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "builder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing Obj>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fromFields",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type from provided fields\n@param fields\n           Fields to construct the instance of the obj with\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0) populated\n\n@see withDefaults",
"name" : "fromFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"paramNames" : [ "fields", "withDefaults" ]
}
}, {
"type" : "Method",
"name" : "make",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type with no non-default field values unless explicitly specified by passing param true\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0)\n           populated\n\n@see withDefaults",
"name" : "make",
"params" : [ {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Construct an instance from provided fields\n@param fields\n           Fields (in the format <field_name, value>) to construct an instance of the obj. Note that \"type\" as a\n           field_name will be considered as the actual Obj's type, e.g. Obj.make({\"type\": \"Panda\"}) is equivalent\n           to Panda.make()\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32\n           -> 0) populated. Passing an empty value for a field will result in the default field value being set if\n           the field does not {@link ValueModifier#PRESERVES_EMPTY preserve empty} and {@link FieldType#hasDefault\n           has a default value}.\n\n\n@see fromFields\n@see beforeMake\n@see afterMake\n@see withDefaults",
"name" : "make",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : " Construct an instance of this type from provided fields. Note it is more efficient to use #fromFields and other overloads\n\n ```js\n User.make({\n   email: 'joe@smith.com',\n   realName: 'Joe Smith'\n })\n\n Obj.make({\n   type: 'User',\n   email: 'joe@smith.com',\n   realName: 'Joe Smith'\n })\n ```\n\n ```py\n c3.User.make({\n   \"email\": 'joe@smith.com',\n   \"realName\": 'Joe Smith'\n })\n\n c3.Obj.make({\n   \"type\": 'User',\n   \"email\": 'joe@smith.com',\n   \"realName\": 'Joe Smith'\n })\n\n c3.User(email='joe@smith.com', realName='Joe Smith')\n\n c3.Obj(type='User', email='joe@smith.com', realName='Joe Smith')\n```\n\n Note that this is **not** the same as the [serialization format](serdeser.c3doc). This is a convenient way to\n specify fields and values in the \"JSON like\" form supported by each language, but the usual serialization rules,\n such as {@link Ann.Ser} do not apply.\n @param fields\n            Fields to construct the instance of the obj with\n @param withDefaults\n            If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0) populated\n\n @see fromFields\n @see beforeMake\n @see afterMake\n @see withDefaults",
"name" : "make",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "make",
"params" : [ {
"name" : "withDefaultsOrFieldsOrFields",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"paramNames" : [ "withDefaultsOrFieldsOrFields", "withDefaults" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "remake",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type from provided instance of a subtype or a \"duck type\".",
"name" : "remake",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "failIfExtraOrInvalidFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "remake",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "failIfExtraOrInvalidFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"paramNames" : [ "other", "failIfExtraOrInvalidFields" ]
}
}, {
"type" : "Method",
"name" : "remakeAs",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an obj of the new type with all fields that exist on the original obj that are defined in the new type\nconverted and copied to the new obj instance. Note, that checking assignability and conversion of field values\ncould be costly if types have different value types for same fields.\n\n@param type\n        Type of new obj to return\n@return new obj of the requested type with all fields present in the original obj that are defined in the new type\n        converted and copied to it",
"name" : "remakeAs",
"genericVars" : [ {
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "remakeAs",
"genericVars" : [ {
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"paramNames" : [ "type" ]
}
}, {
"type" : "Method",
"name" : "beforeMake",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : true,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : false,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Optional override that will be called every time instance of this type is created.\n\n\nNote that it introduces additional overhead so should only be implemented for low volume data.",
"name" : "beforeMake",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"private" : true,
"optional" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "beforeMake",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "afterMake",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : true,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : false,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Optional override that will be called after every instance creation.\n\nNote that it introduces additional overhead so should only be implemented for low volume data.",
"name" : "afterMake",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"private" : true,
"optional" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "afterMake",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
}
}
}, {
"type" : "Method",
"name" : "cachedEmptyInst",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an empty inst using `MyType.make()` and caches it. Avoid recreating multiple copies of the spec for\nevery action dispatch. The cached inst can also be used for comparing whether the object is an empty or not\nWill only create empty instance for immutable Obj e.g. if an Obj is Mutable, this method will throw an error\n\n@see ValueType#defaultEmptyValue",
"name" : "cachedEmptyInst",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "cachedEmptyInst",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj",
"mixing" : true
}
}
}, {
"type" : "Method",
"name" : "toData",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Data"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Represent the current obj instance as {@link Data}",
"name" : "toData",
"returnType" : {
"type" : "ReferenceType",
"name" : "Data"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toData",
"returnType" : {
"type" : "ReferenceType",
"name" : "Data"
}
}
} ],
"hasSourceCode" : {
"js-ide-vscode-client-node" : true
},
"fieldTypes" : [ ]
});
function array(...elements) {
const b = this.arrayBuilder();
for (let e of elements) b.add(e);
return b.build();
}
function arrayBuilder() {
return ArrayType.of(this.myReferenceType()).makeBuilder();
}
function eachFieldValue(action) {
let spec;
if (arguments.length == 2) {
spec = arguments[0];
action = arguments[1];
}
this.type().meta().dataFieldTypes().forEach(ft => Val.consumeFieldValue(this, ft, this[ft.name], spec, action));
}
function eachFieldValueWhile(action) {
let spec;
if (arguments.length == 2) {
spec = arguments[0];
action = arguments[1];
}
let fieldTypes = this.type().meta().dataFieldTypes();
if (spec == null) {
for (let i = 0; i < fieldTypes.length; i++) {
let ft = fieldTypes[i];
if (this.hasOwnProperty(ft.name) && Val.isNotEmpty(this[ft.name])) {
let continue_ = action.call(undefined, ft, this[ft.name]);
if (!continue_)
return true;
}
}
} else {
throw new Error('eachFieldValueWhile with ValueSpec not implemented (yet)');
}
return false;
}
function fieldValue(field, defaultToEmpty) {
const name = typeof field === 'string' ? field : field.name;
let v = this[name];
if (v == null && defaultToEmpty) {
const ft = typeof field === 'string' ? this.type().meta().fieldType(field) : field;
if (ft != null) v = ft.defaultEmptyValue();
}
return v;
}
function fieldValueAtPath(fieldPath, failIfNotFound, _context) {
const rootObj = this;
const rootType = rootObj.type();
let parentType = rootType;
let info = FieldPath.parse(rootType, fieldPath)
.fold([rootObj, rootType.myReferenceType()],
(fp, i, isLeaf, parentInfo) => {
if (parentInfo == null) {
return null;
}
const parentFp = fp.parent();
let parentVal = parentInfo[0];
let parentVt = parentInfo[1];
if (parentVal == null) {
if (fp.valueType() == null && failIfNotFound) {
throw new Error(`Missing field "${fp.pathInRootType()}" of ${rootObj.type().name()}.`);
}
return null;
}
if (parentVt.isCollection() && !parentFp.isIndexed()) {
parentVal = parentVal.first();
parentVt = parentVt.elementType;
}
let value, vt;
if (parentVal.$c3inst != null) {
let ft = parentVal.$c3inst.meta().fieldType(fp.name());
if (ft == null) {
if (failIfNotFound) {
throw new Error(`Missing field "${fp.pathInRootType()}" of ${rootObj.type().name()}.`);
}
return null;
}
value = parentVal[fp.name()];
vt = ft.valueType();
} else {
value = parentVal;
vt = parentVt;
}
if (value == null) {
value = null;
} else if (_vtHasCollection(vt) && fp.isIndexed()) {
const index = fp.index();
if (Array.isArray(value) && typeof index === 'number') {
value = value[index];
} else if (value instanceof Set && typeof index === 'number') {
value = value.get(index);
} else if (value instanceof Map) {
value = value.get(String(index));
} else {
value = value.first(e => String(e) === index);
}
vt = vt.elementType;
}
return [value, vt];
});
return info != null ? info[0] : null;
}
function foldFieldValues(...args) {
let initial = null;
let spec;
let folder;
if (args.length >= 3) {
initial = args[0];
spec = args[1];
folder = args[2];
} else if (args.length === 2) {
initial = args[0];
folder = args[1];
} else {
folder = args[0];
}
let result = initial;
this.eachFieldValue(spec, (ft, v) => result = folder(ft, v, result));
return result;
}
function fromJson(json) {
if (json == null) {
return null;
}
let meta = this.meta();
if (typeof json === 'object') {
if (Object.getOwnPropertyNames(json).length == 0) {
return null;
}
let typeSerName = meta.typeSerName;
if (typeSerName != null && typeof json[typeSerName] === 'string') {
let t = C3.type(json[typeSerName]);
if (t != null && t.meta().isA(this)) {
meta = t.meta();
}
}
let copy = {}, renamed = false;
Object.keys(json).forEach(p => {
if (p === typeSerName) {
return;
}
let ft = meta.fieldTypeBySerName(p);
if (ft != null) {
copy[ft.name] = json[p];
renamed = true;
} else {
copy[p] = json[p];
}
});
return meta.toType().make(renamed ? copy : json);
}
if (typeof json === 'string' && meta.isA('StringSerializable')) {
return this.fromString(json);
}
throw Err.invalidValue(json, meta.name);
}
function fromJsonString(string) {
if (Str.isEmpty(string)) return;
let json;
try {
json = JSON.parse(string);
} catch (e) {
throw Err.invalidValue(string, this.name() + ' JSON string');
}
return this.fromJson(json);
}
function _vtHasCollection(vt) {
if (vt.isCollection()) {
return true;
} else if (vt.isAnyOf()) {
for (let candidate of vt.restrictions) {
if (candidate.valueType.isCollection()) return true;
}
}
return false;
}
function isEmptyObj() {
let count = 0;
if (this.type().meta().isA('Mutable')) {
let spec = ValueSpec.make({ skipTraversedRefs: true, traversedRefs: new Set(), includeEmptyRefs: true });
this.eachFieldValue(spec, (ft, v) => {
if (v != null && ft.valueType().isReference()) {
if (spec.traversedRefs.contains(v)) {
count++;
return;
}
spec.traversedRefs.add(v);
}
if (Val.isNotEmpty(v))
count++;
});
} else {
this.eachFieldValue((_ft, _v) => count++);
}
return count == 0;
}
function make(...args) {
let init;
let withDefaults = false;
if (args.length == 1 && typeof args[0] == 'boolean') {
withDefaults = args[0];
} else if (args.length > 0) {
init = args[0];
if (args.length > 1 && typeof args[1] == 'boolean') {
withDefaults = args[1];
}
}
let obj;
if (typeof init === 'string' && this.meta().isA('StringSerializable')) {
obj = this.fromString(...args);
} else {
obj = this.builder(init).build();
if (withDefaults) {
obj = obj.withDefaults();
}
}
return obj;
}
function mapFieldValues(mapper) {
let spec;
if (arguments.length == 2) {
spec = arguments[0];
mapper = arguments[1];
}
let init = {};
this.eachFieldValue(spec, (ft, v) => {
let mapped = mapper.call(undefined, ft, v);
if (mapped != null)
init[ft.name] = mapped;
});
return this.type().builder(init).build();
}
function mapFieldValuesAsync(mapper) {
let spec;
if (arguments.length == 2) {
spec = arguments[0];
mapper = arguments[1];
}
let init = {};
const allAsyncMaps = [];
this.eachFieldValue(spec, (ft, v) => {
let mapped = mapper.call(undefined, ft, v);
if (mapped != null) {
allAsyncMaps.push(mapped);
mapped.then((resolve) => {
init[ft.name] = resolve;
});
}
});
return Promise.all(allAsyncMaps).then(() => {
return this.type().builder(init).build();
});
}
function mapBuilder() {
return MapType.of(PrimitiveType.ofStr(), this.myReferenceType()).makeBuilder();
}
function mapBuilderOf(keyType) {
return MapType.of(keyType, this.myReferenceType()).makeBuilder();
}
function singletonArray() {
return ArrayType.of(this.type().myReferenceType()).makeBuilder().add(this).build();
}
function singletonSet() {
return SetType.of(this.type().myReferenceType()).makeBuilder().add(this).build();
}
function setBuilder() {
return SetType.of(this.myReferenceType()).makeBuilder();
}
function toBuilder() {
return this.type().builder(this);
}
function withDefaults(includeEmptyRefsWithDefaults, defaultFields) {
if (this.$cache.get('$withDefaults', false, () => false)) return this;
if (defaultFields != null && defaultFields.length === 0) defaultFields = null;
const fields = new Map();
let delegate = false;
this.type().meta().fieldTypes().forEach(ft => {
if (delegate) return;
if (defaultFields && !defaultFields.includes(ft.name)) return;
const oldVal = this[ft.name];
if (oldVal == null ||
!ft.valueType().preservesEmpty() && Val.isCollection(oldVal) && oldVal.isEmpty()) {
if (ft.hasDefault()) {
const c = ft.defaultValueConst();
if (c != null) {
fields.set(ft.name, c);
} else {
delegate = true;
}
} else if (!Object.hasOwnProperty.call(this, ft.name)) {
const initVal = ft.valueType().initialValue();
if (initVal != null) fields.set(ft.name, initVal);
}
} else if (Val.isObj(oldVal) &&
(!oldVal.isEmptyObj() || includeEmptyRefsWithDefaults) &&
!(oldVal instanceof WithUniqueId)) { // TODO PLAT-48170 Use WithUniqueKey
fields.set(ft.name, oldVal.withDefaults(includeEmptyRefsWithDefaults, defaultFields));
} else if (Val.isCollection(oldVal)) {
fields.set(ft.name, oldVal.withDefaults(includeEmptyRefsWithDefaults, defaultFields));
}
});
let res;
if (delegate) {
res = this.type().typeSystem().call(this.type().name(), 'withDefaults', this,
includeEmptyRefsWithDefaults, defaultFields);
} else {
res = this.withFields(fields, true);
}
res.$cache.put('$withDefaults', true);
return res;
}
function withField(field, value, doNotConvert) {
if (typeof field === 'string') {
field = this.type().meta().fieldType(field, true);
}
return this.toBuilder().v(field, value, doNotConvert).build();
}
function withFields(fields, doNotConvert) {
if (fields == null || fields.size === 0) return this;
return this.toBuilder().setFields(fields, doNotConvert).build();
}
function _toJson(ths, typed, writeTopLevelType) {
let o = {};
if (writeTopLevelType && ths.type().meta().fieldTypeBySerName('type') == null) {
o.type = ths.type().name();
}
let toJsonFuncName = typed ? "valueToTypedJson" : "valueToJson";
Object.keys(ths).forEach(p => {
let ft = ths.type().meta().fieldType(p);
if (ft == null || (ft.annotations().has('ser') && ft.annotations().ser().hidden))
return;
let v = ths[p];
if (ft.valueType().preservesEmpty() || (v != null && !ft.valueType().isEmptyValue(v))) {
o[ft.serName()] = ft.valueType()[toJsonFuncName](v);
}
});
return o;
}
function toTypedJson() {
let omitTopLevelType = arguments.length > 0 ? arguments[0] : false;
if (arguments[1] != null || arguments[2] != null) {
throw new Error('Obj.toTypedJson with include/exclude or runtime is not implemented (yet)');
}
return _toJson(this, true, !omitTopLevelType);
}
function toJson() {
if (arguments.length > 0) {
throw new Error('Obj.toJson with include/exclude not implemented (yet)');
}
return _toJson(this, false, false);
}
"use strict";
function $Builder(type, inst) {
let fields = {};
this.$type = type;
this.$setup = function (_inst) {};
this.$findType = function (type, _fields) { return type; };
this.$makeField = function (ft, value) { return value; };
this.$afterMake = function (inst) { return inst; };
if (inst != null) {
Object.keys(inst).forEach(fn => fields[fn] = inst[fn]);
}
Object.defineProperties(this, {
$objType: { value: type },
$onbuild: { value: undefined, writable: true },
$fields: { value: fields, configurable: true },
$refs: { value: {}, configurable: true },
$arrays: { value: {}, configurable: true },
$sets: { value: {}, configurable: true },
$maps: { value: {}, configurable: true },
$builder: { value: true },
});
}
$Builder.prototype.a = function a(field, element, doNotConvert) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isArray()) {
throw Err.invalidCall('ObjBuilder.a', `non-array field ${field.name}`);
}
let b = this.$arrays[field.name];
if (b == null) {
b = this.$fields[field.name];
if (b == null || !b.$builder) {
b = this.$arrays[field.name] = vt.makeBuilder(b);
}
}
if (arguments.length == 1) {
return b;
} else if (arguments.length == 2 || arguments.length == 3) {
b.add(element);
return this;
} else {
throw Err.invalidCall('ObjBuilder.a', 'expected field and element');
}
};
$Builder.prototype.clear = function clear() {
Object.defineProperty(this, '$fields', { value: {}, configurable: true });
Object.defineProperty(this, "$refs", { value: {}, configurable: true });
Object.defineProperty(this, "$arrays", { value: {}, configurable: true });
Object.defineProperty(this, "$sets", { value: {}, configurable: true });
Object.defineProperty(this, "$maps", { value: {}, configurable: true });
};
$Builder.prototype.constrain = function constrain() {
throw new Error('Unsupported operation ObjBuilder.constrain for JavaScript.');
};
$Builder.prototype.current = function current() {
let init = {};
Object.keys(this.$fields).forEach(p => {
let v = this.$fields[p];
if (v != null && v.$builder)
v = v.current();
init[p] = v;
});
return this.$objType.make(init);
};
$Builder.prototype.isEmpty = function isEmpty() {
return Object.keys(this.$fields).length === 0 &&
Object.keys(this.$refs).length === 0 &&
Object.keys(this.$arrays).length === 0 &&
Object.keys(this.$sets).length === 0 &&
Object.keys(this.$maps).length === 0;
};
$Builder.prototype.m = function m(field, key, element, doNotConvert) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isMap()) {
throw new Error(`Invalid call to ObjBuilder.m: non-map field ${field.name}.`);
}
let b = this.$maps[field.name];
if (b == null) {
b = this.$fields[field.name];
if (b == null || !b.$builder) {
b = this.$maps[field.name] = vt.makeBuilder(b);
}
}
if (arguments.length == 1) {
return b;
} else if (arguments.length == 3 || arguments.length == 4) {
b.put(key, element);
return this;
} else {
throw new Error(`Invalid call to ObjBuilder.m: expected field, key and value.`);
}
};
$Builder.prototype.mergeJson = function mergeJson(json) {
if (json != null) {
Object.keys(json).forEach(fn => this.v(fn, json[fn], false));
}
return this;
};
$Builder.prototype.mergeObj = function mergeObj(other, otherFieldsFilter) {
if (other == null) {
return this;
}
if (arguments.length == 1) {
if (this.objType() == other.type()) {
other.eachFieldValue((ft, v) => this.v(ft, v));
} else {
other.eachFieldValue((ft, v) => this.v(this.objType().fieldType(ft.name), v));
}
return this;
} else if (arguments.length == 2) {
if (other.instanceOf(otherFieldsFilter)) {
const tm = otherFieldsFilter.meta();
other.eachFieldValue((ft, v) => {
if (tm.fieldType(ft.name) != null)
this.v(ft, v);
});
}
return this;
}
throw new Error(`Invalid call to ObjBuilder.mergeObj: expected other and otherFieldsFilter.`);
};
$Builder.prototype.objType = function objType() {
return this.$objType;
};
$Builder.prototype.r = function r(field) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isReference()) {
throw new Error(`Invalid call to ObjBuilder.r: non-reference field ${field.name}.`);
}
let type = vt.dereference(true);
let b = this.$refs[field.name];
if (b == null) {
if (b == null || !b.$builder) {
b = this.$refs[field.name] = type.builder().mergeObj(b);
}
}
return b;
};
$Builder.prototype.s = function s(field, element, doNotConvert) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isSet()) {
throw Err.invalidCall('ObjBuilder.a', `non-array field ${field.name}`);
}
let b = this.$sets[field.name];
if (b == null) {
b = this.$fields[field.name];
if (b == null || !b.$builder) {
b = this.$sets[field.name] = vt.makeBuilder(b);
}
}
if (arguments.length == 1) {
return b;
} else if (arguments.length == 2 || arguments.length == 3) {
b.add(element);
return this;
} else {
throw Err.invalidCall('ObjBuilder.s', 'expected field and element');
}
};
$Builder.prototype.setFields = function setFields(fields, doNotConvert) {
if (fields != null) {
for (let [name, v] of fields) {
const ft = this.$objType.meta().fieldType(name, true);
if (v == null) {
delete this.$fields[ft.name];
} else {
this.$fields[ft.name] = v;
}
}
}
return this;
};
$Builder.prototype.v = function v(field, value, doNotConvert) {
if (arguments.length < 2) {
throw new Error(`Invalid call to ObjBuilder.v: expected field and value.`);
}
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
this.$fields[field.name] = value;
return this;
};
$Builder.prototype.build = function build() {
const type = this.$findType(this.$type, this.$fields);
let inst = Object.create(type.$objProto);
this.$setup(inst);
Object.keys(this.$refs).forEach(fn => {
this.$fields[fn] = this.$refs[fn].build();
});
Object.keys(this.$arrays).forEach(fn => {
this.$fields[fn] = this.$arrays[fn].build();
});
Object.keys(this.$sets).forEach(fn => {
this.$fields[fn] = this.$sets[fn].build();
});
Object.keys(this.$maps).forEach(fn => {
this.$fields[fn] = this.$maps[fn].build();
});
Object.keys(this.$fields).forEach(fn => {
let ft = type.$init.fieldTypes.find(fieldType => fieldType.name === fn && !fieldType.constant);
if (ft && inst[fn] === undefined && this.$fields[fn] != null) {
inst[fn] = this.$makeField(ft, this.$fields[fn]);
}
});
type.$init.fieldTypes.forEach(ft => {
if (!ft.constant && !_hasOwnProperty(inst, ft.name)) {
let vt = ft.valueType;
if (vt.modifier !== 'PRESERVES_EMPTY') {
let v = this.$makeField(ft, null);
if (v != null) {
inst[ft.name] = v;
}
}
}
});
inst = this.$afterMake(inst);
Object.freeze(inst);
if (this.$onbuild) {
this.$onbuild(inst);
}
return inst;
};
$Builder.prototype.type = function type() { return $type; };
$Builder.prototype.v = function v(field, value, doNotConvert) {
if (arguments.length < 2) {
throw new Error('Invalid call to ObjBuilder.v: expected field and value.');
}
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
this.$fields[field.name] = value;
return this;
};
let $logger;
function log() {
if ($logger == null) {
$logger = C3.Logger.for($type.name());
}
return $logger;
};
const $type = new Type$Proto($conn, $init);
const $proto = new (function Obj() {});
Object.defineProperty($proto, '$conn', { value: $conn });
Object.defineProperties($type, {
$objProto: { value: $proto },
$withType: { value: true }
});
Object.defineProperty($type, Symbol.hasInstance, { value: function(inst) { return inst != null && inst.$c3inst && inst.$c3inst.meta().isA(this); } });
$type.arrayBuilder = arrayBuilder;
$proto.toTypedJson = toTypedJson;
$proto.toBuilder = toBuilder;
$type.fromJsonString = fromJsonString;
$type.fromJson = fromJson;
$proto.fieldValueAtPath = fieldValueAtPath;
$proto.singletonSet = singletonSet;
$proto.fieldValue = fieldValue;
$proto.isEmptyObj = isEmptyObj;
$proto.withDefaults = withDefaults;
$type.array = array;
$proto.foldFieldValues = foldFieldValues;
$proto.toJson = toJson;
$type.make = make;
$proto.mapFieldValues = mapFieldValues;
$proto.eachFieldValue = eachFieldValue;
$proto.singletonArray = singletonArray;
$proto.mapFieldValuesAsync = mapFieldValuesAsync;
$type.mapBuilderOf = mapBuilderOf;
$proto.withField = withField;
$proto.withFields = withFields;
$proto.eachFieldValueWhile = eachFieldValueWhile;
$type.setBuilder = setBuilder;
$type.mapBuilder = mapBuilder;
$type.buildArray = function buildArray(builder) {
const b = this.arrayBuilder();
builder(b);
return b.build();
};
$type.buildMap = function buildMap(builder) {
const b = this.mapBuilder();
builder(b);
return b.build();
};
$type.builder = function builder(inst) { return new $Builder(this, inst); };
Object.defineProperty($type.builder, '$std', { value: true });
$type._instantiate = function _instantiate(fields) {
return this.make(fields);
};
$type.buildSet = function buildSet(builder) {
const b = this.setBuilder();
builder(b);
return b.build();
};
$proto.type = function type() { return $type; };
$proto.log = log;
$proto.toJSON = function toJSON() { return this.toTypedJson(); };
Object.freeze($type);
Object.freeze($proto);
return $type;
})());
$conn._registerType((function() {
const $init = _deepFreeze({
"type" : "TypeMeta",
"metadataPath" : "platform/src/typesys/value/WithType.c3typ",
"package" : "platform",
"packageSubPath" : "typesys.value",
"name" : "WithType",
"doc" : "Base type of instances (value) of a type that are \"type-aware\" i.e. can fully infer or store its own type.\n\n@see Obj",
"declaredAbstract" : true,
"declaredMixinRefTypes" : [ {
"name" : "Value"
} ],
"declaredFieldTypes" : [ {
"doc" : "C3 Type of this instance.",
"name" : "type",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
},
"abstract" : true,
"inline" : true,
"member" : true
}
}, {
"doc" : "Returns new instance with all references to old type, including result of #type, replaced with new type. If new\ntype does not contain fields from old or field value types are not convertable then drops the field.\n\nThis method is used during live metadata update",
"name" : "replaceType",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "old",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "new",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithType",
"mixing" : true
},
"private" : true,
"abstract" : true,
"inline" : true,
"member" : true
}
}, {
"doc" : " Produce a calling proxy that represents the content of all Obj type's mixins, but not the type itself. This is\n useful for redispatching **member** methods reimplemented on this type to a parent implementation:\n ```js\n function toString() {\n   return this.super().toString() + ', x=' + this.x;\n }\n ```\n\n ```py\n def toString(this):\n    return this.super().toString() + ', x=' + this.x\n```\n\n To redispatch **static** methods, see {@link Type#super}.\n\n Note that this not the same as the language-specific `super` keyword because it works through the type system and\n supports multiple mixins. It behaves like the Python `super()` function, except called on the instance rather than\n globally.\n\n If `mixin` is the implementing type in a client implementation, this will delegate the call to the server.\n This can be used to create a local implementation \"around\" the server implementation for additional caching or\n other local state management.\n\n @param mixin if specified, this mixin is used instead or an error is thrown\n @return \"super\" calling proxy for this object\n\n @see Type.super",
"name" : "super",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
} ],
"isWithType" : true,
"isObj" : false,
"isMutable" : false,
"isStateful" : false,
"isSingleton" : false,
"isDefaultInstance" : false,
"isAbstract" : true,
"hasEventStream" : false,
"isGeneric" : false,
"isNativeRemix" : false,
"hasVarBindings" : false,
"prototypeName" : "WithType",
"typeSerName" : "type",
"hasSerNameFields" : false,
"annotations" : {
"type" : "Annotations"
},
"mixins" : [ "Value" ],
"referenceType" : {
"type" : "ReferenceType",
"name" : "WithType"
},
"mixinsWithSourceCode" : {
"js-ide-vscode-client-node" : [ ]
},
"methods" : [ {
"type" : "Method",
"name" : "type",
"hasAnyStatic" : false,
"hasAnyAbstract" : true,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : false,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "C3 Type of this instance.",
"name" : "type",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
},
"abstract" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "type",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}
}, {
"type" : "Method",
"name" : "replaceType",
"hasAnyStatic" : false,
"hasAnyAbstract" : true,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithType",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : false,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns new instance with all references to old type, including result of #type, replaced with new type. If new\ntype does not contain fields from old or field value types are not convertable then drops the field.\n\nThis method is used during live metadata update",
"name" : "replaceType",
"params" : [ {
"name" : "old",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "new",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithType",
"mixing" : true
},
"private" : true,
"abstract" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "replaceType",
"params" : [ {
"name" : "old",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "new",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "WithType",
"mixing" : true
},
"paramNames" : [ "old", "new" ]
}
}, {
"type" : "Method",
"name" : "super",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithType" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithType"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : " Produce a calling proxy that represents the content of all Obj type's mixins, but not the type itself. This is\n useful for redispatching **member** methods reimplemented on this type to a parent implementation:\n ```js\n function toString() {\n   return this.super().toString() + ', x=' + this.x;\n }\n ```\n\n ```py\n def toString(this):\n    return this.super().toString() + ', x=' + this.x\n```\n\n To redispatch **static** methods, see {@link Type#super}.\n\n Note that this not the same as the language-specific `super` keyword because it works through the type system and\n supports multiple mixins. It behaves like the Python `super()` function, except called on the instance rather than\n globally.\n\n If `mixin` is the implementing type in a client implementation, this will delegate the call to the server.\n This can be used to create a local implementation \"around\" the server implementation for additional caching or\n other local state management.\n\n @param mixin if specified, this mixin is used instead or an error is thrown\n @return \"super\" calling proxy for this object\n\n @see Type.super",
"name" : "super",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "ReferenceType",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "super",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "ReferenceType",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"paramNames" : [ "mixin" ]
},
"$nearestImplementedOn" : "WithType"
} ],
"hasSourceCode" : {
"js-ide-vscode-client-node" : true
},
"fieldTypes" : [ ]
});
function super_(mixin) {
throw Err.notImplemented('WithType', 'super');
}
let $logger;
function log() {
if ($logger == null) {
$logger = C3.Logger.for($type.name());
}
return $logger;
};
const $type = new Type$Proto($conn, $init);
const $proto = new (function WithType() {});
Object.defineProperty($proto, '$conn', { value: $conn });
Object.defineProperties($type, {
$objProto: { value: $proto },
$withType: { value: true }
});
Object.defineProperty($type, Symbol.hasInstance, { value: function(inst) { return inst != null && inst.$c3inst && inst.$c3inst.meta().isA(this); } });
$proto.super = super_;
$type._instantiate = function _instantiate(value) {
let inst = Object.create(this.$objProto);
if (value != null) {
Object.defineProperty(inst, '$value', { value: Object.freeze(value) });
}
if (typeof this.$setupInst === 'function') {
this.$setupInst(inst);
}
return inst;
};
$proto.type = function type() { return $type; };
$proto.log = log;
$proto.toJSON = function toJSON() { return '$value' in this ? this.$value : null; };
Object.freeze($type);
Object.freeze($proto);
return $type;
})());
$conn._registerType((function() {
const $init = _deepFreeze({
"type" : "TypeMeta",
"metadataPath" : "platform/src/http/HttpResponse.c3typ",
"package" : "platform",
"packageSubPath" : "http",
"name" : "HttpResponse",
"doc" : "HTTP response, usually produced by {@link HttpRequest#sendAsync} or {@link HttpRequest#sendSync sendSync}.",
"declaredMixinRefTypes" : [ {
"name" : "HttpResponseMetadata"
} ],
"declaredFieldTypes" : [ {
"doc" : "The original request this response corresponds to.",
"name" : "request",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "HttpRequest"
}
}, {
"doc" : "The entity body as {@link Content} from the response, if any.",
"name" : "body",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Content"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Whether any body is present (regardless of status code).",
"name" : "hasBody",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "The time in milliseconds that sending the request and reading the response took.",
"name" : "elapsedMs",
"valueType" : {
"type" : "DoubleType",
"name" : "double"
}
}, {
"doc" : "@return `true` if the request succeeded (2xx).",
"name" : "succeeded",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "@return `true` if the request failed (4xx, 5xx).",
"name" : "failed",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "@return error information if request has #failed.",
"name" : "error",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Error"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "@return `true` if the request was a redirect (3xx).",
"name" : "redirected",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "@return new location if request was #redirected.",
"name" : "redirectUrl",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "@return C3 server id if this request was sent to C3 server or null or error otherwise.",
"name" : "serverId",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "failIfNot",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true
}
}, {
"doc" : "Parse the response body as JSON. If the body is empty, the value is null, otherwise it must be valid JSON.",
"name" : "json",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "JsonType",
"name" : "json"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Get the response body as a string. If the body is empty, the value is null.",
"name" : "string",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"name" : "_body",
"private" : true,
"valueType" : {
"type" : "BinaryType",
"name" : "binary"
}
}, {
"name" : "fromJava",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "request",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest"
}
}, {
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'org.apache.http.HttpResponse'"
} ]
} ],
"name" : "rsp",
"valueType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"private" : true,
"inline" : true
}
}, {
"name" : "fromJavaClosable",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "request",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest"
}
}, {
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'org.apache.http.client.methods.CloseableHttpResponse'"
} ]
} ],
"name" : "srp",
"valueType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"private" : true,
"inline" : true
}
}, {
"doc" : "Construct HttpResponse from python native http.client.HttpResponse.",
"name" : "fromPython",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "rsp",
"valueType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"private" : true,
"inline" : true,
"actionRequirementNames" : [ "py" ]
}
}, {
"name" : "withBody",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "body",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BinaryType",
"name" : "binary"
}
}, {
"valueType" : {
"type" : "StringType",
"name" : "string"
}
} ]
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Adds a Set-Cookie header to the response. Note that each cookie uses a separate header so a new header is always\nadded.\n\n@param name cookie name\n@param value cookie value\n@return modified response",
"name" : "withSetCookie",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Write body, headers, status code, and reason phrase from ths HttpResponse to provided java native\nHttpServerResponse. This is not a pure function - the HttpServerResponse will be mutated.",
"name" : "writeToHttpServerResponse",
"private" : true,
"valueType" : {
"type" : "MethodType",
"params" : [ {
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'io.vertx.core.http.HttpServerResponse'"
} ]
} ],
"name" : "res",
"valueType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
}
} ],
"member" : true
}
} ],
"isWithType" : true,
"isObj" : true,
"isMutable" : false,
"isStateful" : false,
"isSingleton" : false,
"isDefaultInstance" : false,
"isAbstract" : false,
"hasEventStream" : false,
"isGeneric" : false,
"isNativeRemix" : false,
"hasVarBindings" : false,
"prototypeName" : "HttpResponse",
"typeSerName" : "type",
"hasSerNameFields" : false,
"annotations" : {
"type" : "Annotations"
},
"mixins" : [ "HttpResponseMetadata", "WithHttpHeaders", "Obj", "Serializable", "Value", "Fingerprintable", "MemoryMeasurable", "WithType" ],
"referenceType" : {
"type" : "ReferenceType",
"name" : "HttpResponse"
},
"mixinsWithSourceCode" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders", "Obj", "WithType" ]
},
"fieldTypes" : [ {
"type" : "FieldType",
"doc" : "The internally used case-insensitive HTTP headers.",
"name" : "_headers",
"schemaSuffix" : "HDRS",
"private" : true,
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"isNumber" : false,
"instanceType" : "Map<string, [string]>"
}
}, {
"type" : "FieldType",
"doc" : "The HTTP status code (200, 400, etc) from the remote server.",
"name" : "statusCode",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "Int32Type",
"name" : "int32",
"isNumber" : true
}
}, {
"type" : "FieldType",
"doc" : "The HTTP status reason phrase (\"OK\", \"Bad Request\", etc).",
"name" : "reasonPhrase",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "StringType",
"name" : "string",
"isNumber" : false
}
}, {
"type" : "FieldType",
"doc" : "The HTTP version phrase (\"HTTP/1.1\").",
"name" : "httpVersion",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "StringType",
"name" : "string",
"isNumber" : false
}
}, {
"type" : "FieldType",
"doc" : "The original request this response corresponds to.",
"name" : "request",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "ReferenceType",
"name" : "HttpRequest",
"isNumber" : false,
"instanceType" : "HttpRequest"
}
}, {
"type" : "FieldType",
"doc" : "The time in milliseconds that sending the request and reading the response took.",
"name" : "elapsedMs",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "DoubleType",
"name" : "double",
"isNumber" : true
}
}, {
"type" : "FieldType",
"name" : "_body",
"private" : true,
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "BinaryType",
"name" : "binary",
"isNumber" : false
}
} ],
"methods" : [ {
"type" : "Method",
"name" : "toJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a JSON object.\n\n@return JSON object representation\n\n@see #fromJson",
"name" : "toJson",
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"name" : "toJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"name" : "toJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
} ]
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ]
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"paramNames" : [ "include", "exclude" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "toTypedJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a _typed_ JSON object.\n@param omitTopLevelType\n       Whether to leave out `type: {{ type of this serializable instance }}` as the **first** key-value pair in\n       the outer level of the produced json.\n@param runtime\n       If provided, then any special serialization logic required for the {@link ImplLanguage.Runtime} will be\n       performed. **NOTE** This argument is ignored if `typed` is not `true`. @see Ann.Ser\n\n\n@return JSON object representation\n\n@see #fromJson\n@see #toJson\n@see serdeser.c3doc\n@see JsonType",
"name" : "toTypedJson",
"params" : [ {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"name" : "toTypedJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"name" : "toTypedJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toTypedJson",
"params" : [ {
"name" : "omitTopLevelTypeOrIncludeOrInclude",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
} ]
}
}, {
"name" : "actionRequirementOrExcludeOrExclude",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
}, {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
} ]
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"paramNames" : [ "omitTopLevelTypeOrIncludeOrInclude", "actionRequirementOrExcludeOrExclude" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "toJsonString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toJsonString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized JSON string.\n\n@return JSON object as string",
"name" : "toJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "pretty" ]
}
}, {
"type" : "Method",
"name" : "toTypedJsonString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toTypedJsonString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"name" : "toTypedJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toTypedJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "pretty", "omitTopLevelType" ]
}
}, {
"type" : "Method",
"name" : "toJsString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toJsString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized JavaScript object literal.\n\n@return JavaScript object literal string",
"name" : "toJsString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJsString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "withType" ]
}
}, {
"type" : "Method",
"name" : "toXmlString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toXmlString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized XML string.\n\n@return XML element as string\n\n@see #fromXmlString",
"name" : "toXmlString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toXmlString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "withType" ]
}
}, {
"type" : "Method",
"name" : "serialize",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a string serialized representation of the object.\n\n@return string serialized object representation",
"name" : "serialize",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "serialize",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "contentType" ]
}
}, {
"type" : "Method",
"name" : "fromJson",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the JSON-based representation and reconstruct the corresponding object.\n\nfromJson is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which may be\na type that mixes in the type on which it is called). This means that the resulting object's type will be isA the\ncalled-on type, but perhaps not identical. In particular, `Obj.fromJson` works for any actual type and will return\nan instance of the correct type.\n\n@see #toJson",
"name" : "fromJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "HttpResponse",
"mixing" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "json" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fromJsonString",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the JSON-based representation and reconstruct the corresponding object.\n\nfromJsonString is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which may be\na type that mixes in the type on which it is called). This means that the resulting object's type will be isA the\ncalled-on type, but perhaps not identical. In particular, `Obj.fromJsonString` works for any actual type and will return\nan instance of the correct type.\n\n@see #toJsonString",
"name" : "fromJsonString",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "HttpResponse",
"mixing" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromJsonString",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "json" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fromXmlString",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the XML-based representation and reconstruct the corresponding object.\n\nfromXmlString is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which\nmay be a type that mixes in the type on which it is called). This means that the resulting object's type will be\nisA the called type, but perhaps not identical. In particular, `Obj.fromXmlString` works for any actual type and\nwill return an instance of the correct type.\n\n@see #toXmlString",
"name" : "fromXmlString",
"params" : [ {
"name" : "xml",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "HttpResponse",
"mixing" : true
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromXmlString",
"params" : [ {
"name" : "xml",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "xml" ]
}
}, {
"type" : "Method",
"name" : "deserialize",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load from contentType representation and reconstruct the corresponding object.\n\nfromString is be called on the type be deserialized and must reconstruct an object of the appropriate type\n(which may be a type that mixes in the type on which it is called). This means that the resulting object's type\nwill be isA the called-on type, but perhaps not identical. In particular, `fromString` works for any actual\ntype and will return an instance of the correct type.",
"name" : "deserialize",
"params" : [ {
"name" : "contentStr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "HttpResponse",
"mixing" : true
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "deserialize",
"params" : [ {
"name" : "contentStr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "contentStr", "contentType" ]
}
}, {
"type" : "Method",
"name" : "fingerprint",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Produce a checksum that can easily be compared to determine if two objects are definitely different. Note that\nthere is a slight possibility that two objects with the same fingerprint will actually differ.\n\nThe fingerprint recurses into field values, including collections and referenced Objs. The handling of nested\n{@link Identified identified} references (typically entities) differ in that _only_ the `id` field is included\nunless the allIdentifiedRefFields option is specified.\n\nIf the object graph may contain recursive embedded object references, the trackRecursiveRefs option may be used.\nHowever, maintaining the list of visited objects is costly so this should not be done unnecessarily.\n\n@param allIdentifiedRefFields\n          if `true`, fingerprint individual fields of persistable references, not just the `id`\n@param trackRecursiveRefs\n          if `true`, a set of referenced objects is maintained to avoid infinite recursion\n@param traversedRefs\n          only considered together with trackRecursiveRefs and if provided then all traversed references are\n          checked against and added to it\n@return integer fingerprint\n\n@see https://en.wikipedia.org/wiki/Fingerprint_(computing)",
"name" : "fingerprint",
"params" : [ {
"name" : "allIdentifiedRefFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "trackRecursiveRefs",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "traversedRefs",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<Obj>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fingerprint",
"params" : [ {
"name" : "allIdentifiedRefFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "trackRecursiveRefs",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "traversedRefs",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<Obj>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"paramNames" : [ "allIdentifiedRefFields", "trackRecursiveRefs", "traversedRefs" ]
}
}, {
"type" : "Method",
"name" : "retainedMemory",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Measures retained memory by this instance.\n\n@param deep\n       if true and this instance contains references to other objects also measures memory retained by those\n@param allMeasured\n       if set then will skip instances that are in the set and will add instances that where measured by this call\n@return retained memory in bytes for this instances",
"name" : "retainedMemory",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "allMeasured",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<any>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "retainedMemory",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "allMeasured",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<any>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"paramNames" : [ "deep", "allMeasured" ]
}
}, {
"type" : "Method",
"name" : "type",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "C3 Type of this instance.",
"name" : "type",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "type",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "replaceType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns new instance with all references to old type, including result of #type, replaced with new type. If new\ntype does not contain fields from old or field value types are not convertable then drops the field.\n\nThis method is used during live metadata update",
"name" : "replaceType",
"params" : [ {
"name" : "old",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "new",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "replaceType",
"params" : [ {
"name" : "old",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "new",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "old", "new" ]
}
}, {
"type" : "Method",
"name" : "super",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithType" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithType"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : " Produce a calling proxy that represents the content of all Obj type's mixins, but not the type itself. This is\n useful for redispatching **member** methods reimplemented on this type to a parent implementation:\n ```js\n function toString() {\n   return this.super().toString() + ', x=' + this.x;\n }\n ```\n\n ```py\n def toString(this):\n    return this.super().toString() + ', x=' + this.x\n```\n\n To redispatch **static** methods, see {@link Type#super}.\n\n Note that this not the same as the language-specific `super` keyword because it works through the type system and\n supports multiple mixins. It behaves like the Python `super()` function, except called on the instance rather than\n globally.\n\n If `mixin` is the implementing type in a client implementation, this will delegate the call to the server.\n This can be used to create a local implementation \"around\" the server implementation for additional caching or\n other local state management.\n\n @param mixin if specified, this mixin is used instead or an error is thrown\n @return \"super\" calling proxy for this object\n\n @see Type.super",
"name" : "super",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "ReferenceType",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "super",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "ReferenceType",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"paramNames" : [ "mixin" ]
},
"$nearestImplementedOn" : "WithType"
}, {
"type" : "Method",
"name" : "instanceOf",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Checks whether this Obj is an instance of the specified type by checking both its type and the mixin chain.\nThis is the most convenient way to ask \"is this type usable in a context requiring the other type?\"\n\n@return true if this instance is of this type or any of its mixins",
"name" : "instanceOf",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Checks whether this instance is an instance of the specified type by checking both its type and the mixin chain.\nThis is the most convenient way to ask \"is this type usable in a context requiring the other type?\"\n\n@return true if this instance is of this type or any of its mixins\n\n@see ValueType#isA",
"name" : "instanceOf",
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "instanceOf",
"params" : [ {
"name" : "typeNameOrType",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ]
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "typeNameOrType" ]
}
}, {
"type" : "Method",
"name" : "isEmptyObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether all the fields of this instance are empty.",
"name" : "isEmptyObj",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isEmptyObj",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "isSame",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether the specified instance represents exactly the same object as this instance.",
"name" : "isSame",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isSame",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "other" ]
}
}, {
"type" : "Method",
"name" : "fieldValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns value of the given field.\n\n@param field\n          Field to return the value for\n       defaultToEmpty\n          will return default empty value if field is missing",
"name" : "fieldValue",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Returns value of the given field type. Be sure to use the FieldType instance for the exact same type as the type of\nthe obj.\n\n@param field\n          Field to return the value for\n       defaultToEmpty\n          will return default empty value if field is missing\n@return value for the given field",
"name" : "fieldValue",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValue",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
} ]
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "field", "defaultToEmpty" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fieldValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldValue"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all non empty field values. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValues",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldValue"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValues",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldValue"
}
}
}
}, {
"type" : "Method",
"name" : "fieldValuesByOrdinal",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all field values including empty ones as array where value of a field is at corresponding ordinal position.\nUnless `skipTrailingEmpty` parameter is set and there are trailing empty values resulting array has same size as\n#dataFieldTypes",
"name" : "fieldValuesByOrdinal",
"params" : [ {
"name" : "skipTrailingEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesByOrdinal",
"params" : [ {
"name" : "skipTrailingEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"paramNames" : [ "skipTrailingEmpty" ]
}
}, {
"type" : "Method",
"name" : "fieldValuesByFieldType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all non empty field values by field type. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValuesByFieldType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesByFieldType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
}
}, {
"type" : "Method",
"name" : "fieldValuesByFieldName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all non empty field values by field name. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValuesByFieldName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesByFieldName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}
}, {
"type" : "Method",
"name" : "fieldNames",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all data field names including those whose values are empty. Array is ordered by field ordinal.",
"name" : "fieldNames",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldNames",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}
}, {
"type" : "Method",
"name" : "at",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return value of the field at provided ordinal\n\n@param ordinal\n        Integer ordinal of the field in the parent type\n@return value of field at ordinal",
"name" : "at",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "ordinal",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Return value for the given serialized expression\n\n@param expr\n        Serialized expression to obtain the value in the given Obj\n@param failIfNotValid\n        If set, fails if not a valid expression\n@return value obtained as a result of expression evaluation",
"name" : "at",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "expr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
}, {
"name" : "failIfNotValid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "at",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "ordinalOrExpr",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
}, {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
} ]
}
}, {
"name" : "failIfNotValid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "ordinalOrExpr", "failIfNotValid" ]
}
}, {
"type" : "Method",
"name" : "fieldValueAtPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Looks up a single field value by path from this Obj. Field paths are separated by dots so an expression like\n`fieldValueAtPath(\"location.elevation\")` is equivalent to `traverse(\"location\").fieldValue(\"elevation\")` except\nthat it also handles `null`. If path contains any collections then only first element will be traversed,\nunless the collection index is specified in the path.\n\nIf you need to traverse all elements of collection fields use #fieldValuesAtPath instead.\n\n@param fieldPath\n          field names separated by dots\n@param failIfNotFound\n          if true, an error will be thrown if the any of the field types aren't defined\n@param context\n          if an error is thrown, the context returned by calling the lambda will be incorporated\n@return the field or null",
"name" : "fieldValueAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValueAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "fieldPath", "failIfNotFound", "context" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fieldValuesAtPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "VarReferenceType",
"name" : "T"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Looks up all the fields by path from root Obj. If path contains any collections then result will contain all\ntraversals, unless the collection index is specified in the path.\n\n@param fieldPath\n          field names separated by dots\n@param failIfNotFound\n          if true, an error will be thrown if the any of the field types aren't defined\n@param context\n          if an error is thrown, the context returned by calling the lambda will be incorporated\n@return fields as a flat list\n\n@see #fieldValueAtPath",
"name" : "fieldValuesAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "VarReferenceType",
"name" : "T"
}
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "VarReferenceType",
"name" : "T"
}
},
"paramNames" : [ "fieldPath", "failIfNotFound", "context" ]
}
}, {
"type" : "Method",
"name" : "eachFieldValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Perform an action for each non-empty field of this object.\n\n@param action\n          lambda to apply",
"name" : "eachFieldValue",
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Perform an action for each field of this object. Fields are filtered based on provided `spec`.\n\n@param spec\n          which fields to include\n@param action\n          lambda to apply",
"name" : "eachFieldValue",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachFieldValue",
"params" : [ {
"name" : "actionOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"paramNames" : [ "actionOrSpec", "action" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "eachFieldValueWhile",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Perform an action for each field of this object while processing action returns `true`. Fields are filtered based\non provided `spec`.\n\n@param spec\n          which fields to include\n@param action\n          lambda to apply; stop if this `action` returns `false\n@return `true` if iteration was not aborted by lambda i.e. it saw all field values",
"name" : "eachFieldValueWhile",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachFieldValueWhile",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "spec", "action" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "eachRef",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type. For reference fields, this means\nthe field value if non-null and for collections of Obj, this means each element in the collection.\n\n@param action\n          function to be executed for each pair of field type and Obj instance",
"name" : "eachRef",
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type. For reference fields, this means\nthe field value if non-null and for collections of Obj, this means each element in the collection.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param action\n          function to be executed for each pair of field type and Obj instance",
"name" : "eachRef",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRef",
"params" : [ {
"name" : "actionOrIncludeEmpty",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
}, {
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ]
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"paramNames" : [ "actionOrIncludeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "eachRefWhile",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type while processing action returns\n`true`.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param action\n          function to be executed for each pair of field type and Obj instance; stops processing if return `false`\n@return `true` if iteration was not aborted by lambda i.e. it saw all refs",
"name" : "eachRefWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRefWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "includeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "eachRefRecursive",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type or in any child refs.",
"name" : "eachRefRecursive",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRefRecursive",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"paramNames" : [ "includeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "eachRefRecursiveWhile",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type or in any child refs. Continue while\nprocessing action returns `true`.",
"name" : "eachRefRecursiveWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRefRecursiveWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "includeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "mapFieldValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Result of this function call is a copy of current instance with all non empty fields replaced based on results of\nthe `mapper` invocation.\n\n@param action\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValues",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Result of this function call is a copy of current instance with all fields replaced based on results of the\n`mapper` invocation.\n\n@param spec\n          which fields to include\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValues",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapFieldValues",
"params" : [ {
"name" : "mapperOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "convertValueOrMapper",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ]
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "mapperOrSpec", "convertValueOrMapper", "convertValue" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapFieldValuesAsync",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing HttpResponse>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Result of this function call is a copy of current instance with all non empty fields replaced based on results of\nthe asynchronous `mapper` invocation.\n\n@param action\n          lambda to apply for every field value to produce a new value for that fields\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValuesAsync",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing HttpResponse>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Result of this function call is a copy of current instance with all fields replaced based on results of the\nasynchronous `mapper` invocation.\n\n@param spec\n          which fields to include\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValuesAsync",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing HttpResponse>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"name" : "mapFieldValuesAsync",
"params" : [ {
"name" : "mapperOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "convertValueOrMapper",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
} ]
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing HttpResponse>",
"hadDeclaredVarBindings" : true
},
"paramNames" : [ "mapperOrSpec", "convertValueOrMapper", "convertValue" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapFieldValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Result of this function call is a copy of current instance with specified field value replaced based on result of\nthe `mapper` invocation.\n@param field\n          field being mapped\n@param includeEmpty\n          if set, invokes mapper for fields with empty value\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValue",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapFieldValue",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "field", "includeEmpty", "mapper", "convertValue" ]
}
}, {
"type" : "Method",
"name" : "mapRefs",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Executes the specified lambda against each referenced Obj instance and replaces it's value with result of this\nlambda application.\n\nResult of this function call is a copy of current instance with all references replaced based on results of the\n`mapper` invocation.\n\n@param action\n          function to be executed for each pair of field type and Obj instance\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapRefs",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Executes the specified lambda against each referenced Obj instance and replaces it's value with result of this\nlambda application.\n\nResult of this function call is a copy of current instance with all references replaced based on results of the\n`mapper` invocation.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param mapper\n          function to be executed for each pair of field type and Obj instance for producing new reference value\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapRefs",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapRefs",
"params" : [ {
"name" : "mapperOrIncludeEmpty",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
}, {
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ]
}
}, {
"name" : "convertValueOrMapper",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
} ]
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "mapperOrIncludeEmpty", "convertValueOrMapper", "convertValue" ]
}
}, {
"type" : "Method",
"name" : "foldFieldValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Result of this function is application of `folder` lambda to every non empty field value where `accumulator`\nargument is a result of previous application. Initial value of `accumulator` will be `null`.\n\nThis function is useful for calculating aggregate values based on all current non empty field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Result of this function is application of `folder` lambda to every non empty field value where `accumulator`\nargument is a result of previous application. Initial value of `accumulator` is provided via `initial` parameter.\n\nThis function is useful for calculating aggregate values based on all current non empty field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "initial",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Result of this function is application of `folder` lambda to every field value where `accumulator` argument is a\nresult of previous application. Initial value of `accumulator` is provided via `initial` parameter.\n\nThis function is useful for calculating aggregate values based on all field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "initial",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}, {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "folderOrInitialOrInitial",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
}, {
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ]
}
}, {
"name" : "folderOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "folderOrInitialOrInitial", "folderOrSpec", "folder" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "evalProjection",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "AnyType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Evaluates given projection expression over this instance.",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
}, {
"name" : "resultType",
"valueType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "AnyType"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Evaluates given projection over this instance and returns results as json.",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "JsonType",
"name" : "json"
},
"inline" : true,
"member" : true,
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Evaluates given projection over this instance and returns results as instance of the new Obj.",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
}, {
"name" : "resultType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
},
"inline" : true,
"member" : true,
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
}, {
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
} ]
}
}, {
"name" : "resultTypeOrBindingsOrResultType",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
}, {
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
} ]
}
}, {
"name" : "bindingsOrOptionsOrBindings",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ]
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "AnyType"
},
"paramNames" : [ "projection", "resultTypeOrBindingsOrResultType", "bindingsOrOptionsOrBindings", "options" ]
}
}, {
"type" : "Method",
"name" : "validateObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjResult"
}
} ]
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Populates all missing default values and throws error if any constraint it violated.",
"name" : "validateObj",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Validate that the Obj fields are set according to all the required rules.",
"name" : "validateObj",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjSpec"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjResult"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "validateObj",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjSpec"
}
} ],
"returnType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjResult"
}
} ]
},
"paramNames" : [ "spec" ]
}
}, {
"type" : "Method",
"name" : "withField",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the provided field in it. The name must correspond to an existing field\ndefined on this type or its mixins. The value must be of the correct type if doNotConvert flag is true.\n\n@param field\n          name of the field\n@param value\n          of the field\n@param doNotConvert\n          if true, do not attempt to convert the value to match the field's type\n@return new Obj",
"name" : "withField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the provided field in it. The name must correspond to an existing field\ndefined on this type or its mixins. The value must be of the correct type if doNotConvert flag is true.\n\n@param field\n          the field\n@param value\n          of the field\n@param doNotConvert\n          if true, do not attempt to convert the value to match the field's type\n@return new Obj",
"name" : "withField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
} ]
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "field", "value", "doNotConvert" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "withFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the provided fields in it. The name must correspond to an existing fields\ndefined on this type or its mixins. The values must be of the correct type if doNotConvert flag is true.\n\n@param fields\n          map of fields name/values\n@param doNotConvert\n          if true, attempt to convert the values to match the fields' type\n@return new Obj",
"name" : "withFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "fields", "doNotConvert" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "withFieldAtPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj with the value at the specified path field. If the value is null, the final field is removed.\n\nImmutable objects may return the same instance if the field being set or removed does not actually represent a\nchange to the existing object.\n\n@param path\n          path to set value at\n@param value\n          value to set\n@param doNotConvert\n          if true, attempt to convert the values to match the fields' type\n@param doNotCreateIfMissing\n          true indicates that any empty reference along the path will not set the value\n@return new Obj",
"name" : "withFieldAtPath",
"params" : [ {
"name" : "path",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "doNotCreateIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withFieldAtPath",
"params" : [ {
"name" : "path",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "doNotCreateIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "path", "value", "doNotConvert", "doNotCreateIfMissing" ]
}
}, {
"type" : "Method",
"name" : "withoutField",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the field with the provided name.\n\nImmutable objects may return the same instance if the field being removed is not present in the existing object.\n\n@param name\n          of the field to remove\n@return new Obj with removed field",
"name" : "withoutField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the field with the provided field type.\n\nImmutable objects may return the same instance if the field being removed is not present in the existing object.\n\n@param field\n          of the field to remove\n@return new Obj with removed field",
"name" : "withoutField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
} ]
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "field" ]
}
}, {
"type" : "Method",
"name" : "withoutFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the fields with the provided names.\n\nImmutable objects may return the same instance if the fields being removed are not present in the existing object.\n\n@param names\n          of the fields to remove\n@return new Obj with removed fields",
"name" : "withoutFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "withoutFieldsByType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the fields with the provided field types. Be sure to use the FieldType instance for the\nexact same type as the type of the obj to respect the \"ordinal\" of the field type\n\nImmutable objects may return the same instance if the fields being removed are not present in the existing object.\n\n@param fields\n          of the fields to remove\n@return new Obj with removed fields",
"name" : "withoutFieldsByType",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutFieldsByType",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "withDefaults",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the default values (if defined) for all empty fields. This is implemented by\ncalling {@link FieldType#defaultValue defaultValue} for a field if it is not already set and\n{@link FieldType#hasDefault has a default}. It will also set {@see ValueType#initialValue initial values} for\nfields with required primitive ValueTypes (E.g. x: `!int32` -> will be set to 0). Note that this will not overwrite\nfields that have already been set.\n\n{@link FunctionParam#validateArg} will call {@link #withDefaults} for {@link Spec}s passed as arguments to methods.\nAs a result, methods should be implemented assuming all default values are set on `Spec` arguments.\n\n@param includeEmptyRefsWithDefaults\n          it `true` then missing / empty child references that have fields with defaults will also be instantiated\n@param defaultFields\n          If not empty, a list of default field paths to populate.  Any default fields not specified in the\n          array will be ignored.\n@return new Obj\n\n@see FieldType#defaultValueConst\n@see FieldType#defaultValue",
"name" : "withDefaults",
"params" : [ {
"name" : "includeEmptyRefsWithDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "defaultFields",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withDefaults",
"params" : [ {
"name" : "includeEmptyRefsWithDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "defaultFields",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "includeEmptyRefsWithDefaults", "defaultFields" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mergeObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Merges all the fields of the provided Obj into this instance, producing a new Obj of the same type as this one.\nIn case of conflicts, fields of other instance take precedence unless otherwise specified by the fieldPathMergeSpec\n\n@param other\n          object\n@param fieldPathMergeSpec\n          mapping of fields of the object to the respective merge annotations\n@return the new merged Obj",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "fieldPathMergeSpec",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Merges all the fields of the provided Obj into this instance, producing a new Obj of the same type as this one.\nIn case of conflicts, fields of other instance take precedence.\n\n@param other\n          object\n@param otherFieldsFilter\n          only fields of otherFieldsFilter type from other are merged into this obj.\n@return the new merged Obj",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "otherFieldsFilter",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Merge the fields of this Obj with corresponding fields on other Obj using the provided lambda. This means that\nfields that exist on other Obj and do not exist on this Obj will not be added to final Obj.\n@param deep\n       if set to true then traverse reference and collection fields and merge corresponding fields or elements with\n       the same key or index.",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 2
}, {
"type" : "MethodType",
"doc" : "Merge the fields of this Obj with corresponding fields on other Obj using the provided lambda. This means that\nfields that exist other Obj and do not exist on this Obj will not be added to final Obj or evaluated. Does not\ntraverse child reference and collection fields.",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 3
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "fieldPathMergeSpecOrOtherFieldsFilterOrDeepOrMerger",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ]
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "other", "fieldPathMergeSpecOrOtherFieldsFilterOrDeepOrMerger", "merger" ]
}
}, {
"type" : "Method",
"name" : "mergeAndExpandObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Create new Obj with all non-null fields of this and other. Fields that are non null in both apply merger lambda.\nFields that non null in only one of this and other will be in the resulting Obj without change.",
"name" : "mergeAndExpandObj",
"genericVars" : [ {
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeAndExpandObj",
"genericVars" : [ {
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"paramNames" : [ "other", "merger" ]
}
}, {
"type" : "Method",
"name" : "mergeJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "mergeJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "json" ]
}
}, {
"type" : "Method",
"name" : "mergeChildren",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Merge the obj references within the current obj\n@param deep\n       If set, traverses the reference fields within the obj as well for a deep merge\n@param objKey\n       lambda specifying how to obtain the key for the Obj while determining which Objs to merge\n@param filter\n       Field paths that need to be filtered from this merge\n@return Obj with child references merged",
"name" : "mergeChildren",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "objKey",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "child",
"valueType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "filter",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeChildren",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "objKey",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "child",
"valueType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "filter",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "deep", "objKey", "filter" ]
}
}, {
"type" : "Method",
"name" : "sumObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds the numeric Obj fields with the other Objs respective fields.\nIf deep is set it will traverse reference and collection fields and sum corresponding numeric fields in\nreferences with same name and collection elements at same index or key.",
"name" : "sumObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "sumObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "other", "deep" ]
}
}, {
"type" : "Method",
"name" : "singletonArray",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "HttpResponse",
"mixing" : true
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Build an array of the correct type with a single element which is this instance.\n\n@return new array instance with this as only element.",
"name" : "singletonArray",
"returnType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "HttpResponse",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"name" : "singletonArray",
"returnType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "HttpResponse",
"mixing" : true
}
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "array",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "HttpResponse",
"mixing" : true
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an array of instances of this type.",
"name" : "array",
"params" : [ {
"name" : "elements",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "HttpResponse",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "array",
"params" : [ {
"name" : "elements",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "HttpResponse",
"mixing" : true
}
},
"paramNames" : [ "elements" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "arrayBuilder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "ArrayBuilder<mixing HttpResponse>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an array of instances of this type.",
"name" : "arrayBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "ArrayBuilder<mixing HttpResponse>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "arrayBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "ArrayBuilder<mixing HttpResponse>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "singletonSet",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "SetType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "HttpResponse",
"mixing" : true
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Build an set of the correct type with a single element which is this instance.\n\n@return new array instance with this as only element.",
"name" : "singletonSet",
"returnType" : {
"type" : "SetType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "HttpResponse",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"name" : "singletonSet",
"returnType" : {
"type" : "SetType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "HttpResponse",
"mixing" : true
}
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "setBuilder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<mixing HttpResponse>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates a set of instances of this type.",
"name" : "setBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<mixing HttpResponse>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "setBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<mixing HttpResponse>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapBuilder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<string, mixing HttpResponse>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Create a map of string to elements of this type.",
"name" : "mapBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<string, mixing HttpResponse>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<string, mixing HttpResponse>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapBuilderOf",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<any, mixing HttpResponse>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Create a map with the given key type and elements of this type.",
"name" : "mapBuilderOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<any, mixing HttpResponse>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapBuilderOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<any, mixing HttpResponse>",
"hadDeclaredVarBindings" : true
},
"paramNames" : [ "keyType" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "myReferenceType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myReferenceType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myReferenceType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
}
}
}, {
"type" : "Method",
"name" : "myMapTypeOf",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myMapTypeOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myMapTypeOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"paramNames" : [ "keyType" ]
}
}, {
"type" : "Method",
"name" : "myMapType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myMapType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myMapType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
}
}
}, {
"type" : "Method",
"name" : "myArrayType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myArrayType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myArrayType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
}
}
}, {
"type" : "Method",
"name" : "mySetType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "mySetType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mySetType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
}
}
}, {
"type" : "Method",
"name" : "myStreamType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myStreamType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myStreamType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
}
}
}, {
"type" : "Method",
"name" : "toBuilder",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing HttpResponse>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return new ObjBuilder with initial state set to fields of this instance.",
"name" : "toBuilder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing HttpResponse>",
"hadDeclaredVarBindings" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toBuilder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing HttpResponse>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "builder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing HttpResponse>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return new ObjBuilder of this instance.",
"name" : "builder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing HttpResponse>",
"hadDeclaredVarBindings" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "builder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing HttpResponse>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fromFields",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type from provided fields\n@param fields\n           Fields to construct the instance of the obj with\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0) populated\n\n@see withDefaults",
"name" : "fromFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "fields", "withDefaults" ]
}
}, {
"type" : "Method",
"name" : "make",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type with no non-default field values unless explicitly specified by passing param true\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0)\n           populated\n\n@see withDefaults",
"name" : "make",
"params" : [ {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Construct an instance from provided fields\n@param fields\n           Fields (in the format <field_name, value>) to construct an instance of the obj. Note that \"type\" as a\n           field_name will be considered as the actual Obj's type, e.g. Obj.make({\"type\": \"Panda\"}) is equivalent\n           to Panda.make()\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32\n           -> 0) populated. Passing an empty value for a field will result in the default field value being set if\n           the field does not {@link ValueModifier#PRESERVES_EMPTY preserve empty} and {@link FieldType#hasDefault\n           has a default value}.\n\n\n@see fromFields\n@see beforeMake\n@see afterMake\n@see withDefaults",
"name" : "make",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : " Construct an instance of this type from provided fields. Note it is more efficient to use #fromFields and other overloads\n\n ```js\n User.make({\n   email: 'joe@smith.com',\n   realName: 'Joe Smith'\n })\n\n Obj.make({\n   type: 'User',\n   email: 'joe@smith.com',\n   realName: 'Joe Smith'\n })\n ```\n\n ```py\n c3.User.make({\n   \"email\": 'joe@smith.com',\n   \"realName\": 'Joe Smith'\n })\n\n c3.Obj.make({\n   \"type\": 'User',\n   \"email\": 'joe@smith.com',\n   \"realName\": 'Joe Smith'\n })\n\n c3.User(email='joe@smith.com', realName='Joe Smith')\n\n c3.Obj(type='User', email='joe@smith.com', realName='Joe Smith')\n```\n\n Note that this is **not** the same as the [serialization format](serdeser.c3doc). This is a convenient way to\n specify fields and values in the \"JSON like\" form supported by each language, but the usual serialization rules,\n such as {@link Ann.Ser} do not apply.\n @param fields\n            Fields to construct the instance of the obj with\n @param withDefaults\n            If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0) populated\n\n @see fromFields\n @see beforeMake\n @see afterMake\n @see withDefaults",
"name" : "make",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "make",
"params" : [ {
"name" : "withDefaultsOrFieldsOrFields",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "withDefaultsOrFieldsOrFields", "withDefaults" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "remake",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type from provided instance of a subtype or a \"duck type\".",
"name" : "remake",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "failIfExtraOrInvalidFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "remake",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "failIfExtraOrInvalidFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "other", "failIfExtraOrInvalidFields" ]
}
}, {
"type" : "Method",
"name" : "remakeAs",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an obj of the new type with all fields that exist on the original obj that are defined in the new type\nconverted and copied to the new obj instance. Note, that checking assignability and conversion of field values\ncould be costly if types have different value types for same fields.\n\n@param type\n        Type of new obj to return\n@return new obj of the requested type with all fields present in the original obj that are defined in the new type\n        converted and copied to it",
"name" : "remakeAs",
"genericVars" : [ {
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "remakeAs",
"genericVars" : [ {
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"paramNames" : [ "type" ]
}
}, {
"type" : "Method",
"name" : "beforeMake",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : true,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : false,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Optional override that will be called every time instance of this type is created.\n\n\nNote that it introduces additional overhead so should only be implemented for low volume data.",
"name" : "beforeMake",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"private" : true,
"optional" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "beforeMake",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "afterMake",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : true,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : false,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Optional override that will be called after every instance creation.\n\nNote that it introduces additional overhead so should only be implemented for low volume data.",
"name" : "afterMake",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"private" : true,
"optional" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "afterMake",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
}
}
}, {
"type" : "Method",
"name" : "cachedEmptyInst",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an empty inst using `MyType.make()` and caches it. Avoid recreating multiple copies of the spec for\nevery action dispatch. The cached inst can also be used for comparing whether the object is an empty or not\nWill only create empty instance for immutable Obj e.g. if an Obj is Mutable, this method will throw an error\n\n@see ValueType#defaultEmptyValue",
"name" : "cachedEmptyInst",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "cachedEmptyInst",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
}
}
}, {
"type" : "Method",
"name" : "toData",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Data"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Represent the current obj instance as {@link Data}",
"name" : "toData",
"returnType" : {
"type" : "ReferenceType",
"name" : "Data"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toData",
"returnType" : {
"type" : "ReferenceType",
"name" : "Data"
}
}
}, {
"type" : "Method",
"name" : "header",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns the header value for a header containing a single value.\n\n@param @required name\n          The header name, case insensitive\n@param dflt\n          The default value to return if the header does not exist\n@return The header value, or values concatenated together by ', ' if multiple, or dflt if not found.",
"name" : "header",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "dflt",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "header",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "dflt",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "name", "dflt" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "headers",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns the header values for a header containing potentially multiple values.\n\n@param @required name\n          the header name, case insensitive\n@return The header values array if header is found, else empty array.",
"name" : "headers",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "headers",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"paramNames" : [ "name" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "allHeaders",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns the headers map with the lower-case header and list of values",
"name" : "allHeaders",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "allHeaders",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "allHeadersMerged",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns headers map with keys of the lower-case header and value the result of the predicate. If predicate is not\nprovided, it will combine all headers with a \", \" except it will skip the set-cookie header if its present.\n\n@param merger\n          the optional function used to turn the array of header values to a string value. If the predicate returns\n          an empty value, it will not be added to the output.\n@return The headers map with keys of the lower-case header and value the result of the predicate",
"name" : "allHeadersMerged",
"params" : [ {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "header",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"name" : "values",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "allHeadersMerged",
"params" : [ {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "header",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"name" : "values",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"paramNames" : [ "merger" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "findFirstHeaderValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns the first header value satisfied by the given predicate.\n\n@param name\n          the header name (case-insensitive)\n@param predicate\n          the condition used to find the header value. If null the first header value found will be used\n@return The first matching header value for name or null if not found.",
"name" : "findFirstHeaderValue",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "predicate",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "v",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "findFirstHeaderValue",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "predicate",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "v",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "name", "predicate" ]
}
}, {
"type" : "Method",
"name" : "findAllHeaderValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns the header values satisfied by the given predicate.\n\n@param name\n          the header name (case-insensitive)\n@param predicate\n          the condition used to find the header values. If null the all header values for name will be returned\n@return All matching header values for name or null if not found.",
"name" : "findAllHeaderValues",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "predicate",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "v",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "findAllHeaderValues",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "predicate",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "v",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"paramNames" : [ "name", "predicate" ]
}
}, {
"type" : "Method",
"name" : "contentType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "The content type for these headers.",
"name" : "contentType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "contentType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "contentEncoding",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "The content encoding for these headers.",
"name" : "contentEncoding",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "contentEncoding",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "cookieValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Gets the cookie value from Http headers by a given cookie key.\n\n@param key\n          cookie key\n@return The cookie value or null if not found.",
"name" : "cookieValue",
"params" : [ {
"name" : "key",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "cookieValue",
"params" : [ {
"name" : "key",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "key" ]
}
}, {
"type" : "Method",
"name" : "replaceHeader",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Sets the header to (only) the specified value. This will wipe out any prior setting of this header, replacing it\nwith just this value. This is useful to _change_ a header value, instead of adding another value.\n\n@param name\n          header name (case-insensitive)\n@param value\n          replacement header value\n@return The new {@link WithHttpHeaders} object with name and value applied\n\n@see #withHeader\n@see #withoutHeader",
"name" : "replaceHeader",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "replaceHeader",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "name", "value" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withHeader",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds a header value into the existing headers. If called multiple times with the same header name, all values\nwill be added in the order they were called with duplicates removed.\n\n@param name\n          header name (case-insensitive)\n@param value\n          additional header value\n@return The new {@link WithHttpHeaders} object with name and value applied\n\n@see #replaceHeader\n@see #withoutHeader",
"name" : "withHeader",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withHeader",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "name", "value" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withoutHeader",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Removes all values from the existing header.\n\n@param name\n          header name (case-insensitive)\n@return The new {@link WithHttpHeaders} object with header removed\n\n@see #withHeader\n@see #replaceHeader",
"name" : "withoutHeader",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutHeader",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "name" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withHeaders",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Puts multiple header values into the existing headers. If the map has keys that collide in a case-insensitive way,\nthe order of the values may not be preserved, but duplicate values will be removed.\n\n@param headers\n          a map where the key is a header and value is one or many string values for that header.\n@return A modified {@link WithHttpHeaders} object with the headers applied",
"name" : "withHeaders",
"params" : [ {
"name" : "headers",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ]
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withHeaders",
"params" : [ {
"name" : "headers",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ]
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "headers" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withJsonHeaders",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds \"Accept\" and \"ContentType\" headers as \"application/json\".",
"name" : "withJsonHeaders",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withJsonHeaders",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
}
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withActionEngineHeader",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Add a \"X-C3-Action-Engine\" header appropriate to the current execution environment.",
"name" : "withActionEngineHeader",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withActionEngineHeader",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
}
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withAuthHeader",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Add Authorization header to this HTTP header.",
"name" : "withAuthHeader",
"params" : [ {
"name" : "auth",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Authorization"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withAuthHeader",
"params" : [ {
"name" : "auth",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Authorization"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "auth" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withContentType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds a content type to this HTTP header. Will silently not add contentType if it is empty.",
"name" : "withContentType",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withContentType",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "contentType" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "withContentEncoding",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithHttpHeaders" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithHttpHeaders"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds a content encoding type to this HTTP header. Will silently not add contentEncoding if it is empty.",
"name" : "withContentEncoding",
"params" : [ {
"name" : "contentEncoding",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentEncoding"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withContentEncoding",
"params" : [ {
"name" : "contentEncoding",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentEncoding"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "contentEncoding" ]
},
"$nearestImplementedOn" : "WithHttpHeaders"
}, {
"type" : "Method",
"name" : "statusCodeToReasonPhrase",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : true,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return the standard reason phrase for an status code. For example: \"Not Found\" for 404.\n\n@param code HTTP status code\n@param failIfNone throw an error if the code is invalid\n@return reason phrase",
"name" : "statusCodeToReasonPhrase",
"params" : [ {
"name" : "code",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
}, {
"name" : "failIfNone",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "statusCodeToReasonPhrase",
"params" : [ {
"name" : "code",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
}, {
"name" : "failIfNone",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "code", "failIfNone" ]
}
}, {
"type" : "Method",
"name" : "body",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Content"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "HttpResponse" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "HttpResponse"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "The entity body as {@link Content} from the response, if any.",
"name" : "body",
"returnType" : {
"type" : "ReferenceType",
"name" : "Content"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "body",
"returnType" : {
"type" : "ReferenceType",
"name" : "Content"
}
},
"$nearestImplementedOn" : "HttpResponse"
}, {
"type" : "Method",
"name" : "hasBody",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "HttpResponse" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "HttpResponse"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether any body is present (regardless of status code).",
"name" : "hasBody",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasBody",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
},
"$nearestImplementedOn" : "HttpResponse"
}, {
"type" : "Method",
"name" : "succeeded",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "HttpResponse" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "HttpResponse"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return `true` if the request succeeded (2xx).",
"name" : "succeeded",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "succeeded",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
},
"$nearestImplementedOn" : "HttpResponse"
}, {
"type" : "Method",
"name" : "failed",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "HttpResponse" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "HttpResponse"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return `true` if the request failed (4xx, 5xx).",
"name" : "failed",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "failed",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
},
"$nearestImplementedOn" : "HttpResponse"
}, {
"type" : "Method",
"name" : "error",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Error"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "HttpResponse" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "HttpResponse"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return error information if request has #failed.",
"name" : "error",
"returnType" : {
"type" : "ReferenceType",
"name" : "Error"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "error",
"returnType" : {
"type" : "ReferenceType",
"name" : "Error"
}
},
"$nearestImplementedOn" : "HttpResponse"
}, {
"type" : "Method",
"name" : "redirected",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "HttpResponse" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "HttpResponse"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return `true` if the request was a redirect (3xx).",
"name" : "redirected",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "redirected",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
},
"$nearestImplementedOn" : "HttpResponse"
}, {
"type" : "Method",
"name" : "redirectUrl",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "HttpResponse" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "HttpResponse"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return new location if request was #redirected.",
"name" : "redirectUrl",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "redirectUrl",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
},
"$nearestImplementedOn" : "HttpResponse"
}, {
"type" : "Method",
"name" : "serverId",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return C3 server id if this request was sent to C3 server or null or error otherwise.",
"name" : "serverId",
"params" : [ {
"name" : "failIfNot",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "serverId",
"params" : [ {
"name" : "failIfNot",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "failIfNot" ]
}
}, {
"type" : "Method",
"name" : "json",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "JsonType",
"name" : "json"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "HttpResponse" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "HttpResponse"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Parse the response body as JSON. If the body is empty, the value is null, otherwise it must be valid JSON.",
"name" : "json",
"returnType" : {
"type" : "JsonType",
"name" : "json"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "json",
"returnType" : {
"type" : "JsonType",
"name" : "json"
}
},
"$nearestImplementedOn" : "HttpResponse"
}, {
"type" : "Method",
"name" : "string",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "HttpResponse" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "HttpResponse"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get the response body as a string. If the body is empty, the value is null.",
"name" : "string",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "string",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
},
"$nearestImplementedOn" : "HttpResponse"
}, {
"type" : "Method",
"name" : "fromJava",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "request",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "fromJava",
"params" : [ {
"name" : "request",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest"
}
}, {
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'org.apache.http.HttpResponse'"
} ]
} ],
"name" : "rsp",
"valueType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"private" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromJava",
"params" : [ {
"name" : "request",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest"
}
}, {
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'org.apache.http.HttpResponse'"
} ]
} ],
"name" : "rsp",
"valueType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"paramNames" : [ "request", "rsp" ]
}
}, {
"type" : "Method",
"name" : "fromJavaClosable",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "request",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "fromJavaClosable",
"params" : [ {
"name" : "request",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest"
}
}, {
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'org.apache.http.client.methods.CloseableHttpResponse'"
} ]
} ],
"name" : "srp",
"valueType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"private" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromJavaClosable",
"params" : [ {
"name" : "request",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpRequest"
}
}, {
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'org.apache.http.client.methods.CloseableHttpResponse'"
} ]
} ],
"name" : "srp",
"valueType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"paramNames" : [ "request", "srp" ]
}
}, {
"type" : "Method",
"name" : "fromPython",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct HttpResponse from python native http.client.HttpResponse.",
"name" : "fromPython",
"params" : [ {
"name" : "rsp",
"valueType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"private" : true,
"inline" : true,
"actionRequirementNames" : [ "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromPython",
"params" : [ {
"name" : "rsp",
"valueType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse"
},
"paramNames" : [ "rsp" ]
}
}, {
"type" : "Method",
"name" : "withBody",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "HttpResponse" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "HttpResponse"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"name" : "withBody",
"params" : [ {
"name" : "body",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BinaryType",
"name" : "binary"
}
}, {
"valueType" : {
"type" : "StringType",
"name" : "string"
}
} ]
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withBody",
"params" : [ {
"name" : "body",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BinaryType",
"name" : "binary"
}
}, {
"valueType" : {
"type" : "StringType",
"name" : "string"
}
} ]
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "body" ]
},
"$nearestImplementedOn" : "HttpResponse"
}, {
"type" : "Method",
"name" : "withSetCookie",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "HttpResponse" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "HttpResponse"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds a Set-Cookie header to the response. Note that each cookie uses a separate header so a new header is always\nadded.\n\n@param name cookie name\n@param value cookie value\n@return modified response",
"name" : "withSetCookie",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withSetCookie",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "HttpResponse",
"mixing" : true
},
"paramNames" : [ "name", "value" ]
},
"$nearestImplementedOn" : "HttpResponse"
}, {
"type" : "Method",
"name" : "writeToHttpServerResponse",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : false,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Write body, headers, status code, and reason phrase from ths HttpResponse to provided java native\nHttpServerResponse. This is not a pure function - the HttpServerResponse will be mutated.",
"name" : "writeToHttpServerResponse",
"params" : [ {
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'io.vertx.core.http.HttpServerResponse'"
} ]
} ],
"name" : "res",
"valueType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
}
} ],
"private" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "writeToHttpServerResponse",
"params" : [ {
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'io.vertx.core.http.HttpServerResponse'"
} ]
} ],
"name" : "res",
"valueType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
}
} ],
"paramNames" : [ "res" ]
}
} ],
"hasSourceCode" : {
"js-ide-vscode-client-node" : true
}
});
function allHeaders() {
return new Map(this._headers);
}
function allHeadersMerged(merger) {
if (merger == null) merger = (header, vals) => {
if ("set-cookie" == header) return null;
return vals.join(", ");
}
let merged = new Map;
for (let [header, vals] of this._headers) {
let m = merger(header, vals);
if (m != null) merged.set(header, m);
}
return merged;
}
function header(name, dflt) {
if ("set-cookie" == name?.toLowerCase()) {
throw new Error("Unsupported header Set-Cookie for WithHttpHeaders.header. Use WithHttpHeaders.headers instead.")
}
let values = this.headers(name);
if (values.length === 0) {
return dflt;
}
return values.join(", ");
}
function headers(name) {
return this._headers?.get(name?.toLowerCase()) || [];
}
function replaceHeader(name, value) {
_validateHeaderName(name);
_validateHeaderValue(value);
let _headers = new Map(this._headers);
_headers.set(name.toLowerCase(), [value]);
return this.with_headers(_headers);
}
function withHeader(name, value) {
_validateHeaderName(name);
let values = this.headers(name);
if (value != null && value !== '' && !values.includes(value)) {
values = values.concat([value]);
}
if (values.length === 0) {
return this;
}
let _headers = new Map(this._headers);
_headers.set(name.toLowerCase(), values);
return this.with_headers(_headers);
}
function withoutHeader(name) {
_validateHeaderName(name);
let _headers = new Map(this._headers);
_headers.delete(name.toLowerCase());
return this.with_headers(_headers);
}
function withHeaders(headers) {
let _headers = new Map(this._headers);
if (headers != null) {
if (!(headers instanceof Map)) {
headers = new Map(Object.entries(headers));
}
headers.forEach((vals, key) => {
_validateHeaderName(key);
let keyLowerCase = key.toLowerCase();
vals = typeof(vals) === 'string' ? [vals]: vals;
let newValues = (_headers.get(keyLowerCase) ?? []).concat(vals);
let existingValues = new Set();
newValues = newValues.filter(v => {
if (!existingValues.has(v)) {
existingValues.add(v);
return true;
}
return false;
});
if (newValues.length > 0) {
_headers.set(keyLowerCase, newValues);
}
});
}
return this.with_headers(_headers);
}
function withContentEncoding(contentEncoding) {
return !contentEncoding ? this: this.withHeader("Content-Encoding", contentEncoding);
}
function withContentType(contentType) {
return !contentType ? this: this.withHeader("Content-Type", contentType);
}
function withJsonHeaders() {
return this.withContentType('application/json').withHeader("Accept", 'application/json');
}
function withAuthHeader(auth) {
return this.withHeader("Authorization", auth);
}
function withActionEngineHeader() {
if (this?.$conn?.$actionEngine != null) {
return this.withHeader("X-C3-Action-Engine", this.$conn.$actionEngine);
}
return this;
}
function cookieValue(key) {
let values = this.headers('Set-Cookie');
for (let value of values) {
let r = /^([^=]+)="([^"]*)"(;.*)?$/.exec(value) || /^([^=]+)=([^;]*)(;.*)?$/.exec(value);
if (r && r[1] == key) {
return r[2];
}
}
}
function contentType() {
return this.header("Content-Type");
}
function contentEncoding() {
return this.header("Content-Encoding");
}
function _validateHeaderName(name) {
if (name == null || name.trim() === '') {
throw new Error(`Invalid value ${name} for http header, it must not be empty.`);
}
}
function _validateHeaderValue(value) {
if (value == null || value.trim() === '') {
throw new Error(`Invalid value ${name} for http header, it must not be empty.`);
}
}
function array(...elements) {
const b = this.arrayBuilder();
for (let e of elements) b.add(e);
return b.build();
}
function arrayBuilder() {
return ArrayType.of(this.myReferenceType()).makeBuilder();
}
function eachFieldValue(action) {
let spec;
if (arguments.length == 2) {
spec = arguments[0];
action = arguments[1];
}
this.type().meta().dataFieldTypes().forEach(ft => Val.consumeFieldValue(this, ft, this[ft.name], spec, action));
}
function eachFieldValueWhile(action) {
let spec;
if (arguments.length == 2) {
spec = arguments[0];
action = arguments[1];
}
let fieldTypes = this.type().meta().dataFieldTypes();
if (spec == null) {
for (let i = 0; i < fieldTypes.length; i++) {
let ft = fieldTypes[i];
if (this.hasOwnProperty(ft.name) && Val.isNotEmpty(this[ft.name])) {
let continue_ = action.call(undefined, ft, this[ft.name]);
if (!continue_)
return true;
}
}
} else {
throw new Error('eachFieldValueWhile with ValueSpec not implemented (yet)');
}
return false;
}
function fieldValue(field, defaultToEmpty) {
const name = typeof field === 'string' ? field : field.name;
let v = this[name];
if (v == null && defaultToEmpty) {
const ft = typeof field === 'string' ? this.type().meta().fieldType(field) : field;
if (ft != null) v = ft.defaultEmptyValue();
}
return v;
}
function fieldValueAtPath(fieldPath, failIfNotFound, _context) {
const rootObj = this;
const rootType = rootObj.type();
let parentType = rootType;
let info = FieldPath.parse(rootType, fieldPath)
.fold([rootObj, rootType.myReferenceType()],
(fp, i, isLeaf, parentInfo) => {
if (parentInfo == null) {
return null;
}
const parentFp = fp.parent();
let parentVal = parentInfo[0];
let parentVt = parentInfo[1];
if (parentVal == null) {
if (fp.valueType() == null && failIfNotFound) {
throw new Error(`Missing field "${fp.pathInRootType()}" of ${rootObj.type().name()}.`);
}
return null;
}
if (parentVt.isCollection() && !parentFp.isIndexed()) {
parentVal = parentVal.first();
parentVt = parentVt.elementType;
}
let value, vt;
if (parentVal.$c3inst != null) {
let ft = parentVal.$c3inst.meta().fieldType(fp.name());
if (ft == null) {
if (failIfNotFound) {
throw new Error(`Missing field "${fp.pathInRootType()}" of ${rootObj.type().name()}.`);
}
return null;
}
value = parentVal[fp.name()];
vt = ft.valueType();
} else {
value = parentVal;
vt = parentVt;
}
if (value == null) {
value = null;
} else if (_vtHasCollection(vt) && fp.isIndexed()) {
const index = fp.index();
if (Array.isArray(value) && typeof index === 'number') {
value = value[index];
} else if (value instanceof Set && typeof index === 'number') {
value = value.get(index);
} else if (value instanceof Map) {
value = value.get(String(index));
} else {
value = value.first(e => String(e) === index);
}
vt = vt.elementType;
}
return [value, vt];
});
return info != null ? info[0] : null;
}
function foldFieldValues(...args) {
let initial = null;
let spec;
let folder;
if (args.length >= 3) {
initial = args[0];
spec = args[1];
folder = args[2];
} else if (args.length === 2) {
initial = args[0];
folder = args[1];
} else {
folder = args[0];
}
let result = initial;
this.eachFieldValue(spec, (ft, v) => result = folder(ft, v, result));
return result;
}
function fromJson(json) {
if (json == null) {
return null;
}
let meta = this.meta();
if (typeof json === 'object') {
if (Object.getOwnPropertyNames(json).length == 0) {
return null;
}
let typeSerName = meta.typeSerName;
if (typeSerName != null && typeof json[typeSerName] === 'string') {
let t = C3.type(json[typeSerName]);
if (t != null && t.meta().isA(this)) {
meta = t.meta();
}
}
let copy = {}, renamed = false;
Object.keys(json).forEach(p => {
if (p === typeSerName) {
return;
}
let ft = meta.fieldTypeBySerName(p);
if (ft != null) {
copy[ft.name] = json[p];
renamed = true;
} else {
copy[p] = json[p];
}
});
return meta.toType().make(renamed ? copy : json);
}
if (typeof json === 'string' && meta.isA('StringSerializable')) {
return this.fromString(json);
}
throw Err.invalidValue(json, meta.name);
}
function fromJsonString(string) {
if (Str.isEmpty(string)) return;
let json;
try {
json = JSON.parse(string);
} catch (e) {
throw Err.invalidValue(string, this.name() + ' JSON string');
}
return this.fromJson(json);
}
function _vtHasCollection(vt) {
if (vt.isCollection()) {
return true;
} else if (vt.isAnyOf()) {
for (let candidate of vt.restrictions) {
if (candidate.valueType.isCollection()) return true;
}
}
return false;
}
function isEmptyObj() {
let count = 0;
if (this.type().meta().isA('Mutable')) {
let spec = ValueSpec.make({ skipTraversedRefs: true, traversedRefs: new Set(), includeEmptyRefs: true });
this.eachFieldValue(spec, (ft, v) => {
if (v != null && ft.valueType().isReference()) {
if (spec.traversedRefs.contains(v)) {
count++;
return;
}
spec.traversedRefs.add(v);
}
if (Val.isNotEmpty(v))
count++;
});
} else {
this.eachFieldValue((_ft, _v) => count++);
}
return count == 0;
}
function make(...args) {
let init;
let withDefaults = false;
if (args.length == 1 && typeof args[0] == 'boolean') {
withDefaults = args[0];
} else if (args.length > 0) {
init = args[0];
if (args.length > 1 && typeof args[1] == 'boolean') {
withDefaults = args[1];
}
}
let obj;
if (typeof init === 'string' && this.meta().isA('StringSerializable')) {
obj = this.fromString(...args);
} else {
obj = this.builder(init).build();
if (withDefaults) {
obj = obj.withDefaults();
}
}
return obj;
}
function mapFieldValues(mapper) {
let spec;
if (arguments.length == 2) {
spec = arguments[0];
mapper = arguments[1];
}
let init = {};
this.eachFieldValue(spec, (ft, v) => {
let mapped = mapper.call(undefined, ft, v);
if (mapped != null)
init[ft.name] = mapped;
});
return this.type().builder(init).build();
}
function mapFieldValuesAsync(mapper) {
let spec;
if (arguments.length == 2) {
spec = arguments[0];
mapper = arguments[1];
}
let init = {};
const allAsyncMaps = [];
this.eachFieldValue(spec, (ft, v) => {
let mapped = mapper.call(undefined, ft, v);
if (mapped != null) {
allAsyncMaps.push(mapped);
mapped.then((resolve) => {
init[ft.name] = resolve;
});
}
});
return Promise.all(allAsyncMaps).then(() => {
return this.type().builder(init).build();
});
}
function mapBuilder() {
return MapType.of(PrimitiveType.ofStr(), this.myReferenceType()).makeBuilder();
}
function mapBuilderOf(keyType) {
return MapType.of(keyType, this.myReferenceType()).makeBuilder();
}
function singletonArray() {
return ArrayType.of(this.type().myReferenceType()).makeBuilder().add(this).build();
}
function singletonSet() {
return SetType.of(this.type().myReferenceType()).makeBuilder().add(this).build();
}
function setBuilder() {
return SetType.of(this.myReferenceType()).makeBuilder();
}
function toBuilder() {
return this.type().builder(this);
}
function withDefaults(includeEmptyRefsWithDefaults, defaultFields) {
if (this.$cache.get('$withDefaults', false, () => false)) return this;
if (defaultFields != null && defaultFields.length === 0) defaultFields = null;
const fields = new Map();
let delegate = false;
this.type().meta().fieldTypes().forEach(ft => {
if (delegate) return;
if (defaultFields && !defaultFields.includes(ft.name)) return;
const oldVal = this[ft.name];
if (oldVal == null ||
!ft.valueType().preservesEmpty() && Val.isCollection(oldVal) && oldVal.isEmpty()) {
if (ft.hasDefault()) {
const c = ft.defaultValueConst();
if (c != null) {
fields.set(ft.name, c);
} else {
delegate = true;
}
} else if (!Object.hasOwnProperty.call(this, ft.name)) {
const initVal = ft.valueType().initialValue();
if (initVal != null) fields.set(ft.name, initVal);
}
} else if (Val.isObj(oldVal) &&
(!oldVal.isEmptyObj() || includeEmptyRefsWithDefaults) &&
!(oldVal instanceof WithUniqueId)) { // TODO PLAT-48170 Use WithUniqueKey
fields.set(ft.name, oldVal.withDefaults(includeEmptyRefsWithDefaults, defaultFields));
} else if (Val.isCollection(oldVal)) {
fields.set(ft.name, oldVal.withDefaults(includeEmptyRefsWithDefaults, defaultFields));
}
});
let res;
if (delegate) {
res = this.type().typeSystem().call(this.type().name(), 'withDefaults', this,
includeEmptyRefsWithDefaults, defaultFields);
} else {
res = this.withFields(fields, true);
}
res.$cache.put('$withDefaults', true);
return res;
}
function withField(field, value, doNotConvert) {
if (typeof field === 'string') {
field = this.type().meta().fieldType(field, true);
}
return this.toBuilder().v(field, value, doNotConvert).build();
}
function withFields(fields, doNotConvert) {
if (fields == null || fields.size === 0) return this;
return this.toBuilder().setFields(fields, doNotConvert).build();
}
function _toJson(ths, typed, writeTopLevelType) {
let o = {};
if (writeTopLevelType && ths.type().meta().fieldTypeBySerName('type') == null) {
o.type = ths.type().name();
}
let toJsonFuncName = typed ? "valueToTypedJson" : "valueToJson";
Object.keys(ths).forEach(p => {
let ft = ths.type().meta().fieldType(p);
if (ft == null || (ft.annotations().has('ser') && ft.annotations().ser().hidden))
return;
let v = ths[p];
if (ft.valueType().preservesEmpty() || (v != null && !ft.valueType().isEmptyValue(v))) {
o[ft.serName()] = ft.valueType()[toJsonFuncName](v);
}
});
return o;
}
function toTypedJson() {
let omitTopLevelType = arguments.length > 0 ? arguments[0] : false;
if (arguments[1] != null || arguments[2] != null) {
throw new Error('Obj.toTypedJson with include/exclude or runtime is not implemented (yet)');
}
return _toJson(this, true, !omitTopLevelType);
}
function toJson() {
if (arguments.length > 0) {
throw new Error('Obj.toJson with include/exclude not implemented (yet)');
}
return _toJson(this, false, false);
}
function super_(mixin) {
throw Err.notImplemented('WithType', 'super');
}
function body() {
if (this._body != null) {
return ContentValue.fromBinary(this._body,
this.header('Content-Type'),
this.header('Content-Encoding'));
}
}
function error() {
if (this.failed()) {
let contentType = this.header('Content-Type');
if (this.hasBody() && /^application\/json/.test(contentType)) {
try {
return C3.Error.deserialize(this.string(), contentType);
} catch (e) {
}
}
return Err.Http.httpStatus(this.statusCode, this.reasonPhrase);
}
}
function failed() {
return this.statusCode >= 400;
}
function hasBody() {
return this._body != null && this._body.byteLength > 0;
}
function json() {
let s = this.string();
if (s != null && s !== '') {
return JSON.parse(s);
}
return null;
}
function redirected() {
return this.statusCode >= 300 && this.statusCode < 400;
}
function redirectUrl() {
return this.redirected() ? this.header(HttpHeaderName.LOCATION) : null;
}
function string() {
if (this._body != null) {
const decoder = new C3.$TextDecoder();
let s = decoder.decode(this._body);
if (s !== '')
return s;
}
return null;
}
function succeeded() {
return this.statusCode >= 200 && this.statusCode < 300;
}
function withBody(b) {
if (b == null) {
return this.with_body(null);
}
if (b instanceof ArrayBuffer) {
return this.with_body(b);
}
if (ArrayBuffer.isView(b)) {
return this.with_body(b.buffer);
}
let s = String(b);
if (s == null || s === '') {
return this.with_body(null);
}
const encoder = new C3.$TextEncoder();
return this.with_body(encoder.encode(s).buffer);
}
function withSetCookie(name, value) {
let appUrlPrefix = this.request ? AppUrl.endpointPathPrefix(this.request.url) : null;
let quotes = false;
for (let i = 0; i < value.length && !quotes; i++) {
let c = value[i];
if (c < '!' || c > '~' || c == ',' || c == ';' || c == '"' || c == '\\') {
quotes = true;
}
}
if (quotes) value = Str.quote(value);
let cookie = name + '=' + value;
if (Str.isNotEmpty(appUrlPrefix)) {
cookie += "; Path=" + appUrlPrefix + ";";
}
return this.withHeader('Set-Cookie', cookie);
}
"use strict";
function $Builder(type, inst) {
let fields = {};
this.$type = type;
this.$setup = function (_inst) {};
this.$findType = function (type, _fields) { return type; };
this.$makeField = function (ft, value) { return value; };
this.$afterMake = function (inst) { return inst; };
if (inst != null) {
Object.keys(inst).forEach(fn => fields[fn] = inst[fn]);
}
Object.defineProperties(this, {
$objType: { value: type },
$onbuild: { value: undefined, writable: true },
$fields: { value: fields, configurable: true },
$refs: { value: {}, configurable: true },
$arrays: { value: {}, configurable: true },
$sets: { value: {}, configurable: true },
$maps: { value: {}, configurable: true },
$builder: { value: true },
});
}
$Builder.prototype.a = function a(field, element, doNotConvert) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isArray()) {
throw Err.invalidCall('ObjBuilder.a', `non-array field ${field.name}`);
}
let b = this.$arrays[field.name];
if (b == null) {
b = this.$fields[field.name];
if (b == null || !b.$builder) {
b = this.$arrays[field.name] = vt.makeBuilder(b);
}
}
if (arguments.length == 1) {
return b;
} else if (arguments.length == 2 || arguments.length == 3) {
b.add(element);
return this;
} else {
throw Err.invalidCall('ObjBuilder.a', 'expected field and element');
}
};
$Builder.prototype.clear = function clear() {
Object.defineProperty(this, '$fields', { value: {}, configurable: true });
Object.defineProperty(this, "$refs", { value: {}, configurable: true });
Object.defineProperty(this, "$arrays", { value: {}, configurable: true });
Object.defineProperty(this, "$sets", { value: {}, configurable: true });
Object.defineProperty(this, "$maps", { value: {}, configurable: true });
};
$Builder.prototype.constrain = function constrain() {
throw new Error('Unsupported operation ObjBuilder.constrain for JavaScript.');
};
$Builder.prototype.current = function current() {
let init = {};
Object.keys(this.$fields).forEach(p => {
let v = this.$fields[p];
if (v != null && v.$builder)
v = v.current();
init[p] = v;
});
return this.$objType.make(init);
};
$Builder.prototype.isEmpty = function isEmpty() {
return Object.keys(this.$fields).length === 0 &&
Object.keys(this.$refs).length === 0 &&
Object.keys(this.$arrays).length === 0 &&
Object.keys(this.$sets).length === 0 &&
Object.keys(this.$maps).length === 0;
};
$Builder.prototype.m = function m(field, key, element, doNotConvert) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isMap()) {
throw new Error(`Invalid call to ObjBuilder.m: non-map field ${field.name}.`);
}
let b = this.$maps[field.name];
if (b == null) {
b = this.$fields[field.name];
if (b == null || !b.$builder) {
b = this.$maps[field.name] = vt.makeBuilder(b);
}
}
if (arguments.length == 1) {
return b;
} else if (arguments.length == 3 || arguments.length == 4) {
b.put(key, element);
return this;
} else {
throw new Error(`Invalid call to ObjBuilder.m: expected field, key and value.`);
}
};
$Builder.prototype.mergeJson = function mergeJson(json) {
if (json != null) {
Object.keys(json).forEach(fn => this.v(fn, json[fn], false));
}
return this;
};
$Builder.prototype.mergeObj = function mergeObj(other, otherFieldsFilter) {
if (other == null) {
return this;
}
if (arguments.length == 1) {
if (this.objType() == other.type()) {
other.eachFieldValue((ft, v) => this.v(ft, v));
} else {
other.eachFieldValue((ft, v) => this.v(this.objType().fieldType(ft.name), v));
}
return this;
} else if (arguments.length == 2) {
if (other.instanceOf(otherFieldsFilter)) {
const tm = otherFieldsFilter.meta();
other.eachFieldValue((ft, v) => {
if (tm.fieldType(ft.name) != null)
this.v(ft, v);
});
}
return this;
}
throw new Error(`Invalid call to ObjBuilder.mergeObj: expected other and otherFieldsFilter.`);
};
$Builder.prototype.objType = function objType() {
return this.$objType;
};
$Builder.prototype.r = function r(field) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isReference()) {
throw new Error(`Invalid call to ObjBuilder.r: non-reference field ${field.name}.`);
}
let type = vt.dereference(true);
let b = this.$refs[field.name];
if (b == null) {
if (b == null || !b.$builder) {
b = this.$refs[field.name] = type.builder().mergeObj(b);
}
}
return b;
};
$Builder.prototype.s = function s(field, element, doNotConvert) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isSet()) {
throw Err.invalidCall('ObjBuilder.a', `non-array field ${field.name}`);
}
let b = this.$sets[field.name];
if (b == null) {
b = this.$fields[field.name];
if (b == null || !b.$builder) {
b = this.$sets[field.name] = vt.makeBuilder(b);
}
}
if (arguments.length == 1) {
return b;
} else if (arguments.length == 2 || arguments.length == 3) {
b.add(element);
return this;
} else {
throw Err.invalidCall('ObjBuilder.s', 'expected field and element');
}
};
$Builder.prototype.setFields = function setFields(fields, doNotConvert) {
if (fields != null) {
for (let [name, v] of fields) {
const ft = this.$objType.meta().fieldType(name, true);
if (v == null) {
delete this.$fields[ft.name];
} else {
this.$fields[ft.name] = v;
}
}
}
return this;
};
$Builder.prototype.v = function v(field, value, doNotConvert) {
if (arguments.length < 2) {
throw new Error(`Invalid call to ObjBuilder.v: expected field and value.`);
}
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
this.$fields[field.name] = value;
return this;
};
$Builder.prototype.build = function build() {
const type = this.$findType(this.$type, this.$fields);
let inst = Object.create(type.$objProto);
this.$setup(inst);
Object.keys(this.$refs).forEach(fn => {
this.$fields[fn] = this.$refs[fn].build();
});
Object.keys(this.$arrays).forEach(fn => {
this.$fields[fn] = this.$arrays[fn].build();
});
Object.keys(this.$sets).forEach(fn => {
this.$fields[fn] = this.$sets[fn].build();
});
Object.keys(this.$maps).forEach(fn => {
this.$fields[fn] = this.$maps[fn].build();
});
Object.keys(this.$fields).forEach(fn => {
let ft = type.$init.fieldTypes.find(fieldType => fieldType.name === fn && !fieldType.constant);
if (ft && inst[fn] === undefined && this.$fields[fn] != null) {
inst[fn] = this.$makeField(ft, this.$fields[fn]);
}
});
type.$init.fieldTypes.forEach(ft => {
if (!ft.constant && !_hasOwnProperty(inst, ft.name)) {
let vt = ft.valueType;
if (vt.modifier !== 'PRESERVES_EMPTY') {
let v = this.$makeField(ft, null);
if (v != null) {
inst[ft.name] = v;
}
}
}
});
inst = this.$afterMake(inst);
Object.freeze(inst);
if (this.$onbuild) {
this.$onbuild(inst);
}
return inst;
};
$Builder.prototype.type = function type() { return $type; };
$Builder.prototype.v = function v(field, value, doNotConvert) {
if (arguments.length < 2) {
throw new Error('Invalid call to ObjBuilder.v: expected field and value.');
}
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
this.$fields[field.name] = value;
return this;
};
$Builder.prototype._headers = function (v) {
if (v == null) {
delete this.$fields._headers;
} else {
this.$fields._headers = v;
}
return this;
};
$Builder.prototype.statusCode = function (v) {
if (v == null) {
delete this.$fields.statusCode;
} else {
this.$fields.statusCode = v;
}
return this;
};
$Builder.prototype.reasonPhrase = function (v) {
if (v == null) {
delete this.$fields.reasonPhrase;
} else {
this.$fields.reasonPhrase = v;
}
return this;
};
$Builder.prototype.httpVersion = function (v) {
if (v == null) {
delete this.$fields.httpVersion;
} else {
this.$fields.httpVersion = v;
}
return this;
};
$Builder.prototype.request = function (v) {
if (v == null) {
delete this.$fields.request;
} else {
this.$fields.request = v;
}
return this;
};
$Builder.prototype.elapsedMs = function (v) {
if (v == null) {
delete this.$fields.elapsedMs;
} else {
this.$fields.elapsedMs = v;
}
return this;
};
$Builder.prototype._body = function (v) {
if (v == null) {
delete this.$fields._body;
} else {
this.$fields._body = v;
}
return this;
};
let $logger;
function log() {
if ($logger == null) {
$logger = C3.Logger.for($type.name());
}
return $logger;
};
const $type = new Type$Proto($conn, $init);
const $proto = new (function HttpResponse() {});
Object.defineProperty($proto, '$conn', { value: $conn });
Object.defineProperties($type, {
$objProto: { value: $proto },
$withType: { value: true }
});
Object.defineProperty($type, Symbol.hasInstance, { value: function(inst) { return inst != null && inst.$c3inst && inst.$c3inst.meta().isA(this); } });
function header_(name, dflt) {
return Ctx.call((t, a) => header.apply(t, a), $type, 'header', this, name, dflt);
}
_impl(header_, header);
$proto.header = header_;
function redirected_() {
return Ctx.call((t, a) => redirected.apply(t, a), $type, 'redirected', this);
}
_impl(redirected_, redirected);
$proto.redirected = redirected_;
$proto.toTypedJson = toTypedJson;
function withContentEncoding_(contentEncoding) {
return Ctx.call((t, a) => withContentEncoding.apply(t, a), $type, 'withContentEncoding', this, contentEncoding);
}
_impl(withContentEncoding_, withContentEncoding);
$proto.withContentEncoding = withContentEncoding_;
$proto.toBuilder = toBuilder;
$proto.mapFieldValues = mapFieldValues;
function string_() {
return Ctx.call((t, a) => string.apply(t, a), $type, 'string', this);
}
_impl(string_, string);
$proto.string = string_;
function headers_(name) {
return Ctx.call((t, a) => headers.apply(t, a), $type, 'headers', this, name);
}
_impl(headers_, headers);
$proto.headers = headers_;
$type.fromJson = fromJson;
$type.fromJsonString = fromJsonString;
$proto.withField = withField;
function withSetCookie_(name, value) {
return Ctx.call((t, a) => withSetCookie.apply(t, a), $type, 'withSetCookie', this, name, value);
}
_impl(withSetCookie_, withSetCookie);
$proto.withSetCookie = withSetCookie_;
$proto.fieldValueAtPath = fieldValueAtPath;
$type.mapBuilderOf = mapBuilderOf;
$proto.mapFieldValuesAsync = mapFieldValuesAsync;
function error_() {
return Ctx.call((t, a) => error.apply(t, a), $type, 'error', this);
}
_impl(error_, error);
$proto.error = error_;
function withAuthHeader_(auth) {
return Ctx.call((t, a) => withAuthHeader.apply(t, a), $type, 'withAuthHeader', this, auth);
}
_impl(withAuthHeader_, withAuthHeader);
$proto.withAuthHeader = withAuthHeader_;
$proto.eachFieldValue = eachFieldValue;
function allHeadersMerged_(merger) {
return Ctx.call((t, a) => allHeadersMerged.apply(t, a), $type, 'allHeadersMerged', this, merger);
}
_impl(allHeadersMerged_, allHeadersMerged);
$proto.allHeadersMerged = allHeadersMerged_;
function withBody_(body) {
return Ctx.call((t, a) => withBody.apply(t, a), $type, 'withBody', this, body);
}
_impl(withBody_, withBody);
$proto.withBody = withBody_;
function hasBody_() {
return Ctx.call((t, a) => hasBody.apply(t, a), $type, 'hasBody', this);
}
_impl(hasBody_, hasBody);
$proto.hasBody = hasBody_;
$proto.fieldValue = fieldValue;
$type.array = array;
$proto.eachFieldValueWhile = eachFieldValueWhile;
function body_() {
return Ctx.call((t, a) => body.apply(t, a), $type, 'body', this);
}
_impl(body_, body);
$proto.body = body_;
function withHeader_(name, value) {
return Ctx.call((t, a) => withHeader.apply(t, a), $type, 'withHeader', this, name, value);
}
_impl(withHeader_, withHeader);
$proto.withHeader = withHeader_;
$proto.toJson = toJson;
$proto.singletonSet = singletonSet;
$proto.withDefaults = withDefaults;
function withHeaders_(headers) {
return Ctx.call((t, a) => withHeaders.apply(t, a), $type, 'withHeaders', this, headers);
}
_impl(withHeaders_, withHeaders);
$proto.withHeaders = withHeaders_;
$type.setBuilder = setBuilder;
function replaceHeader_(name, value) {
return Ctx.call((t, a) => replaceHeader.apply(t, a), $type, 'replaceHeader', this, name, value);
}
_impl(replaceHeader_, replaceHeader);
$proto.replaceHeader = replaceHeader_;
function json_() {
return Ctx.call((t, a) => json.apply(t, a), $type, 'json', this);
}
_impl(json_, json);
$proto.json = json_;
$proto.super = super_;
$proto.isEmptyObj = isEmptyObj;
function allHeaders_() {
return Ctx.call((t, a) => allHeaders.apply(t, a), $type, 'allHeaders', this);
}
_impl(allHeaders_, allHeaders);
$proto.allHeaders = allHeaders_;
$type.mapBuilder = mapBuilder;
$proto.foldFieldValues = foldFieldValues;
function withActionEngineHeader_() {
return Ctx.call((t, a) => withActionEngineHeader.apply(t, a), $type, 'withActionEngineHeader', this);
}
_impl(withActionEngineHeader_, withActionEngineHeader);
$proto.withActionEngineHeader = withActionEngineHeader_;
$type.arrayBuilder = arrayBuilder;
$type.make = make;
$proto.singletonArray = singletonArray;
function withJsonHeaders_() {
return Ctx.call((t, a) => withJsonHeaders.apply(t, a), $type, 'withJsonHeaders', this);
}
_impl(withJsonHeaders_, withJsonHeaders);
$proto.withJsonHeaders = withJsonHeaders_;
$proto.withFields = withFields;
function failed_() {
return Ctx.call((t, a) => failed.apply(t, a), $type, 'failed', this);
}
_impl(failed_, failed);
$proto.failed = failed_;
function redirectUrl_() {
return Ctx.call((t, a) => redirectUrl.apply(t, a), $type, 'redirectUrl', this);
}
_impl(redirectUrl_, redirectUrl);
$proto.redirectUrl = redirectUrl_;
function withoutHeader_(name) {
return Ctx.call((t, a) => withoutHeader.apply(t, a), $type, 'withoutHeader', this, name);
}
_impl(withoutHeader_, withoutHeader);
$proto.withoutHeader = withoutHeader_;
function withContentType_(contentType) {
return Ctx.call((t, a) => withContentType.apply(t, a), $type, 'withContentType', this, contentType);
}
_impl(withContentType_, withContentType);
$proto.withContentType = withContentType_;
function succeeded_() {
return Ctx.call((t, a) => succeeded.apply(t, a), $type, 'succeeded', this);
}
_impl(succeeded_, succeeded);
$proto.succeeded = succeeded_;
$type.buildArray = function buildArray(builder) {
const b = this.arrayBuilder();
builder(b);
return b.build();
};
$type.buildMap = function buildMap(builder) {
const b = this.mapBuilder();
builder(b);
return b.build();
};
$type.builder = function builder(inst) { return new $Builder(this, inst); };
Object.defineProperty($type.builder, '$std', { value: true });
$type._instantiate = function _instantiate(fields) {
return this.make(fields);
};
$type.buildSet = function buildSet(builder) {
const b = this.setBuilder();
builder(b);
return b.build();
};
$proto.type = function type() { return $type; };
$proto.log = log;
$proto.with_headers = function(v) { return this.type().builder(this)._headers(v).build(); };
$proto.without_headers = function() { return this.type().builder(this)._headers().build(); };
$proto.withStatusCode = function(v) { return this.type().builder(this).statusCode(v).build(); };
$proto.withoutStatusCode = function() { return this.type().builder(this).statusCode().build(); };
$proto.withReasonPhrase = function(v) { return this.type().builder(this).reasonPhrase(v).build(); };
$proto.withoutReasonPhrase = function() { return this.type().builder(this).reasonPhrase().build(); };
$proto.withHttpVersion = function(v) { return this.type().builder(this).httpVersion(v).build(); };
$proto.withoutHttpVersion = function() { return this.type().builder(this).httpVersion().build(); };
$proto.withRequest = function(v) { return this.type().builder(this).request(v).build(); };
$proto.withoutRequest = function() { return this.type().builder(this).request().build(); };
$proto.withElapsedMs = function(v) { return this.type().builder(this).elapsedMs(v).build(); };
$proto.withoutElapsedMs = function() { return this.type().builder(this).elapsedMs().build(); };
$proto.with_body = function(v) { return this.type().builder(this)._body(v).build(); };
$proto.without_body = function() { return this.type().builder(this)._body().build(); };
$proto.toJSON = function toJSON() { return this.toTypedJson(); };
Object.freeze($type);
Object.freeze($proto);
return $type;
})());
$conn._registerType((function() {
const $init = _deepFreeze({
"type" : "TypeMeta",
"metadataPath" : "platform/src/remote/TypeSystem.c3typ",
"package" : "platform",
"packageSubPath" : "remote",
"name" : "TypeSystem",
"doc" : "Type for the remote full type system, synchronous version.\n\nThe \"full\" type system is distinguished from the {@link ThinTypeSystem thin type system} by the fact that\nvalues have the full C3 semantics and Obj instances expose the declared methods directly.\n\n@see Remote",
"declaredInline" : true,
"declaredMixinRefTypes" : [ {
"name" : "TypeSystemBase"
}, {
"name" : "Value"
} ],
"declaredFieldTypes" : [ {
"annotationsJson" : [ {
"call" : [ {
"name" : "stayInEngine",
"value" : true
} ]
} ],
"doc" : "Get a full type by name. Note that this can be a top-level type or an inner type with the path fully specified to\nthe top-level type. The value will be cached between calls for the same instance of the type system.",
"name" : "type",
"valueType" : {
"type" : "InheritedValueType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Type"
},
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Call a named method on the specified type, with the arguments represented as json values. Return value will be a\ntyped json representation of a result of the call.",
"name" : "callJson",
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "methodName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "thisArg",
"valueType" : {
"type" : "JsonType",
"name" : "json"
}
}, {
"name" : "args",
"valueType" : {
"type" : "JsonType",
"name" : "json"
}
}, {
"name" : "kwargs",
"valueType" : {
"type" : "JsonType",
"name" : "json"
}
} ],
"returnType" : {
"type" : "JsonType",
"name" : "json",
"typed" : true
},
"member" : true,
"actionRequirementNames" : [ "java" ]
}
}, {
"doc" : "Call a named method on the specified type, with the arguments specified positionally (as varargs). For member\nmethod calls the \"this\" instance should be the first argument and for static method calls, the first argument\nshould be the type.",
"name" : "call",
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "methodName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "args",
"valueType" : {
"type" : "AnyType"
},
"varArgs" : true
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Invokes lambda action remotely.",
"name" : "call",
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Return the names of all the types declared in the connection's application.\n\n@param includeInnerTypes return inner type names in addition to top-level type names",
"name" : "typeNames",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "includeInnerTypes",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Import types in the provided scope. This publishes all top-level types into the specified scope variable for\neasy script access. Note that types that conflict with existing members are _not_ published, which allows this\nto be used without masking access to system values (such as `window` in the browser).\n\nIn addition to handles to all the types, this also installs the `type()` method of this (synchronous) type system\nonto the variable which makes it easier to load types by name.\n\n```js\nC3.connect().typeSystem().importTypes(C3)\nvar U = C3.type('User')\nU == C3.User; // TRUE\nvar UR = C3.connect(<another env connect info>).typeSystem().type('User')\nU != UR; // TRUE\n```\n\n@param scope to import types into\n@return a map of imported types",
"name" : "importTypes",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "scope",
"valueType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "Type"
}
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Clears the effect of `importTypes`:\n- Removes the type definitions on the `scope` object passed into `importTypes`.\n- Removes the type definitions on the `C3` object on the `scope` object passed into `importTypes`\n- Removes the functions defined on the `C3` object on the `scope` object passed into `importTypes`",
"name" : "clearImports",
"private" : true,
"valueType" : {
"type" : "MethodType",
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
} ],
"isWithType" : false,
"isObj" : false,
"isMutable" : false,
"isStateful" : false,
"isSingleton" : false,
"isDefaultInstance" : false,
"isAbstract" : false,
"hasEventStream" : false,
"isGeneric" : false,
"isNativeRemix" : false,
"hasVarBindings" : false,
"prototypeName" : "TypeSystem",
"typeSerName" : "type",
"hasSerNameFields" : false,
"annotations" : {
"type" : "Annotations"
},
"mixins" : [ "TypeSystemBase", "Value" ],
"referenceType" : {
"type" : "ReferenceType",
"name" : "TypeSystem"
},
"mixinsWithSourceCode" : {
"js-ide-vscode-client-node" : [ "TypeSystemBase" ]
},
"methods" : [ {
"type" : "Method",
"name" : "type",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeSystem" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeSystem"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"call" : [ {
"name" : "stayInEngine",
"value" : true
} ]
} ],
"doc" : "Get a full type by name. Note that this can be a top-level type or an inner type with the path fully specified to\nthe top-level type. The value will be cached between calls for the same instance of the type system.",
"name" : "type",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"call" : [ {
"name" : "stayInEngine",
"value" : true
} ]
} ],
"name" : "type",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"paramNames" : [ "name", "failIfMissing" ]
},
"$nearestImplementedOn" : "TypeSystem"
}, {
"type" : "Method",
"name" : "sync",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeSystem"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeSystemBase" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeSystemBase"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get a synchronous instance of the full type system for this connection. If this instance is a synchronous version,\nthe same value is returned.\n\n@return instance of this type system that dispatches actions in a synchronous manner",
"name" : "sync",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeSystem"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "sync",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeSystem"
}
},
"$nearestImplementedOn" : "TypeSystemBase"
}, {
"type" : "Method",
"name" : "async",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "AsyncTypeSystem"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeSystemBase" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeSystemBase"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get an asynchronous instance of the full type system for this connection. If this instance is an asynchronous\nversion, the same value is returned.\n\n@return instance of this type system that dispatches actions in an asynchronous manner using Promise",
"name" : "async",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "AsyncTypeSystem"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "async",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "AsyncTypeSystem"
}
},
"$nearestImplementedOn" : "TypeSystemBase"
}, {
"type" : "Method",
"name" : "connection",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerConnection"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeSystemBase" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeSystemBase"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"call" : [ {
"name" : "stayInEngine",
"value" : {
"py" : "true"
}
} ]
} ],
"doc" : "Get the connection on which this type system operates.\n\n@return server connection",
"name" : "connection",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerConnection"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"call" : [ {
"name" : "stayInEngine",
"value" : {
"py" : "true"
}
} ]
} ],
"name" : "connection",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerConnection"
}
},
"$nearestImplementedOn" : "TypeSystemBase"
}, {
"type" : "Method",
"name" : "clearCache",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeSystemBase" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeSystemBase"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"call" : [ {
"name" : "stayInEngine",
"value" : true
} ]
} ],
"doc" : "When no argument is provided, discard all cached metadata on this connection. When a typename is specified,\nremove cached metadata for the given type, and all sub types that mixes this type. This is typically used in\nclient SDKs to refresh cache for updated types. Note that existing instances will still continue to use the old\ntypes, but references to types through this type system itself will reload after this call.\n\n@param typeName specific type to clear or null for all\n@param reimport if true, re-import single type if `importTypes` was called",
"name" : "clearCache",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"name" : "reimport",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"call" : [ {
"name" : "stayInEngine",
"value" : true
} ]
} ],
"name" : "clearCache",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"name" : "reimport",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"paramNames" : [ "typeName", "reimport" ]
},
"$nearestImplementedOn" : "TypeSystemBase"
}, {
"type" : "Method",
"name" : "cacheContainsType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeSystemBase" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeSystemBase"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "True if the type with the given typeName is cached in TypeSystem.",
"name" : "cacheContainsType",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "cacheContainsType",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "typeName" ]
},
"$nearestImplementedOn" : "TypeSystemBase"
}, {
"type" : "Method",
"name" : "c3",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeSystemBase" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeSystemBase"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns a native c3 \"namespace object\". In general, this object has a field for each {@link Type} declared in\na given package. This object also has all fields and methods of any {@link GlobalProtocol} sub-type. In Python,\nthis method returns an object of the same type as the \"c3\" global variable. In JS, this method returns an object of\nthe same type as the \"C3\" variable.",
"name" : "c3",
"returnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"cached" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "py", "js", "java" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "c3",
"returnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
}
},
"$nearestImplementedOn" : "TypeSystemBase"
}, {
"type" : "Method",
"name" : "trackTypeChanges",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeSystemBase" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeSystemBase"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Listens for changes occurring on the server and updates the local state as necessary. This is useful on development\nsystems (apps in `DEV` mode) where types are being actively developed.\n\n@param notify lambda called each time a type change is detected\n\n@see Pkg#listen",
"name" : "trackTypeChanges",
"params" : [ {
"name" : "notify",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "e",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg.Event"
}
} ]
}
} ],
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "js-client" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "trackTypeChanges",
"params" : [ {
"name" : "notify",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "e",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg.Event"
}
} ]
}
} ],
"paramNames" : [ "notify" ]
},
"$nearestImplementedOn" : "TypeSystemBase"
}, {
"type" : "Method",
"name" : "callRequest",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeSystemBase" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeSystemBase"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Build a request instance usable for calling the specified method. The type and method name are required to form\nthe URL. The HTTP method will always be `POST`.\n\nIf any arguments are specified, the body of the request will be JSON and it will have the JSON-related\nheaders, including `Accept: application/json`. Otherwise, the request will have no body and `Accept: *\\/*`.\n\n@param type the name of the type on which to call the method\n@param action the name of the method to call\n@param args the arguments to pass, with `this` or the type name first\n@return the HTTP request to make this call",
"name" : "callRequest",
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "action",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "args",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "callRequest",
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "action",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "args",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest"
},
"paramNames" : [ "type", "action", "args" ]
},
"$nearestImplementedOn" : "TypeSystemBase"
}, {
"type" : "Method",
"name" : "callJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "JsonType",
"name" : "json",
"typed" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Call a named method on the specified type, with the arguments represented as json values. Return value will be a\ntyped json representation of a result of the call.",
"name" : "callJson",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "methodName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "thisArg",
"valueType" : {
"type" : "JsonType",
"name" : "json"
}
}, {
"name" : "args",
"valueType" : {
"type" : "JsonType",
"name" : "json"
}
}, {
"name" : "kwargs",
"valueType" : {
"type" : "JsonType",
"name" : "json"
}
} ],
"returnType" : {
"type" : "JsonType",
"name" : "json",
"typed" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "callJson",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "methodName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "thisArg",
"valueType" : {
"type" : "JsonType",
"name" : "json"
}
}, {
"name" : "args",
"valueType" : {
"type" : "JsonType",
"name" : "json"
}
}, {
"name" : "kwargs",
"valueType" : {
"type" : "JsonType",
"name" : "json"
}
} ],
"returnType" : {
"type" : "JsonType",
"name" : "json",
"typed" : true
},
"paramNames" : [ "typeName", "methodName", "thisArg", "args", "kwargs" ]
}
}, {
"type" : "Method",
"name" : "call",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeSystem" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeSystem"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Call a named method on the specified type, with the arguments specified positionally (as varargs). For member\nmethod calls the \"this\" instance should be the first argument and for static method calls, the first argument\nshould be the type.",
"name" : "call",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "methodName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "args",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Invokes lambda action remotely.",
"name" : "call",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "call",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "typeNameOrAction",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ]
}
}, {
"name" : "methodName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "args",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "typeNameOrAction", "methodName", "args" ]
},
"$nearestImplementedOn" : "TypeSystem"
}, {
"type" : "Method",
"name" : "typeNames",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeSystem" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeSystem"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return the names of all the types declared in the connection's application.\n\n@param includeInnerTypes return inner type names in addition to top-level type names",
"name" : "typeNames",
"params" : [ {
"name" : "includeInnerTypes",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "typeNames",
"params" : [ {
"name" : "includeInnerTypes",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"paramNames" : [ "includeInnerTypes" ]
},
"$nearestImplementedOn" : "TypeSystem"
}, {
"type" : "Method",
"name" : "importTypes",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeSystem" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeSystem"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Import types in the provided scope. This publishes all top-level types into the specified scope variable for\neasy script access. Note that types that conflict with existing members are _not_ published, which allows this\nto be used without masking access to system values (such as `window` in the browser).\n\nIn addition to handles to all the types, this also installs the `type()` method of this (synchronous) type system\nonto the variable which makes it easier to load types by name.\n\n```js\nC3.connect().typeSystem().importTypes(C3)\nvar U = C3.type('User')\nU == C3.User; // TRUE\nvar UR = C3.connect(<another env connect info>).typeSystem().type('User')\nU != UR; // TRUE\n```\n\n@param scope to import types into\n@return a map of imported types",
"name" : "importTypes",
"params" : [ {
"name" : "scope",
"valueType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "importTypes",
"params" : [ {
"name" : "scope",
"valueType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"paramNames" : [ "scope" ]
},
"$nearestImplementedOn" : "TypeSystem"
}, {
"type" : "Method",
"name" : "clearImports",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeSystem" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeSystem"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Clears the effect of `importTypes`:\n- Removes the type definitions on the `scope` object passed into `importTypes`.\n- Removes the type definitions on the `C3` object on the `scope` object passed into `importTypes`\n- Removes the functions defined on the `C3` object on the `scope` object passed into `importTypes`",
"name" : "clearImports",
"private" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "clearImports"
},
"$nearestImplementedOn" : "TypeSystem"
} ],
"hasSourceCode" : {
"js-ide-vscode-client-node" : true
},
"fieldTypes" : [ ]
});
var $protos = {};
class ArrayBase extends Array {
constructor(vt) {
super(typeof vt === 'number' ? vt : 0);
if (new.target == ArrayBase) {
throw new TypeError('Cannot construct ArrayBase class directly.');
}
if (vt == null || typeof vt == 'number') {
vt = ArrayType.ofAny();
}
let box = { type: vt };
Object.defineProperty(this, '$private', { value: box });
}
collectionType() {
let vt = this.$private.type;
if (typeof vt.type === 'string') {
vt = ArrayType.make(vt);
this.$private.type = vt;
}
return vt;
}
contains(e) {
return super.indexOf(e) >= 0;
}
elementType() {
return this.collectionType().elementType;
}
first(arg) {
if (typeof arg === 'number' && arg > 1) {
let vt = this.collectionType();
return _make(vt.type().$conn, super.slice(0, arg), vt, false);
} else if (typeof arg === 'function') {
return this.find(arg);
} else {
return this[0];
}
}
isEmpty() {
return this.length === 0;
}
get size() {
return this.length;
}
toJSON() {
return this.toJson();
}
_toJson(typed, omitTopLevelType) {
let toJsonFunc = typed ? 'valueToTypedJson' : 'valueToJson';
let vt = this.collectionType();
let et = vt.elementType;
let a = [];
this.forEach(e => a.push(et[toJsonFunc](e)));
return typed && !omitTopLevelType ? { type: this.type().toString(), value: a } : a;
}
toJson() {
return this._toJson(false);
}
toTypedJson(omitTopLevelType) {
return this._toJson(true, omitTopLevelType);
}
fromJson(json) {
_make(this.type().$conn, json, this.collectionType(), false);
}
type() {
return this.$cache.get('type', true, () => C3.Array.bindVar(this.elementType()));
}
*_iter() {
for (let e of this) {
yield e;
}
}
_build(...args) {
if (args.length == 1) {
return this.collectionType().buildArray(args[0]);
} else {
return ArrayType.of(args[0]).buildArray(args[1]);
}
}
_singleton(e) {
return this.collectionType().buildArray(b => b.add(e));
}
approxUniqueCount() {
return C3.Array.$objProto.approxUniqueCount.call(this);
}
approxMedian(...args) {
return C3.Array.$objProto.approxMedian.call(this, ...args);
}
approxHistogram(...args) {
return C3.Array.$objProto.approxHistogram.call(this, ...args);
}
truePercent() {
return C3.Array.$objProto.truePercent.call(this);
}
nullCount() {
return C3.Array.$objProto.nullCount.call(this);
}
toJsonString() {
return C3.Array.$objProto.toJsonString.call(this);
}
toTypedJsonString() {
return C3.Array.$objProto.toTypedJsonString.call(this);
}
toJsString() {
return C3.Array.$objProto.toJsString.call(this);
}
toXmlString() {
return C3.Array.$objProto.toXmlString.call(this);
}
serialize(...args) {
return C3.Array.$objProto.serialize.call(this, ...args);
}
toString(...args) {
return C3.Array.$objProto.toString.call(this, ...args);
}
fingerprint(...args) {
return C3.Array.$objProto.fingerprint.call(this, ...args);
}
retainedMemory(...args) {
return C3.Array.$objProto.retainedMemory.call(this, ...args);
}
elementAgg(...args) {
return C3.Array.$objProto.elementAgg.call(this, ...args);
}
elementAll(...args) {
return C3.Array.$objProto.elementAll.call(this, ...args);
}
elementAvg(...args) {
return C3.Array.$objProto.elementAvg.call(this, ...args);
}
elementCartesianProduct() {
return C3.Array.$objProto.elementCartesianProduct.call(this);
}
elementMin(...args) {
return C3.Array.$objProto.elementMin.call(this, ...args);
}
elementMax(...args) {
return C3.Array.$objProto.elementMax.call(this, ...args);
}
elementSum(...args) {
return C3.Array.$objProto.elementSum.call(this, ...args);
}
elementStddev(...args) {
return C3.Array.$objProto.elementStddev.call(this, ...args);
}
elementVariance(...args) {
return C3.Array.$objProto.elementVariance.call(this, ...args);
}
iter() {
return C3.Array.$objProto.iter.call(this);
}
_iter_() {
return C3.Array.$objProto._iter_.call(this);
}
_length_() {
return C3.Array.$objProto._length_.call(this);
}
collect(...args) {
return C3.Array.$objProto.collect.call(this, ...args);
}
collectArrays(...args) {
return C3.Array.$objProto.collectArrays.call(this, ...args);
}
abs() {
return C3.Array.$objProto.abs.call(this);
}
aggImplementation(...args) {
return C3.Array.$objProto.aggImplementation.call(this, ...args);
}
sumDbl() {
return C3.Array.$objProto.sumDbl.call(this);
}
sumDiff(...args) {
return C3.Array.$objProto.sumDiff.call(this, ...args);
}
cusum(...args) {
return C3.Array.$objProto.cusum.call(this, ...args);
}
normalize() {
return C3.Array.$objProto.normalize.call(this);
}
at(...args) {
return C3.Array.$objProto.at.call(this, ...args);
}
pluck(...args) {
return C3.Array.$objProto.pluck.call(this, ...args);
}
firstNotNull(...args) {
return C3.Array.$objProto.firstNotNull.call(this, ...args);
}
firstNotEmpty(...args) {
return C3.Array.$objProto.firstNotEmpty.call(this, ...args);
}
last(...args) {
return C3.Array.$objProto.last.call(this, ...args);
}
lastNotNull(...args) {
return C3.Array.$objProto.lastNotNull.call(this, ...args);
}
lastNotEmpty(...args) {
return C3.Array.$objProto.lastNotEmpty.call(this, ...args);
}
minImplementation(...args) {
return C3.Array.$objProto.minImplementation.call(this, ...args);
}
minBy(...args) {
return C3.Array.$objProto.minBy.call(this, ...args);
}
maxImplementation(...args) {
return C3.Array.$objProto.maxImplementation.call(this, ...args);
}
maxBy(...args) {
return C3.Array.$objProto.maxBy.call(this, ...args);
}
count(...args) {
return C3.Array.$objProto.count.call(this, ...args);
}
sumImplementation(...args) {
return C3.Array.$objProto.sumImplementation.call(this, ...args);
}
allImplementation(...args) {
return C3.Array.$objProto.allImplementation.call(this, ...args);
}
prod(...args) {
return C3.Array.$objProto.prod.call(this, ...args);
}
avg() {
return C3.Array.$objProto.avg.call(this);
}
avgDbl() {
return C3.Array.$objProto.avgDbl.call(this);
}
median() {
return C3.Array.$objProto.median.call(this);
}
medianDbl() {
return C3.Array.$objProto.medianDbl.call(this);
}
percentile(...args) {
return C3.Array.$objProto.percentile.call(this, ...args);
}
percentileDbl(...args) {
return C3.Array.$objProto.percentileDbl.call(this, ...args);
}
stddev() {
return C3.Array.$objProto.stddev.call(this);
}
stddevDbl() {
return C3.Array.$objProto.stddevDbl.call(this);
}
variance() {
return C3.Array.$objProto.variance.call(this);
}
varianceDbl() {
return C3.Array.$objProto.varianceDbl.call(this);
}
aggDbl(...args) {
return C3.Array.$objProto.aggDbl.call(this, ...args);
}
round(...args) {
return C3.Array.$objProto.round.call(this, ...args);
}
invert() {
return C3.Array.$objProto.invert.call(this);
}
isMissing() {
return C3.Array.$objProto.isMissing.call(this);
}
only(...args) {
return C3.Array.$objProto.only.call(this, ...args);
}
containsAll(...args) {
return C3.Array.$objProto.containsAll.call(this, ...args);
}
containsAny(...args) {
return C3.Array.$objProto.containsAny.call(this, ...args);
}
findAny(...args) {
return C3.Array.$objProto.findAny.call(this, ...args);
}
anyNotNull(...args) {
return C3.Array.$objProto.anyNotNull.call(this, ...args);
}
anyNotEmpty(...args) {
return C3.Array.$objProto.anyNotEmpty.call(this, ...args);
}
each(...args) {
C3.Array.$objProto.each.call(this, ...args);
}
eachWhile(...args) {
return C3.Array.$objProto.eachWhile.call(this, ...args);
}
mapToSame(...args) {
return C3.Array.$objProto.mapToSame.call(this, ...args);
}
map(...args) {
return C3.Array.$objProto.map.call(this, ...args);
}
mapToStr(...args) {
return C3.Array.$objProto.mapToStr.call(this, ...args);
}
mapTo(...args) {
return C3.Array.$objProto.mapTo.call(this, ...args);
}
flatMapToSame(...args) {
return C3.Array.$objProto.flatMapToSame.call(this, ...args);
}
flatMap(...args) {
return C3.Array.$objProto.flatMap.call(this, ...args);
}
flatMapTo(...args) {
return C3.Array.$objProto.flatMapTo.call(this, ...args);
}
flatMapRecursive(...args) {
return C3.Array.$objProto.flatMapRecursive.call(this, ...args);
}
fold(...args) {
return C3.Array.$objProto.fold.call(this, ...args);
}
compact() {
return C3.Array.$objProto.compact.call(this);
}
unique() {
return C3.Array.$objProto.unique.call(this);
}
uniqueBy(...args) {
return C3.Array.$objProto.uniqueBy.call(this, ...args);
}
fillMissingBy(...args) {
return C3.Array.$objProto.fillMissingBy.call(this, ...args);
}
fillMissing(...args) {
return C3.Array.$objProto.fillMissing.call(this, ...args);
}
fieldNames() {
return C3.Array.$objProto.fieldNames.call(this);
}
fieldValueType(...args) {
return C3.Array.$objProto.fieldValueType.call(this, ...args);
}
reject(...args) {
return C3.Array.$objProto.reject.call(this, ...args);
}
include(...args) {
return C3.Array.$objProto.include.call(this, ...args);
}
fieldSlice(...args) {
return C3.Array.$objProto.fieldSlice.call(this, ...args);
}
fieldSelect(...args) {
return C3.Array.$objProto.fieldSelect.call(this, ...args);
}
exclude(...args) {
return C3.Array.$objProto.exclude.call(this, ...args);
}
replaceByPredicate(...args) {
return C3.Array.$objProto.replaceByPredicate.call(this, ...args);
}
sorted(...args) {
return C3.Array.$objProto.sorted.call(this, ...args);
}
sortedBy(...args) {
return C3.Array.$objProto.sortedBy.call(this, ...args);
}
sortedIndex(...args) {
return C3.Array.$objProto.sortedIndex.call(this, ...args);
}
batch(...args) {
return C3.Array.$objProto.batch.call(this, ...args);
}
partition(...args) {
return C3.Array.$objProto.partition.call(this, ...args);
}
countBy(...args) {
return C3.Array.$objProto.countBy.call(this, ...args);
}
every(...args) {
return C3.Array.$objProto.every.call(this, ...args);
}
flatten(...args) {
return C3.Array.$objProto.flatten.call(this, ...args);
}
sample(...args) {
return C3.Array.$objProto.sample.call(this, ...args);
}
sliceByKey(...args) {
return C3.Array.$objProto.sliceByKey.call(this, ...args);
}
summarize(...args) {
return C3.Array.$objProto.summarize.call(this, ...args);
}
downsample(...args) {
return C3.Array.$objProto.downsample.call(this, ...args);
}
leastSquares() {
return C3.Array.$objProto.leastSquares.call(this);
}
rollingDiff(...args) {
return C3.Array.$objProto.rollingDiff.call(this, ...args);
}
pctChange(...args) {
return C3.Array.$objProto.pctChange.call(this, ...args);
}
binaryOp(...args) {
return C3.Array.$objProto.binaryOp.call(this, ...args);
}
unaryOp(...args) {
return C3.Array.$objProto.unaryOp.call(this, ...args);
}
shape() {
return C3.Array.$objProto.shape.call(this);
}
dimensionality() {
return C3.Array.$objProto.dimensionality.call(this);
}
toObj() {
return C3.Array.$objProto.toObj.call(this);
}
fetch(...args) {
return C3.Array.$objProto.fetch.call(this, ...args);
}
largest(...args) {
return C3.Array.$objProto.largest.call(this, ...args);
}
histogram(...args) {
return C3.Array.$objProto.histogram.call(this, ...args);
}
neg() {
return C3.Array.$objProto.neg.call(this);
}
describeImplementation(...args) {
return C3.Array.$objProto.describeImplementation.call(this, ...args);
}
and(...args) {
return C3.Array.$objProto.and.call(this, ...args);
}
approxMostFrequent(...args) {
return C3.Array.$objProto.approxMostFrequent.call(this, ...args);
}
or(...args) {
return C3.Array.$objProto.or.call(this, ...args);
}
timeseries(...args) {
return C3.Array.$objProto.timeseries.call(this, ...args);
}
stream() {
return C3.Array.$objProto.stream.call(this);
}
sub(...args) {
return C3.Array.$objProto.sub.call(this, ...args);
}
mul(...args) {
return C3.Array.$objProto.mul.call(this, ...args);
}
div(...args) {
return C3.Array.$objProto.div.call(this, ...args);
}
truediv(...args) {
return C3.Array.$objProto.truediv.call(this, ...args);
}
floordiv(...args) {
return C3.Array.$objProto.floordiv.call(this, ...args);
}
mod(...args) {
return C3.Array.$objProto.mod.call(this, ...args);
}
pow(...args) {
return C3.Array.$objProto.pow.call(this, ...args);
}
radd(...args) {
return C3.Array.$objProto.radd.call(this, ...args);
}
rsub(...args) {
return C3.Array.$objProto.rsub.call(this, ...args);
}
rmul(...args) {
return C3.Array.$objProto.rmul.call(this, ...args);
}
rdiv(...args) {
return C3.Array.$objProto.rdiv.call(this, ...args);
}
rtruediv(...args) {
return C3.Array.$objProto.rtruediv.call(this, ...args);
}
rfloordiv(...args) {
return C3.Array.$objProto.rfloordiv.call(this, ...args);
}
rmod(...args) {
return C3.Array.$objProto.rmod.call(this, ...args);
}
rpow(...args) {
return C3.Array.$objProto.rpow.call(this, ...args);
}
eq(...args) {
return C3.Array.$objProto.eq.call(this, ...args);
}
gt(...args) {
return C3.Array.$objProto.gt.call(this, ...args);
}
ge(...args) {
return C3.Array.$objProto.ge.call(this, ...args);
}
lt(...args) {
return C3.Array.$objProto.lt.call(this, ...args);
}
le(...args) {
return C3.Array.$objProto.le.call(this, ...args);
}
ne(...args) {
return C3.Array.$objProto.ne.call(this, ...args);
}
replaceType(...args) {
return C3.Array.$objProto.replaceType.call(this, ...args);
}
super(...args) {
return C3.Array.$objProto.super.call(this, ...args);
}
zip(...args) {
return C3.Array.$objProto.zip.call(this, ...args);
}
valueType() {
return C3.Array.$objProto.valueType.call(this);
}
toNative(...args) {
return C3.Array.$objProto.toNative.call(this, ...args);
}
validated() {
return C3.Array.$objProto.validated.call(this);
}
inferType() {
return C3.Array.$objProto.inferType.call(this);
}
hasNullElements() {
return C3.Array.$objProto.hasNullElements.call(this);
}
isSame(...args) {
return C3.Array.$objProto.isSame.call(this, ...args);
}
hasSameElements(...args) {
return C3.Array.$objProto.hasSameElements.call(this, ...args);
}
isUnique() {
return C3.Array.$objProto.isUnique.call(this);
}
isSorted() {
return C3.Array.$objProto.isSorted.call(this);
}
isIndexed() {
return C3.Array.$objProto.isIndexed.call(this);
}
indices() {
return C3.Array.$objProto.indices.call(this);
}
indexOf(...args) {
return C3.Array.$objProto.indexOf.call(this, ...args);
}
indexOfAny(...args) {
return C3.Array.$objProto.indexOfAny.call(this, ...args);
}
lastIndexOf(...args) {
return C3.Array.$objProto.lastIndexOf.call(this, ...args);
}
lastIndexOfAny(...args) {
return C3.Array.$objProto.lastIndexOfAny.call(this, ...args);
}
min(...args) {
return C3.Array.$objProto.min.call(this, ...args);
}
max(...args) {
return C3.Array.$objProto.max.call(this, ...args);
}
sum(...args) {
return C3.Array.$objProto.sum.call(this, ...args);
}
all(...args) {
return C3.Array.$objProto.all.call(this, ...args);
}
agg(...args) {
return C3.Array.$objProto.agg.call(this, ...args);
}
toArray(...args) {
return C3.Array.$objProto.toArray.call(this, ...args);
}
toSet(...args) {
return C3.Array.$objProto.toSet.call(this, ...args);
}
toStream(...args) {
return C3.Array.$objProto.toStream.call(this, ...args);
}
toMap(...args) {
return C3.Array.$objProto.toMap.call(this, ...args);
}
toMapOf(...args) {
return C3.Array.$objProto.toMapOf.call(this, ...args);
}
toMapOfAny(...args) {
return C3.Array.$objProto.toMapOfAny.call(this, ...args);
}
toMapOfType(...args) {
return C3.Array.$objProto.toMapOfType.call(this, ...args);
}
toCollection(...args) {
return C3.Array.$objProto.toCollection.call(this, ...args);
}
toMixingCollection(...args) {
return C3.Array.$objProto.toMixingCollection.call(this, ...args);
}
toCollectionOfType(...args) {
return C3.Array.$objProto.toCollectionOfType.call(this, ...args);
}
toInMemory() {
return C3.Array.$objProto.toInMemory.call(this);
}
box() {
return C3.Array.$objProto.box.call(this);
}
boxElements() {
return C3.Array.$objProto.boxElements.call(this);
}
anonymize(...args) {
return C3.Array.$objProto.anonymize.call(this, ...args);
}
descriptiveStatistics() {
return C3.Array.$objProto.descriptiveStatistics.call(this);
}
withoutOutliers(...args) {
return C3.Array.$objProto.withoutOutliers.call(this, ...args);
}
extractOutliers(...args) {
return C3.Array.$objProto.extractOutliers.call(this, ...args);
}
isOutlier(...args) {
return C3.Array.$objProto.isOutlier.call(this, ...args);
}
with(...args) {
return C3.Array.$objProto.with.call(this, ...args);
}
withSome(...args) {
return C3.Array.$objProto.withSome.call(this, ...args);
}
withAll(...args) {
return C3.Array.$objProto.withAll.call(this, ...args);
}
without(...args) {
return C3.Array.$objProto.without.call(this, ...args);
}
withoutSome(...args) {
return C3.Array.$objProto.withoutSome.call(this, ...args);
}
withoutAny(...args) {
return C3.Array.$objProto.withoutAny.call(this, ...args);
}
withoutAll(...args) {
return C3.Array.$objProto.withoutAll.call(this, ...args);
}
difference(...args) {
return C3.Array.$objProto.difference.call(this, ...args);
}
unzip() {
return C3.Array.$objProto.unzip.call(this);
}
mergeSimilar(...args) {
return C3.Array.$objProto.mergeSimilar.call(this, ...args);
}
mergeChildren(...args) {
return C3.Array.$objProto.mergeChildren.call(this, ...args);
}
visit(...args) {
return C3.Array.$objProto.visit.call(this, ...args);
}
withDefaults(...args) {
return C3.Array.$objProto.withDefaults.call(this, ...args);
}
evalTimeseries(...args) {
return C3.Array.$objProto.evalTimeseries.call(this, ...args);
}
groupBy(...args) {
return C3.Array.$objProto.groupBy.call(this, ...args);
}
resample(...args) {
return C3.Array.$objProto.resample.call(this, ...args);
}
rolling(...args) {
return C3.Array.$objProto.rolling.call(this, ...args);
}
_item_(...args) {
return C3.Array.$objProto._item_.call(this, ...args);
}
toData() {
return C3.Array.$objProto.toData.call(this);
}
replace(...args) {
return C3.Array.$objProto.replace.call(this, ...args);
}
initial(...args) {
return C3.Array.$objProto.initial.call(this, ...args);
}
pairs() {
return C3.Array.$objProto.pairs.call(this);
}
isCompressed() {
return C3.Array.$objProto.isCompressed.call(this);
}
compress() {
return C3.Array.$objProto.compress.call(this);
}
uncompress() {
return C3.Array.$objProto.uncompress.call(this);
}
isPacked() {
return C3.Array.$objProto.isPacked.call(this);
}
pack() {
return C3.Array.$objProto.pack.call(this);
}
unpack() {
return C3.Array.$objProto.unpack.call(this);
}
reversed() {
return C3.Array.$objProto.reversed.call(this);
}
withIfMissing(...args) {
return C3.Array.$objProto.withIfMissing.call(this, ...args);
}
get(...args) {
return C3.Array.$objProto.get.call(this, ...args);
}
insertAt(...args) {
return C3.Array.$objProto.insertAt.call(this, ...args);
}
removeAt(...args) {
return C3.Array.$objProto.removeAt.call(this, ...args);
}
shuffle() {
return C3.Array.$objProto.shuffle.call(this);
}
permute() {
return C3.Array.$objProto.permute.call(this);
}
toBuilder() {
return C3.Array.$objProto.toBuilder.call(this);
}
withFirst(...args) {
return C3.Array.$objProto.withFirst.call(this, ...args);
}
withoutFirst() {
return C3.Array.$objProto.withoutFirst.call(this);
}
withoutLast() {
return C3.Array.$objProto.withoutLast.call(this);
}
withFill(...args) {
return C3.Array.$objProto.withFill.call(this, ...args);
}
withSplice(...args) {
return C3.Array.$objProto.withSplice.call(this, ...args);
}
boolArray() {
return C3.Array.$objProto.boolArray.call(this);
}
doubleArray() {
return C3.Array.$objProto.doubleArray.call(this);
}
floatArray() {
return C3.Array.$objProto.floatArray.call(this);
}
intArray() {
return C3.Array.$objProto.intArray.call(this);
}
int16Array() {
return C3.Array.$objProto.int16Array.call(this);
}
int32Array() {
return C3.Array.$objProto.int32Array.call(this);
}
byteArray() {
return C3.Array.$objProto.byteArray.call(this);
}
boolAt(...args) {
return C3.Array.$objProto.boolAt.call(this, ...args);
}
doubleAt(...args) {
return C3.Array.$objProto.doubleAt.call(this, ...args);
}
floatAt(...args) {
return C3.Array.$objProto.floatAt.call(this, ...args);
}
intAt(...args) {
return C3.Array.$objProto.intAt.call(this, ...args);
}
int16At(...args) {
return C3.Array.$objProto.int16At.call(this, ...args);
}
int32At(...args) {
return C3.Array.$objProto.int32At.call(this, ...args);
}
byteAt(...args) {
return C3.Array.$objProto.byteAt.call(this, ...args);
}
atOf(...args) {
return C3.Array.$objProto.atOf.call(this, ...args);
}
}
$protos.ArrayBase = ArrayBase;
class SetBase extends Set {
constructor(vt) {
super();
if (new.target == SetBase) {
throw new TypeError('Cannot construct SetBase class directly.');
}
let box = { type: vt };
Object.defineProperty(this, '$private', { value: box });
}
collectionType() {
let vt = this.$private.type;
if (typeof vt.type === 'string') {
vt = SetType.make(vt);
this.$private.type = vt;
}
return vt;
}
contains(e) {
return super.has(e);
}
elementType() {
return this.collectionType().elementType;
}
first(arg) {
if (typeof arg === 'number') {
let array = [];
let i = 0;
for (const e of this) {
if (i >= arg) {
break;
}
array.push(e);
i++;
}
return array;
} else if (typeof arg === 'function') {
for (const e of this) {
if (arg.call(undefined, e)) {
return e;
}
}
} else {
for (const e of this) {
return e;
}
}
}
get(index) {
let i = 0;
for (const value of this) {
if (index === i) {
return value;
}
i++;
}
}
isEmpty() {
return super.size === 0;
}
get size() {
return super.size;
}
toJSON() {
return this.toJson();
}
type() {
return this.$cache.get('type', true, () => C3.Set.bindVar(this.elementType()));
}
_toJson(typed, omitTopLevelType) {
let toJsonFunc = typed ? 'valueToTypedJson' : 'valueToJson';
let vt = this.collectionType();
let et = vt.elementType;
let a = [];
this.forEach(e => a.push(et[toJsonFunc](e)));
return typed && !omitTopLevelType ? { type: this.type().toString(), value: a } : a;
}
toJson() {
return this._toJson(false);
}
toTypedJson(omitTopLevelType) {
return this._toJson(true, omitTopLevelType);
}
fromJson(json) {
_make(this.type().$conn, json, this.collectionType(), false);
}
*_iter() {
for (let e of this)
yield e;
}
_build(...args) {
if (args.length == 1) {
return this.collectionType().buildSet(args[0]);
} else {
return SetType.of(args[0]).buildSet(args[1]);
}
}
_singleton(e) {
return this.collectionType().buildSet(b => b.add(e));
}
approxUniqueCount() {
return C3.Set.$objProto.approxUniqueCount.call(this);
}
approxMedian(...args) {
return C3.Set.$objProto.approxMedian.call(this, ...args);
}
approxHistogram(...args) {
return C3.Set.$objProto.approxHistogram.call(this, ...args);
}
truePercent() {
return C3.Set.$objProto.truePercent.call(this);
}
nullCount() {
return C3.Set.$objProto.nullCount.call(this);
}
toJsonString() {
return C3.Set.$objProto.toJsonString.call(this);
}
toTypedJsonString() {
return C3.Set.$objProto.toTypedJsonString.call(this);
}
toJsString() {
return C3.Set.$objProto.toJsString.call(this);
}
toXmlString() {
return C3.Set.$objProto.toXmlString.call(this);
}
serialize(...args) {
return C3.Set.$objProto.serialize.call(this, ...args);
}
toString(...args) {
return C3.Set.$objProto.toString.call(this, ...args);
}
fingerprint(...args) {
return C3.Set.$objProto.fingerprint.call(this, ...args);
}
retainedMemory(...args) {
return C3.Set.$objProto.retainedMemory.call(this, ...args);
}
elementAgg(...args) {
return C3.Set.$objProto.elementAgg.call(this, ...args);
}
elementAll(...args) {
return C3.Set.$objProto.elementAll.call(this, ...args);
}
elementAvg(...args) {
return C3.Set.$objProto.elementAvg.call(this, ...args);
}
elementCartesianProduct() {
return C3.Set.$objProto.elementCartesianProduct.call(this);
}
elementMin(...args) {
return C3.Set.$objProto.elementMin.call(this, ...args);
}
elementMax(...args) {
return C3.Set.$objProto.elementMax.call(this, ...args);
}
elementSum(...args) {
return C3.Set.$objProto.elementSum.call(this, ...args);
}
elementStddev(...args) {
return C3.Set.$objProto.elementStddev.call(this, ...args);
}
elementVariance(...args) {
return C3.Set.$objProto.elementVariance.call(this, ...args);
}
iter() {
return C3.Set.$objProto.iter.call(this);
}
_iter_() {
return C3.Set.$objProto._iter_.call(this);
}
_length_() {
return C3.Set.$objProto._length_.call(this);
}
collect(...args) {
return C3.Set.$objProto.collect.call(this, ...args);
}
collectArrays(...args) {
return C3.Set.$objProto.collectArrays.call(this, ...args);
}
abs() {
return C3.Set.$objProto.abs.call(this);
}
aggImplementation(...args) {
return C3.Set.$objProto.aggImplementation.call(this, ...args);
}
sumDbl() {
return C3.Set.$objProto.sumDbl.call(this);
}
sumDiff(...args) {
return C3.Set.$objProto.sumDiff.call(this, ...args);
}
cusum(...args) {
return C3.Set.$objProto.cusum.call(this, ...args);
}
normalize() {
return C3.Set.$objProto.normalize.call(this);
}
at(...args) {
return C3.Set.$objProto.at.call(this, ...args);
}
pluck(...args) {
return C3.Set.$objProto.pluck.call(this, ...args);
}
firstNotNull(...args) {
return C3.Set.$objProto.firstNotNull.call(this, ...args);
}
firstNotEmpty(...args) {
return C3.Set.$objProto.firstNotEmpty.call(this, ...args);
}
last(...args) {
return C3.Set.$objProto.last.call(this, ...args);
}
lastNotNull(...args) {
return C3.Set.$objProto.lastNotNull.call(this, ...args);
}
lastNotEmpty(...args) {
return C3.Set.$objProto.lastNotEmpty.call(this, ...args);
}
minImplementation(...args) {
return C3.Set.$objProto.minImplementation.call(this, ...args);
}
minBy(...args) {
return C3.Set.$objProto.minBy.call(this, ...args);
}
maxImplementation(...args) {
return C3.Set.$objProto.maxImplementation.call(this, ...args);
}
maxBy(...args) {
return C3.Set.$objProto.maxBy.call(this, ...args);
}
count(...args) {
return C3.Set.$objProto.count.call(this, ...args);
}
sumImplementation(...args) {
return C3.Set.$objProto.sumImplementation.call(this, ...args);
}
allImplementation(...args) {
return C3.Set.$objProto.allImplementation.call(this, ...args);
}
prod(...args) {
return C3.Set.$objProto.prod.call(this, ...args);
}
avg() {
return C3.Set.$objProto.avg.call(this);
}
avgDbl() {
return C3.Set.$objProto.avgDbl.call(this);
}
median() {
return C3.Set.$objProto.median.call(this);
}
medianDbl() {
return C3.Set.$objProto.medianDbl.call(this);
}
percentile(...args) {
return C3.Set.$objProto.percentile.call(this, ...args);
}
percentileDbl(...args) {
return C3.Set.$objProto.percentileDbl.call(this, ...args);
}
stddev() {
return C3.Set.$objProto.stddev.call(this);
}
stddevDbl() {
return C3.Set.$objProto.stddevDbl.call(this);
}
variance() {
return C3.Set.$objProto.variance.call(this);
}
varianceDbl() {
return C3.Set.$objProto.varianceDbl.call(this);
}
aggDbl(...args) {
return C3.Set.$objProto.aggDbl.call(this, ...args);
}
round(...args) {
return C3.Set.$objProto.round.call(this, ...args);
}
invert() {
return C3.Set.$objProto.invert.call(this);
}
isMissing() {
return C3.Set.$objProto.isMissing.call(this);
}
only(...args) {
return C3.Set.$objProto.only.call(this, ...args);
}
containsAll(...args) {
return C3.Set.$objProto.containsAll.call(this, ...args);
}
containsAny(...args) {
return C3.Set.$objProto.containsAny.call(this, ...args);
}
findAny(...args) {
return C3.Set.$objProto.findAny.call(this, ...args);
}
anyNotNull(...args) {
return C3.Set.$objProto.anyNotNull.call(this, ...args);
}
anyNotEmpty(...args) {
return C3.Set.$objProto.anyNotEmpty.call(this, ...args);
}
each(...args) {
C3.Set.$objProto.each.call(this, ...args);
}
eachWhile(...args) {
return C3.Set.$objProto.eachWhile.call(this, ...args);
}
mapToSame(...args) {
return C3.Set.$objProto.mapToSame.call(this, ...args);
}
map(...args) {
return C3.Set.$objProto.map.call(this, ...args);
}
mapToStr(...args) {
return C3.Set.$objProto.mapToStr.call(this, ...args);
}
mapTo(...args) {
return C3.Set.$objProto.mapTo.call(this, ...args);
}
flatMapToSame(...args) {
return C3.Set.$objProto.flatMapToSame.call(this, ...args);
}
flatMap(...args) {
return C3.Set.$objProto.flatMap.call(this, ...args);
}
flatMapTo(...args) {
return C3.Set.$objProto.flatMapTo.call(this, ...args);
}
flatMapRecursive(...args) {
return C3.Set.$objProto.flatMapRecursive.call(this, ...args);
}
fold(...args) {
return C3.Set.$objProto.fold.call(this, ...args);
}
compact() {
return C3.Set.$objProto.compact.call(this);
}
unique() {
return C3.Set.$objProto.unique.call(this);
}
uniqueBy(...args) {
return C3.Set.$objProto.uniqueBy.call(this, ...args);
}
filter(...args) {
return C3.Set.$objProto.filter.call(this, ...args);
}
fillMissingBy(...args) {
return C3.Set.$objProto.fillMissingBy.call(this, ...args);
}
fillMissing(...args) {
return C3.Set.$objProto.fillMissing.call(this, ...args);
}
fieldNames() {
return C3.Set.$objProto.fieldNames.call(this);
}
fieldValueType(...args) {
return C3.Set.$objProto.fieldValueType.call(this, ...args);
}
reject(...args) {
return C3.Set.$objProto.reject.call(this, ...args);
}
include(...args) {
return C3.Set.$objProto.include.call(this, ...args);
}
fieldSlice(...args) {
return C3.Set.$objProto.fieldSlice.call(this, ...args);
}
fieldSelect(...args) {
return C3.Set.$objProto.fieldSelect.call(this, ...args);
}
exclude(...args) {
return C3.Set.$objProto.exclude.call(this, ...args);
}
replaceByPredicate(...args) {
return C3.Set.$objProto.replaceByPredicate.call(this, ...args);
}
sorted(...args) {
return C3.Set.$objProto.sorted.call(this, ...args);
}
sortedBy(...args) {
return C3.Set.$objProto.sortedBy.call(this, ...args);
}
sortedIndex(...args) {
return C3.Set.$objProto.sortedIndex.call(this, ...args);
}
batch(...args) {
return C3.Set.$objProto.batch.call(this, ...args);
}
partition(...args) {
return C3.Set.$objProto.partition.call(this, ...args);
}
countBy(...args) {
return C3.Set.$objProto.countBy.call(this, ...args);
}
every(...args) {
return C3.Set.$objProto.every.call(this, ...args);
}
flatten(...args) {
return C3.Set.$objProto.flatten.call(this, ...args);
}
sample(...args) {
return C3.Set.$objProto.sample.call(this, ...args);
}
slice(...args) {
return C3.Set.$objProto.slice.call(this, ...args);
}
sliceByKey(...args) {
return C3.Set.$objProto.sliceByKey.call(this, ...args);
}
summarize(...args) {
return C3.Set.$objProto.summarize.call(this, ...args);
}
downsample(...args) {
return C3.Set.$objProto.downsample.call(this, ...args);
}
leastSquares() {
return C3.Set.$objProto.leastSquares.call(this);
}
rollingDiff(...args) {
return C3.Set.$objProto.rollingDiff.call(this, ...args);
}
pctChange(...args) {
return C3.Set.$objProto.pctChange.call(this, ...args);
}
binaryOp(...args) {
return C3.Set.$objProto.binaryOp.call(this, ...args);
}
unaryOp(...args) {
return C3.Set.$objProto.unaryOp.call(this, ...args);
}
shape() {
return C3.Set.$objProto.shape.call(this);
}
dimensionality() {
return C3.Set.$objProto.dimensionality.call(this);
}
toObj() {
return C3.Set.$objProto.toObj.call(this);
}
fetch(...args) {
return C3.Set.$objProto.fetch.call(this, ...args);
}
largest(...args) {
return C3.Set.$objProto.largest.call(this, ...args);
}
histogram(...args) {
return C3.Set.$objProto.histogram.call(this, ...args);
}
neg() {
return C3.Set.$objProto.neg.call(this);
}
describeImplementation(...args) {
return C3.Set.$objProto.describeImplementation.call(this, ...args);
}
and(...args) {
return C3.Set.$objProto.and.call(this, ...args);
}
approxMostFrequent(...args) {
return C3.Set.$objProto.approxMostFrequent.call(this, ...args);
}
or(...args) {
return C3.Set.$objProto.or.call(this, ...args);
}
timeseries(...args) {
return C3.Set.$objProto.timeseries.call(this, ...args);
}
stream() {
return C3.Set.$objProto.stream.call(this);
}
sub(...args) {
return C3.Set.$objProto.sub.call(this, ...args);
}
mul(...args) {
return C3.Set.$objProto.mul.call(this, ...args);
}
div(...args) {
return C3.Set.$objProto.div.call(this, ...args);
}
truediv(...args) {
return C3.Set.$objProto.truediv.call(this, ...args);
}
floordiv(...args) {
return C3.Set.$objProto.floordiv.call(this, ...args);
}
mod(...args) {
return C3.Set.$objProto.mod.call(this, ...args);
}
pow(...args) {
return C3.Set.$objProto.pow.call(this, ...args);
}
radd(...args) {
return C3.Set.$objProto.radd.call(this, ...args);
}
rsub(...args) {
return C3.Set.$objProto.rsub.call(this, ...args);
}
rmul(...args) {
return C3.Set.$objProto.rmul.call(this, ...args);
}
rdiv(...args) {
return C3.Set.$objProto.rdiv.call(this, ...args);
}
rtruediv(...args) {
return C3.Set.$objProto.rtruediv.call(this, ...args);
}
rfloordiv(...args) {
return C3.Set.$objProto.rfloordiv.call(this, ...args);
}
rmod(...args) {
return C3.Set.$objProto.rmod.call(this, ...args);
}
rpow(...args) {
return C3.Set.$objProto.rpow.call(this, ...args);
}
eq(...args) {
return C3.Set.$objProto.eq.call(this, ...args);
}
gt(...args) {
return C3.Set.$objProto.gt.call(this, ...args);
}
ge(...args) {
return C3.Set.$objProto.ge.call(this, ...args);
}
lt(...args) {
return C3.Set.$objProto.lt.call(this, ...args);
}
le(...args) {
return C3.Set.$objProto.le.call(this, ...args);
}
ne(...args) {
return C3.Set.$objProto.ne.call(this, ...args);
}
replaceType(...args) {
return C3.Set.$objProto.replaceType.call(this, ...args);
}
super(...args) {
return C3.Set.$objProto.super.call(this, ...args);
}
zip(...args) {
return C3.Set.$objProto.zip.call(this, ...args);
}
valueType() {
return C3.Set.$objProto.valueType.call(this);
}
toNative(...args) {
return C3.Set.$objProto.toNative.call(this, ...args);
}
validated() {
return C3.Set.$objProto.validated.call(this);
}
inferType() {
return C3.Set.$objProto.inferType.call(this);
}
hasNullElements() {
return C3.Set.$objProto.hasNullElements.call(this);
}
isSame(...args) {
return C3.Set.$objProto.isSame.call(this, ...args);
}
hasSameElements(...args) {
return C3.Set.$objProto.hasSameElements.call(this, ...args);
}
isUnique() {
return C3.Set.$objProto.isUnique.call(this);
}
isSorted() {
return C3.Set.$objProto.isSorted.call(this);
}
isIndexed() {
return C3.Set.$objProto.isIndexed.call(this);
}
indices() {
return C3.Set.$objProto.indices.call(this);
}
indexOf(...args) {
return C3.Set.$objProto.indexOf.call(this, ...args);
}
indexOfAny(...args) {
return C3.Set.$objProto.indexOfAny.call(this, ...args);
}
lastIndexOf(...args) {
return C3.Set.$objProto.lastIndexOf.call(this, ...args);
}
lastIndexOfAny(...args) {
return C3.Set.$objProto.lastIndexOfAny.call(this, ...args);
}
min(...args) {
return C3.Set.$objProto.min.call(this, ...args);
}
max(...args) {
return C3.Set.$objProto.max.call(this, ...args);
}
sum(...args) {
return C3.Set.$objProto.sum.call(this, ...args);
}
all(...args) {
return C3.Set.$objProto.all.call(this, ...args);
}
agg(...args) {
return C3.Set.$objProto.agg.call(this, ...args);
}
toArray(...args) {
return C3.Set.$objProto.toArray.call(this, ...args);
}
toSet(...args) {
return C3.Set.$objProto.toSet.call(this, ...args);
}
toStream(...args) {
return C3.Set.$objProto.toStream.call(this, ...args);
}
toMap(...args) {
return C3.Set.$objProto.toMap.call(this, ...args);
}
toMapOf(...args) {
return C3.Set.$objProto.toMapOf.call(this, ...args);
}
toMapOfAny(...args) {
return C3.Set.$objProto.toMapOfAny.call(this, ...args);
}
toMapOfType(...args) {
return C3.Set.$objProto.toMapOfType.call(this, ...args);
}
toCollection(...args) {
return C3.Set.$objProto.toCollection.call(this, ...args);
}
toMixingCollection(...args) {
return C3.Set.$objProto.toMixingCollection.call(this, ...args);
}
toCollectionOfType(...args) {
return C3.Set.$objProto.toCollectionOfType.call(this, ...args);
}
toInMemory() {
return C3.Set.$objProto.toInMemory.call(this);
}
box() {
return C3.Set.$objProto.box.call(this);
}
boxElements() {
return C3.Set.$objProto.boxElements.call(this);
}
anonymize(...args) {
return C3.Set.$objProto.anonymize.call(this, ...args);
}
descriptiveStatistics() {
return C3.Set.$objProto.descriptiveStatistics.call(this);
}
withoutOutliers(...args) {
return C3.Set.$objProto.withoutOutliers.call(this, ...args);
}
extractOutliers(...args) {
return C3.Set.$objProto.extractOutliers.call(this, ...args);
}
isOutlier(...args) {
return C3.Set.$objProto.isOutlier.call(this, ...args);
}
with(...args) {
return C3.Set.$objProto.with.call(this, ...args);
}
withSome(...args) {
return C3.Set.$objProto.withSome.call(this, ...args);
}
withAll(...args) {
return C3.Set.$objProto.withAll.call(this, ...args);
}
without(...args) {
return C3.Set.$objProto.without.call(this, ...args);
}
withoutSome(...args) {
return C3.Set.$objProto.withoutSome.call(this, ...args);
}
withoutAny(...args) {
return C3.Set.$objProto.withoutAny.call(this, ...args);
}
withoutAll(...args) {
return C3.Set.$objProto.withoutAll.call(this, ...args);
}
difference(...args) {
return C3.Set.$objProto.difference.call(this, ...args);
}
unzip() {
return C3.Set.$objProto.unzip.call(this);
}
mergeSimilar(...args) {
return C3.Set.$objProto.mergeSimilar.call(this, ...args);
}
mergeChildren(...args) {
return C3.Set.$objProto.mergeChildren.call(this, ...args);
}
visit(...args) {
return C3.Set.$objProto.visit.call(this, ...args);
}
withDefaults(...args) {
return C3.Set.$objProto.withDefaults.call(this, ...args);
}
evalTimeseries(...args) {
return C3.Set.$objProto.evalTimeseries.call(this, ...args);
}
groupBy(...args) {
return C3.Set.$objProto.groupBy.call(this, ...args);
}
resample(...args) {
return C3.Set.$objProto.resample.call(this, ...args);
}
rolling(...args) {
return C3.Set.$objProto.rolling.call(this, ...args);
}
_item_(...args) {
return C3.Set.$objProto._item_.call(this, ...args);
}
toData() {
return C3.Set.$objProto.toData.call(this);
}
replace(...args) {
return C3.Set.$objProto.replace.call(this, ...args);
}
initial(...args) {
return C3.Set.$objProto.initial.call(this, ...args);
}
pairs() {
return C3.Set.$objProto.pairs.call(this);
}
isCompressed() {
return C3.Set.$objProto.isCompressed.call(this);
}
compress() {
return C3.Set.$objProto.compress.call(this);
}
uncompress() {
return C3.Set.$objProto.uncompress.call(this);
}
isPacked() {
return C3.Set.$objProto.isPacked.call(this);
}
pack() {
return C3.Set.$objProto.pack.call(this);
}
unpack() {
return C3.Set.$objProto.unpack.call(this);
}
reversed() {
return C3.Set.$objProto.reversed.call(this);
}
withIfMissing(...args) {
return C3.Set.$objProto.withIfMissing.call(this, ...args);
}
toBuilder() {
return C3.Set.$objProto.toBuilder.call(this);
}
}
$protos.SetBase = SetBase;
class MapBase extends Map {
constructor(vt) {
super();
if (new.target == MapBase) {
throw new TypeError('Cannot construct MapBase class directly.');
}
let box = { type: vt };
Object.defineProperty(this, '$private', { value: box });
}
collectionType() {
let vt = this.$private.type;
if (typeof vt.type === 'string') {
vt = MapType.make(vt);
this.$private.type = vt;
}
return vt;
}
type() {
return this.$cache.get('type', true, () => C3.Map.bindVar(this.keyType(), this.elementType()));
}
containsKey(key) {
return super.has(key);
}
elementType() {
return this.collectionType().elementType;
}
first(arg) {
if (typeof arg === 'number') {
let array = [];
let i = 0;
for (const [k, v] of this) {
if (i >= arg) {
break;
}
array.push(v);
i++;
}
return array;
} else if (typeof arg === 'function') {
for (const [k, v] of this) {
if (arg.call(undefined, v, k)) {
return v;
}
}
} else {
for (const [k, v] of this) {
return v;
}
}
}
get(k, ifMissing) {
if (super.has(k)) {
return super.get(k);
}
if (ifMissing) {
return ifMissing.call(undefined, k);
}
}
isEmpty() {
return super.size === 0;
}
keyType() {
return this.collectionType().keyType;
}
get size() {
return super.size;
}
toJSON() {
return this.toJson();
}
_toJson(typed, omitTopLevelType) {
let toJsonFunc = typed ? 'valueToTypedJson' : 'valueToJson';
let vt = this.collectionType();
let et = vt.elementType;
let o = {};
this.forEach((v, k) => o[k] = et[toJsonFunc](v));
return typed && !omitTopLevelType ? { type: this.type().toString(), value: o } : o;
}
toJson() {
return this._toJson(false);
}
toTypedJson(omitTopLevelType) {
return this._toJson(true, omitTopLevelType);
}
fromJson(json) {
_make(this.type().$conn, json, this.collectionType(), false);
}
*_iter() {
for (let [k, e] of this)
yield e;
}
_build(...args) {
if (args.length == 1) {
return this.collectionType().buildMap(args[0]);
} else {
return MapType.of(this.keyType(), args[0]).buildMap(args[1]);
}
}
approxUniqueCount() {
return C3.Map.$objProto.approxUniqueCount.call(this);
}
approxMedian(...args) {
return C3.Map.$objProto.approxMedian.call(this, ...args);
}
approxHistogram(...args) {
return C3.Map.$objProto.approxHistogram.call(this, ...args);
}
truePercent() {
return C3.Map.$objProto.truePercent.call(this);
}
nullCount() {
return C3.Map.$objProto.nullCount.call(this);
}
toJsonString() {
return C3.Map.$objProto.toJsonString.call(this);
}
toTypedJsonString() {
return C3.Map.$objProto.toTypedJsonString.call(this);
}
toJsString() {
return C3.Map.$objProto.toJsString.call(this);
}
toXmlString() {
return C3.Map.$objProto.toXmlString.call(this);
}
serialize(...args) {
return C3.Map.$objProto.serialize.call(this, ...args);
}
toString(...args) {
return C3.Map.$objProto.toString.call(this, ...args);
}
fingerprint(...args) {
return C3.Map.$objProto.fingerprint.call(this, ...args);
}
retainedMemory(...args) {
return C3.Map.$objProto.retainedMemory.call(this, ...args);
}
elementAgg(...args) {
return C3.Map.$objProto.elementAgg.call(this, ...args);
}
elementAll(...args) {
return C3.Map.$objProto.elementAll.call(this, ...args);
}
elementAvg(...args) {
return C3.Map.$objProto.elementAvg.call(this, ...args);
}
elementCartesianProduct() {
return C3.Map.$objProto.elementCartesianProduct.call(this);
}
elementMin(...args) {
return C3.Map.$objProto.elementMin.call(this, ...args);
}
elementMax(...args) {
return C3.Map.$objProto.elementMax.call(this, ...args);
}
elementSum(...args) {
return C3.Map.$objProto.elementSum.call(this, ...args);
}
elementStddev(...args) {
return C3.Map.$objProto.elementStddev.call(this, ...args);
}
elementVariance(...args) {
return C3.Map.$objProto.elementVariance.call(this, ...args);
}
iter() {
return C3.Map.$objProto.iter.call(this);
}
_iter_() {
return C3.Map.$objProto._iter_.call(this);
}
_length_() {
return C3.Map.$objProto._length_.call(this);
}
collect(...args) {
return C3.Map.$objProto.collect.call(this, ...args);
}
collectArrays(...args) {
return C3.Map.$objProto.collectArrays.call(this, ...args);
}
abs() {
return C3.Map.$objProto.abs.call(this);
}
aggImplementation(...args) {
return C3.Map.$objProto.aggImplementation.call(this, ...args);
}
sumDbl() {
return C3.Map.$objProto.sumDbl.call(this);
}
sumDiff(...args) {
return C3.Map.$objProto.sumDiff.call(this, ...args);
}
cusum(...args) {
return C3.Map.$objProto.cusum.call(this, ...args);
}
normalize() {
return C3.Map.$objProto.normalize.call(this);
}
at(...args) {
return C3.Map.$objProto.at.call(this, ...args);
}
pluck(...args) {
return C3.Map.$objProto.pluck.call(this, ...args);
}
firstNotNull(...args) {
return C3.Map.$objProto.firstNotNull.call(this, ...args);
}
firstNotEmpty(...args) {
return C3.Map.$objProto.firstNotEmpty.call(this, ...args);
}
last(...args) {
return C3.Map.$objProto.last.call(this, ...args);
}
lastNotNull(...args) {
return C3.Map.$objProto.lastNotNull.call(this, ...args);
}
lastNotEmpty(...args) {
return C3.Map.$objProto.lastNotEmpty.call(this, ...args);
}
minImplementation(...args) {
return C3.Map.$objProto.minImplementation.call(this, ...args);
}
minBy(...args) {
return C3.Map.$objProto.minBy.call(this, ...args);
}
maxImplementation(...args) {
return C3.Map.$objProto.maxImplementation.call(this, ...args);
}
maxBy(...args) {
return C3.Map.$objProto.maxBy.call(this, ...args);
}
count(...args) {
return C3.Map.$objProto.count.call(this, ...args);
}
sumImplementation(...args) {
return C3.Map.$objProto.sumImplementation.call(this, ...args);
}
allImplementation(...args) {
return C3.Map.$objProto.allImplementation.call(this, ...args);
}
prod(...args) {
return C3.Map.$objProto.prod.call(this, ...args);
}
avg() {
return C3.Map.$objProto.avg.call(this);
}
avgDbl() {
return C3.Map.$objProto.avgDbl.call(this);
}
median() {
return C3.Map.$objProto.median.call(this);
}
medianDbl() {
return C3.Map.$objProto.medianDbl.call(this);
}
percentile(...args) {
return C3.Map.$objProto.percentile.call(this, ...args);
}
percentileDbl(...args) {
return C3.Map.$objProto.percentileDbl.call(this, ...args);
}
stddev() {
return C3.Map.$objProto.stddev.call(this);
}
stddevDbl() {
return C3.Map.$objProto.stddevDbl.call(this);
}
variance() {
return C3.Map.$objProto.variance.call(this);
}
varianceDbl() {
return C3.Map.$objProto.varianceDbl.call(this);
}
aggDbl(...args) {
return C3.Map.$objProto.aggDbl.call(this, ...args);
}
round(...args) {
return C3.Map.$objProto.round.call(this, ...args);
}
invert() {
return C3.Map.$objProto.invert.call(this);
}
isMissing() {
return C3.Map.$objProto.isMissing.call(this);
}
only(...args) {
return C3.Map.$objProto.only.call(this, ...args);
}
contains(...args) {
return C3.Map.$objProto.contains.call(this, ...args);
}
containsAll(...args) {
return C3.Map.$objProto.containsAll.call(this, ...args);
}
containsAny(...args) {
return C3.Map.$objProto.containsAny.call(this, ...args);
}
findAny(...args) {
return C3.Map.$objProto.findAny.call(this, ...args);
}
anyNotNull(...args) {
return C3.Map.$objProto.anyNotNull.call(this, ...args);
}
anyNotEmpty(...args) {
return C3.Map.$objProto.anyNotEmpty.call(this, ...args);
}
each(...args) {
C3.Map.$objProto.each.call(this, ...args);
}
eachWhile(...args) {
return C3.Map.$objProto.eachWhile.call(this, ...args);
}
mapToSame(...args) {
return C3.Map.$objProto.mapToSame.call(this, ...args);
}
map(...args) {
return C3.Map.$objProto.map.call(this, ...args);
}
mapToStr(...args) {
return C3.Map.$objProto.mapToStr.call(this, ...args);
}
mapTo(...args) {
return C3.Map.$objProto.mapTo.call(this, ...args);
}
flatMapToSame(...args) {
return C3.Map.$objProto.flatMapToSame.call(this, ...args);
}
flatMap(...args) {
return C3.Map.$objProto.flatMap.call(this, ...args);
}
flatMapTo(...args) {
return C3.Map.$objProto.flatMapTo.call(this, ...args);
}
flatMapRecursive(...args) {
return C3.Map.$objProto.flatMapRecursive.call(this, ...args);
}
fold(...args) {
return C3.Map.$objProto.fold.call(this, ...args);
}
compact() {
return C3.Map.$objProto.compact.call(this);
}
unique() {
return C3.Map.$objProto.unique.call(this);
}
uniqueBy(...args) {
return C3.Map.$objProto.uniqueBy.call(this, ...args);
}
filter(...args) {
return C3.Map.$objProto.filter.call(this, ...args);
}
fillMissingBy(...args) {
return C3.Map.$objProto.fillMissingBy.call(this, ...args);
}
fillMissing(...args) {
return C3.Map.$objProto.fillMissing.call(this, ...args);
}
fieldNames() {
return C3.Map.$objProto.fieldNames.call(this);
}
fieldValueType(...args) {
return C3.Map.$objProto.fieldValueType.call(this, ...args);
}
reject(...args) {
return C3.Map.$objProto.reject.call(this, ...args);
}
include(...args) {
return C3.Map.$objProto.include.call(this, ...args);
}
fieldSlice(...args) {
return C3.Map.$objProto.fieldSlice.call(this, ...args);
}
fieldSelect(...args) {
return C3.Map.$objProto.fieldSelect.call(this, ...args);
}
exclude(...args) {
return C3.Map.$objProto.exclude.call(this, ...args);
}
replaceByPredicate(...args) {
return C3.Map.$objProto.replaceByPredicate.call(this, ...args);
}
sorted(...args) {
return C3.Map.$objProto.sorted.call(this, ...args);
}
sortedBy(...args) {
return C3.Map.$objProto.sortedBy.call(this, ...args);
}
sortedIndex(...args) {
return C3.Map.$objProto.sortedIndex.call(this, ...args);
}
batch(...args) {
return C3.Map.$objProto.batch.call(this, ...args);
}
partition(...args) {
return C3.Map.$objProto.partition.call(this, ...args);
}
countBy(...args) {
return C3.Map.$objProto.countBy.call(this, ...args);
}
every(...args) {
return C3.Map.$objProto.every.call(this, ...args);
}
flatten(...args) {
return C3.Map.$objProto.flatten.call(this, ...args);
}
sample(...args) {
return C3.Map.$objProto.sample.call(this, ...args);
}
slice(...args) {
return C3.Map.$objProto.slice.call(this, ...args);
}
sliceByKey(...args) {
return C3.Map.$objProto.sliceByKey.call(this, ...args);
}
summarize(...args) {
return C3.Map.$objProto.summarize.call(this, ...args);
}
downsample(...args) {
return C3.Map.$objProto.downsample.call(this, ...args);
}
leastSquares() {
return C3.Map.$objProto.leastSquares.call(this);
}
rollingDiff(...args) {
return C3.Map.$objProto.rollingDiff.call(this, ...args);
}
pctChange(...args) {
return C3.Map.$objProto.pctChange.call(this, ...args);
}
binaryOp(...args) {
return C3.Map.$objProto.binaryOp.call(this, ...args);
}
unaryOp(...args) {
return C3.Map.$objProto.unaryOp.call(this, ...args);
}
shape() {
return C3.Map.$objProto.shape.call(this);
}
dimensionality() {
return C3.Map.$objProto.dimensionality.call(this);
}
toObj() {
return C3.Map.$objProto.toObj.call(this);
}
fetch(...args) {
return C3.Map.$objProto.fetch.call(this, ...args);
}
largest(...args) {
return C3.Map.$objProto.largest.call(this, ...args);
}
histogram(...args) {
return C3.Map.$objProto.histogram.call(this, ...args);
}
neg() {
return C3.Map.$objProto.neg.call(this);
}
describeImplementation(...args) {
return C3.Map.$objProto.describeImplementation.call(this, ...args);
}
and(...args) {
return C3.Map.$objProto.and.call(this, ...args);
}
approxMostFrequent(...args) {
return C3.Map.$objProto.approxMostFrequent.call(this, ...args);
}
or(...args) {
return C3.Map.$objProto.or.call(this, ...args);
}
timeseries(...args) {
return C3.Map.$objProto.timeseries.call(this, ...args);
}
stream() {
return C3.Map.$objProto.stream.call(this);
}
sub(...args) {
return C3.Map.$objProto.sub.call(this, ...args);
}
mul(...args) {
return C3.Map.$objProto.mul.call(this, ...args);
}
div(...args) {
return C3.Map.$objProto.div.call(this, ...args);
}
truediv(...args) {
return C3.Map.$objProto.truediv.call(this, ...args);
}
floordiv(...args) {
return C3.Map.$objProto.floordiv.call(this, ...args);
}
mod(...args) {
return C3.Map.$objProto.mod.call(this, ...args);
}
pow(...args) {
return C3.Map.$objProto.pow.call(this, ...args);
}
radd(...args) {
return C3.Map.$objProto.radd.call(this, ...args);
}
rsub(...args) {
return C3.Map.$objProto.rsub.call(this, ...args);
}
rmul(...args) {
return C3.Map.$objProto.rmul.call(this, ...args);
}
rdiv(...args) {
return C3.Map.$objProto.rdiv.call(this, ...args);
}
rtruediv(...args) {
return C3.Map.$objProto.rtruediv.call(this, ...args);
}
rfloordiv(...args) {
return C3.Map.$objProto.rfloordiv.call(this, ...args);
}
rmod(...args) {
return C3.Map.$objProto.rmod.call(this, ...args);
}
rpow(...args) {
return C3.Map.$objProto.rpow.call(this, ...args);
}
eq(...args) {
return C3.Map.$objProto.eq.call(this, ...args);
}
gt(...args) {
return C3.Map.$objProto.gt.call(this, ...args);
}
ge(...args) {
return C3.Map.$objProto.ge.call(this, ...args);
}
lt(...args) {
return C3.Map.$objProto.lt.call(this, ...args);
}
le(...args) {
return C3.Map.$objProto.le.call(this, ...args);
}
ne(...args) {
return C3.Map.$objProto.ne.call(this, ...args);
}
replaceType(...args) {
return C3.Map.$objProto.replaceType.call(this, ...args);
}
super(...args) {
return C3.Map.$objProto.super.call(this, ...args);
}
zip(...args) {
return C3.Map.$objProto.zip.call(this, ...args);
}
valueType() {
return C3.Map.$objProto.valueType.call(this);
}
toNative(...args) {
return C3.Map.$objProto.toNative.call(this, ...args);
}
validated() {
return C3.Map.$objProto.validated.call(this);
}
inferType() {
return C3.Map.$objProto.inferType.call(this);
}
hasNullElements() {
return C3.Map.$objProto.hasNullElements.call(this);
}
isSame(...args) {
return C3.Map.$objProto.isSame.call(this, ...args);
}
hasSameElements(...args) {
return C3.Map.$objProto.hasSameElements.call(this, ...args);
}
isUnique() {
return C3.Map.$objProto.isUnique.call(this);
}
isSorted() {
return C3.Map.$objProto.isSorted.call(this);
}
isIndexed() {
return C3.Map.$objProto.isIndexed.call(this);
}
indices() {
return C3.Map.$objProto.indices.call(this);
}
indexOf(...args) {
return C3.Map.$objProto.indexOf.call(this, ...args);
}
indexOfAny(...args) {
return C3.Map.$objProto.indexOfAny.call(this, ...args);
}
lastIndexOf(...args) {
return C3.Map.$objProto.lastIndexOf.call(this, ...args);
}
lastIndexOfAny(...args) {
return C3.Map.$objProto.lastIndexOfAny.call(this, ...args);
}
min(...args) {
return C3.Map.$objProto.min.call(this, ...args);
}
max(...args) {
return C3.Map.$objProto.max.call(this, ...args);
}
sum(...args) {
return C3.Map.$objProto.sum.call(this, ...args);
}
all(...args) {
return C3.Map.$objProto.all.call(this, ...args);
}
agg(...args) {
return C3.Map.$objProto.agg.call(this, ...args);
}
toArray(...args) {
return C3.Map.$objProto.toArray.call(this, ...args);
}
toSet(...args) {
return C3.Map.$objProto.toSet.call(this, ...args);
}
toStream(...args) {
return C3.Map.$objProto.toStream.call(this, ...args);
}
toMap(...args) {
return C3.Map.$objProto.toMap.call(this, ...args);
}
toMapOf(...args) {
return C3.Map.$objProto.toMapOf.call(this, ...args);
}
toMapOfAny(...args) {
return C3.Map.$objProto.toMapOfAny.call(this, ...args);
}
toMapOfType(...args) {
return C3.Map.$objProto.toMapOfType.call(this, ...args);
}
toCollection(...args) {
return C3.Map.$objProto.toCollection.call(this, ...args);
}
toMixingCollection(...args) {
return C3.Map.$objProto.toMixingCollection.call(this, ...args);
}
toCollectionOfType(...args) {
return C3.Map.$objProto.toCollectionOfType.call(this, ...args);
}
toInMemory() {
return C3.Map.$objProto.toInMemory.call(this);
}
box() {
return C3.Map.$objProto.box.call(this);
}
boxElements() {
return C3.Map.$objProto.boxElements.call(this);
}
anonymize(...args) {
return C3.Map.$objProto.anonymize.call(this, ...args);
}
descriptiveStatistics() {
return C3.Map.$objProto.descriptiveStatistics.call(this);
}
withoutOutliers(...args) {
return C3.Map.$objProto.withoutOutliers.call(this, ...args);
}
extractOutliers(...args) {
return C3.Map.$objProto.extractOutliers.call(this, ...args);
}
isOutlier(...args) {
return C3.Map.$objProto.isOutlier.call(this, ...args);
}
with(...args) {
return C3.Map.$objProto.with.call(this, ...args);
}
withSome(...args) {
return C3.Map.$objProto.withSome.call(this, ...args);
}
withAll(...args) {
return C3.Map.$objProto.withAll.call(this, ...args);
}
without(...args) {
return C3.Map.$objProto.without.call(this, ...args);
}
withoutSome(...args) {
return C3.Map.$objProto.withoutSome.call(this, ...args);
}
withoutAny(...args) {
return C3.Map.$objProto.withoutAny.call(this, ...args);
}
withoutAll(...args) {
return C3.Map.$objProto.withoutAll.call(this, ...args);
}
difference(...args) {
return C3.Map.$objProto.difference.call(this, ...args);
}
unzip() {
return C3.Map.$objProto.unzip.call(this);
}
mergeSimilar(...args) {
return C3.Map.$objProto.mergeSimilar.call(this, ...args);
}
mergeChildren(...args) {
return C3.Map.$objProto.mergeChildren.call(this, ...args);
}
visit(...args) {
return C3.Map.$objProto.visit.call(this, ...args);
}
withDefaults(...args) {
return C3.Map.$objProto.withDefaults.call(this, ...args);
}
evalTimeseries(...args) {
return C3.Map.$objProto.evalTimeseries.call(this, ...args);
}
groupBy(...args) {
return C3.Map.$objProto.groupBy.call(this, ...args);
}
resample(...args) {
return C3.Map.$objProto.resample.call(this, ...args);
}
rolling(...args) {
return C3.Map.$objProto.rolling.call(this, ...args);
}
_item_(...args) {
return C3.Map.$objProto._item_.call(this, ...args);
}
toData() {
return C3.Map.$objProto.toData.call(this);
}
isCompressed() {
return C3.Map.$objProto.isCompressed.call(this);
}
compress() {
return C3.Map.$objProto.compress.call(this);
}
uncompress() {
return C3.Map.$objProto.uncompress.call(this);
}
isPacked() {
return C3.Map.$objProto.isPacked.call(this);
}
pack() {
return C3.Map.$objProto.pack.call(this);
}
unpack() {
return C3.Map.$objProto.unpack.call(this);
}
reversed() {
return C3.Map.$objProto.reversed.call(this);
}
withIfMissing(...args) {
return C3.Map.$objProto.withIfMissing.call(this, ...args);
}
entryType() {
return C3.Map.$objProto.entryType.call(this);
}
hasNullKeys() {
return C3.Map.$objProto.hasNullKeys.call(this);
}
elements(...args) {
return C3.Map.$objProto.elements.call(this, ...args);
}
keys(...args) {
return C3.Map.$objProto.keys.call(this, ...args);
}
entries(...args) {
return C3.Map.$objProto.entries.call(this, ...args);
}
findAnyElement(...args) {
return C3.Map.$objProto.findAnyElement.call(this, ...args);
}
findAnyEntry(...args) {
return C3.Map.$objProto.findAnyEntry.call(this, ...args);
}
findAnyKey(...args) {
return C3.Map.$objProto.findAnyKey.call(this, ...args);
}
withoutKey(...args) {
return C3.Map.$objProto.withoutKey.call(this, ...args);
}
withoutKeys(...args) {
return C3.Map.$objProto.withoutKeys.call(this, ...args);
}
pickKeys(...args) {
return C3.Map.$objProto.pickKeys.call(this, ...args);
}
merge(...args) {
return C3.Map.$objProto.merge.call(this, ...args);
}
mapEntries(...args) {
return C3.Map.$objProto.mapEntries.call(this, ...args);
}
invertEntries() {
return C3.Map.$objProto.invertEntries.call(this);
}
sortKeys(...args) {
return C3.Map.$objProto.sortKeys.call(this, ...args);
}
toBuilder() {
return C3.Map.$objProto.toBuilder.call(this);
}
}
$protos.MapBase = MapBase;
class AbstractMapBase extends Map {
constructor(vt) {
super();
if (new.target == AbstractMapBase) {
throw new TypeError('Cannot construct AbstractMapBase class directly.');
}
let box = { type: vt };
Object.defineProperty(this, '$private', { value: box });
}
_unsupported(method) {
throw new Error(`Unsupported operation Map#${method}.`);
}
collectionType() {
let vt = this.$private.type;
if (typeof vt.type === 'string') {
vt = MapType.make(vt);
this.$private.type = vt;
}
return vt;
}
type() {
return this.$cache.get('type', true, () => C3.Map.bindVar(this.keyType(), this.elementType()));
}
containsKey(key) {
return super.has(key);
}
elementType() {
return this.collectionType().elementType;
}
get(k, ifMissing) {
if (super.has(k)) {
return super.get(k);
}
if (ifMissing) {
return ifMissing.call(undefined, k);
}
}
isEmpty() {
return super.size === 0;
}
keyType() {
return this.collectionType().keyType;
}
get size() {
return super.size;
}
*_iter() {
for (let [k, e] of this)
yield e;
}
_build(...args) {
if (args.length == 1) {
return this.collectionType().buildMap(args[0]);
} else {
return MapType.of(this.keyType(), args[0]).buildMap(args[1]);
}
}
approxUniqueCount() {
this._unsupported('approxUniqueCount');
}
approxMedian() {
this._unsupported('approxMedian');
}
approxHistogram() {
this._unsupported('approxHistogram');
}
truePercent() {
this._unsupported('truePercent');
}
nullCount() {
this._unsupported('nullCount');
}
toJson() {
this._unsupported('toJson');
}
toTypedJson() {
this._unsupported('toTypedJson');
}
toJsonString() {
this._unsupported('toJsonString');
}
toTypedJsonString() {
this._unsupported('toTypedJsonString');
}
toJsString() {
this._unsupported('toJsString');
}
toXmlString() {
this._unsupported('toXmlString');
}
serialize() {
this._unsupported('serialize');
}
toString() {
this._unsupported('toString');
}
fingerprint() {
this._unsupported('fingerprint');
}
retainedMemory() {
this._unsupported('retainedMemory');
}
elementAgg() {
this._unsupported('elementAgg');
}
elementAll() {
this._unsupported('elementAll');
}
elementAvg() {
this._unsupported('elementAvg');
}
elementCartesianProduct() {
this._unsupported('elementCartesianProduct');
}
elementMin() {
this._unsupported('elementMin');
}
elementMax() {
this._unsupported('elementMax');
}
elementSum() {
this._unsupported('elementSum');
}
elementStddev() {
this._unsupported('elementStddev');
}
elementVariance() {
this._unsupported('elementVariance');
}
iter() {
this._unsupported('iter');
}
_iter_() {
this._unsupported('_iter_');
}
_length_() {
this._unsupported('_length_');
}
collect() {
this._unsupported('collect');
}
collectArrays() {
this._unsupported('collectArrays');
}
abs() {
this._unsupported('abs');
}
aggImplementation() {
this._unsupported('aggImplementation');
}
sumDbl() {
this._unsupported('sumDbl');
}
sumDiff() {
this._unsupported('sumDiff');
}
cusum() {
this._unsupported('cusum');
}
normalize() {
this._unsupported('normalize');
}
at() {
this._unsupported('at');
}
pluck() {
this._unsupported('pluck');
}
first() {
this._unsupported('first');
}
firstNotNull() {
this._unsupported('firstNotNull');
}
firstNotEmpty() {
this._unsupported('firstNotEmpty');
}
last() {
this._unsupported('last');
}
lastNotNull() {
this._unsupported('lastNotNull');
}
lastNotEmpty() {
this._unsupported('lastNotEmpty');
}
minImplementation() {
this._unsupported('minImplementation');
}
minBy() {
this._unsupported('minBy');
}
maxImplementation() {
this._unsupported('maxImplementation');
}
maxBy() {
this._unsupported('maxBy');
}
count() {
this._unsupported('count');
}
sumImplementation() {
this._unsupported('sumImplementation');
}
allImplementation() {
this._unsupported('allImplementation');
}
prod() {
this._unsupported('prod');
}
avg() {
this._unsupported('avg');
}
avgDbl() {
this._unsupported('avgDbl');
}
median() {
this._unsupported('median');
}
medianDbl() {
this._unsupported('medianDbl');
}
percentile() {
this._unsupported('percentile');
}
percentileDbl() {
this._unsupported('percentileDbl');
}
stddev() {
this._unsupported('stddev');
}
stddevDbl() {
this._unsupported('stddevDbl');
}
variance() {
this._unsupported('variance');
}
varianceDbl() {
this._unsupported('varianceDbl');
}
aggDbl() {
this._unsupported('aggDbl');
}
round() {
this._unsupported('round');
}
invert() {
this._unsupported('invert');
}
isMissing() {
this._unsupported('isMissing');
}
only() {
this._unsupported('only');
}
contains() {
this._unsupported('contains');
}
containsAll() {
this._unsupported('containsAll');
}
containsAny() {
this._unsupported('containsAny');
}
findAny() {
this._unsupported('findAny');
}
anyNotNull() {
this._unsupported('anyNotNull');
}
anyNotEmpty() {
this._unsupported('anyNotEmpty');
}
each() {
this._unsupported('each');
}
eachWhile() {
this._unsupported('eachWhile');
}
mapToSame() {
this._unsupported('mapToSame');
}
map() {
this._unsupported('map');
}
mapToStr() {
this._unsupported('mapToStr');
}
mapTo() {
this._unsupported('mapTo');
}
flatMapToSame() {
this._unsupported('flatMapToSame');
}
flatMap() {
this._unsupported('flatMap');
}
flatMapTo() {
this._unsupported('flatMapTo');
}
flatMapRecursive() {
this._unsupported('flatMapRecursive');
}
fold() {
this._unsupported('fold');
}
compact() {
this._unsupported('compact');
}
unique() {
this._unsupported('unique');
}
uniqueBy() {
this._unsupported('uniqueBy');
}
filter() {
this._unsupported('filter');
}
fillMissingBy() {
this._unsupported('fillMissingBy');
}
fillMissing() {
this._unsupported('fillMissing');
}
fieldNames() {
this._unsupported('fieldNames');
}
fieldValueType() {
this._unsupported('fieldValueType');
}
reject() {
this._unsupported('reject');
}
include() {
this._unsupported('include');
}
fieldSlice() {
this._unsupported('fieldSlice');
}
fieldSelect() {
this._unsupported('fieldSelect');
}
exclude() {
this._unsupported('exclude');
}
replaceByPredicate() {
this._unsupported('replaceByPredicate');
}
sorted() {
this._unsupported('sorted');
}
sortedBy() {
this._unsupported('sortedBy');
}
sortedIndex() {
this._unsupported('sortedIndex');
}
batch() {
this._unsupported('batch');
}
partition() {
this._unsupported('partition');
}
countBy() {
this._unsupported('countBy');
}
every() {
this._unsupported('every');
}
flatten() {
this._unsupported('flatten');
}
sample() {
this._unsupported('sample');
}
slice() {
this._unsupported('slice');
}
sliceByKey() {
this._unsupported('sliceByKey');
}
summarize() {
this._unsupported('summarize');
}
downsample() {
this._unsupported('downsample');
}
leastSquares() {
this._unsupported('leastSquares');
}
rollingDiff() {
this._unsupported('rollingDiff');
}
pctChange() {
this._unsupported('pctChange');
}
binaryOp() {
this._unsupported('binaryOp');
}
unaryOp() {
this._unsupported('unaryOp');
}
shape() {
this._unsupported('shape');
}
dimensionality() {
this._unsupported('dimensionality');
}
toObj() {
this._unsupported('toObj');
}
fetch() {
this._unsupported('fetch');
}
largest() {
this._unsupported('largest');
}
histogram() {
this._unsupported('histogram');
}
neg() {
this._unsupported('neg');
}
describeImplementation() {
this._unsupported('describeImplementation');
}
and() {
this._unsupported('and');
}
approxMostFrequent() {
this._unsupported('approxMostFrequent');
}
or() {
this._unsupported('or');
}
timeseries() {
this._unsupported('timeseries');
}
stream() {
this._unsupported('stream');
}
sub() {
this._unsupported('sub');
}
mul() {
this._unsupported('mul');
}
div() {
this._unsupported('div');
}
truediv() {
this._unsupported('truediv');
}
floordiv() {
this._unsupported('floordiv');
}
mod() {
this._unsupported('mod');
}
pow() {
this._unsupported('pow');
}
radd() {
this._unsupported('radd');
}
rsub() {
this._unsupported('rsub');
}
rmul() {
this._unsupported('rmul');
}
rdiv() {
this._unsupported('rdiv');
}
rtruediv() {
this._unsupported('rtruediv');
}
rfloordiv() {
this._unsupported('rfloordiv');
}
rmod() {
this._unsupported('rmod');
}
rpow() {
this._unsupported('rpow');
}
eq() {
this._unsupported('eq');
}
gt() {
this._unsupported('gt');
}
ge() {
this._unsupported('ge');
}
lt() {
this._unsupported('lt');
}
le() {
this._unsupported('le');
}
ne() {
this._unsupported('ne');
}
replaceType() {
this._unsupported('replaceType');
}
super() {
this._unsupported('super');
}
zip() {
this._unsupported('zip');
}
valueType() {
this._unsupported('valueType');
}
toNative() {
this._unsupported('toNative');
}
validated() {
this._unsupported('validated');
}
inferType() {
this._unsupported('inferType');
}
hasNullElements() {
this._unsupported('hasNullElements');
}
isSame() {
this._unsupported('isSame');
}
hasSameElements() {
this._unsupported('hasSameElements');
}
isUnique() {
this._unsupported('isUnique');
}
isSorted() {
this._unsupported('isSorted');
}
isIndexed() {
this._unsupported('isIndexed');
}
indices() {
this._unsupported('indices');
}
indexOf() {
this._unsupported('indexOf');
}
indexOfAny() {
this._unsupported('indexOfAny');
}
lastIndexOf() {
this._unsupported('lastIndexOf');
}
lastIndexOfAny() {
this._unsupported('lastIndexOfAny');
}
min() {
this._unsupported('min');
}
max() {
this._unsupported('max');
}
sum() {
this._unsupported('sum');
}
all() {
this._unsupported('all');
}
agg() {
this._unsupported('agg');
}
toArray() {
this._unsupported('toArray');
}
toSet() {
this._unsupported('toSet');
}
toStream() {
this._unsupported('toStream');
}
toMap() {
this._unsupported('toMap');
}
toMapOf() {
this._unsupported('toMapOf');
}
toMapOfAny() {
this._unsupported('toMapOfAny');
}
toMapOfType() {
this._unsupported('toMapOfType');
}
toCollection() {
this._unsupported('toCollection');
}
toMixingCollection() {
this._unsupported('toMixingCollection');
}
toCollectionOfType() {
this._unsupported('toCollectionOfType');
}
toInMemory() {
this._unsupported('toInMemory');
}
box() {
this._unsupported('box');
}
boxElements() {
this._unsupported('boxElements');
}
anonymize() {
this._unsupported('anonymize');
}
descriptiveStatistics() {
this._unsupported('descriptiveStatistics');
}
withoutOutliers() {
this._unsupported('withoutOutliers');
}
extractOutliers() {
this._unsupported('extractOutliers');
}
isOutlier() {
this._unsupported('isOutlier');
}
with() {
this._unsupported('with');
}
withSome() {
this._unsupported('withSome');
}
withAll() {
this._unsupported('withAll');
}
without() {
this._unsupported('without');
}
withoutSome() {
this._unsupported('withoutSome');
}
withoutAny() {
this._unsupported('withoutAny');
}
withoutAll() {
this._unsupported('withoutAll');
}
difference() {
this._unsupported('difference');
}
unzip() {
this._unsupported('unzip');
}
mergeSimilar() {
this._unsupported('mergeSimilar');
}
mergeChildren() {
this._unsupported('mergeChildren');
}
visit() {
this._unsupported('visit');
}
withDefaults() {
this._unsupported('withDefaults');
}
evalTimeseries() {
this._unsupported('evalTimeseries');
}
groupBy() {
this._unsupported('groupBy');
}
resample() {
this._unsupported('resample');
}
rolling() {
this._unsupported('rolling');
}
_item_() {
this._unsupported('_item_');
}
toData() {
this._unsupported('toData');
}
isCompressed() {
this._unsupported('isCompressed');
}
compress() {
this._unsupported('compress');
}
uncompress() {
this._unsupported('uncompress');
}
isPacked() {
this._unsupported('isPacked');
}
pack() {
this._unsupported('pack');
}
unpack() {
this._unsupported('unpack');
}
reversed() {
this._unsupported('reversed');
}
withIfMissing() {
this._unsupported('withIfMissing');
}
entryType() {
this._unsupported('entryType');
}
hasNullKeys() {
this._unsupported('hasNullKeys');
}
elements() {
this._unsupported('elements');
}
keys() {
this._unsupported('keys');
}
entries() {
this._unsupported('entries');
}
findAnyElement() {
this._unsupported('findAnyElement');
}
findAnyEntry() {
this._unsupported('findAnyEntry');
}
findAnyKey() {
this._unsupported('findAnyKey');
}
withoutKey() {
this._unsupported('withoutKey');
}
withoutKeys() {
this._unsupported('withoutKeys');
}
pickKeys() {
this._unsupported('pickKeys');
}
merge() {
this._unsupported('merge');
}
mapEntries() {
this._unsupported('mapEntries');
}
invertEntries() {
this._unsupported('invertEntries');
}
sortKeys() {
this._unsupported('sortKeys');
}
toBuilder() {
this._unsupported('toBuilder');
}
}
$protos.AbstractMapBase = AbstractMapBase;
class StreamBase {
constructor(vt) {
let box = { type: vt, done: false, seen: 0 };
Object.defineProperty(this, '$private', { value: box });
}
at(index) {
let v;
if (this.skip(index) === index && this.hasNext())
v = this.next();
this.close();
return v;
}
close() {
this.doClose();
if (typeof this.$private.onClose === 'function') {
this.$private.onClose.call(this);
}
}
collect(limit) {
let at = ArrayType.of(this.elementType());
let b = at.makeBuilder();
if (typeof limit === 'number' && limit >= 0) {
let n = 0;
for (let e of this) {
if (n >= limit)
break;
b.add(e);
n++;
}
this.close();
} else {
for (let e of this) {
b.add(e);
}
}
return b.build();
}
collectionType() {
let vt = this.$private.type;
if (typeof vt.type === 'string') {
vt = StreamType.make(vt);
this.$private.type = vt;
}
return vt;
}
count() {
let count = 0;
for (let e of this) {
count++;
}
return count;
}
doClose() {
this.$private.done = true;
if (typeof this.$private.close === 'function') {
this.$private.close.call(this);
}
}
elementType() {
return this.collectionType().elementType;
}
first(arg) {
if (typeof arg === 'number' && arg > 1) {
let elts = [];
for (let i = 0; i < arg && this.hasNext(); i++) {
elts.push(this.next());
}
let vt = this.collectionType();
return _make(vt.type().$conn, elts, vt, false);
} else if (typeof arg === 'function') {
return this.find(arg);
} else {
if (this.hasNext()) {
let e = this.next();
this.doClose();
return e;
}
}
}
hasNext() {
if (!this.$private.done && typeof this.$private.hasNext === 'function') {
let h = this.$private.hasNext.call(this);
if (!h) {
this.doClose();
}
return h;
}
return false;
}
isEmpty() {
return !this.hasNext();
}
next() {
if (!this.$private.done && typeof this.$private.next === 'function') {
let v = this.$private.next.call(this);
this.$private.seen++;
return v;
}
}
seen() {
return this.$private.seen;
}
get size() {
return this.seen() + this.count();
}
skip(n) {
let count;
for (count = 0; count < n && this.hasNext(); count++)
this.next();
return count;
}
toJson() {
let et = this.elementType();
let a = [];
for (let e of this) {
a.push(et.valueToJson(e));
}
return a;
}
toJSON() {
return this.toJson();
}
toString() {
return `[object ${this.constructor.name}(seen ${this.$private.seen}, done ${this.$private.done})]`;
}
type() {
return this.$cache.get('type', true, () => C3.Stream.bindVar(this.elementType()));
}
wasEmpty() {
return this.size == 0;
}
[Symbol.iterator]() {
const stream = this;
return { next: function() {
if (stream.hasNext()) {
return { value: stream.next(), done: false };
} else {
return { value: undefined, done: true };
}
}
, stream };
}
*_iter() {
for (let e of this) {
yield e;
}
}
_build(...args) {
if (args.length == 1) {
return this.collectionType().buildStream(args[0]);
} else {
return StreamType.of(args[0]).buildStream(args[1]);
}
}
_singleton(e) {
return this.collectionType().buildStream(b => b.add(e));
}
_repr_() {
return C3.Stream.$objProto._repr_.call(this);
}
elementAgg(...args) {
return C3.Stream.$objProto.elementAgg.call(this, ...args);
}
elementAll(...args) {
return C3.Stream.$objProto.elementAll.call(this, ...args);
}
elementAvg(...args) {
return C3.Stream.$objProto.elementAvg.call(this, ...args);
}
elementCartesianProduct() {
return C3.Stream.$objProto.elementCartesianProduct.call(this);
}
elementMin(...args) {
return C3.Stream.$objProto.elementMin.call(this, ...args);
}
elementMax(...args) {
return C3.Stream.$objProto.elementMax.call(this, ...args);
}
elementSum(...args) {
return C3.Stream.$objProto.elementSum.call(this, ...args);
}
elementStddev(...args) {
return C3.Stream.$objProto.elementStddev.call(this, ...args);
}
elementVariance(...args) {
return C3.Stream.$objProto.elementVariance.call(this, ...args);
}
iter() {
return C3.Stream.$objProto.iter.call(this);
}
_iter_() {
return C3.Stream.$objProto._iter_.call(this);
}
_length_() {
return C3.Stream.$objProto._length_.call(this);
}
collectArrays(...args) {
return C3.Stream.$objProto.collectArrays.call(this, ...args);
}
abs() {
return C3.Stream.$objProto.abs.call(this);
}
aggImplementation(...args) {
return C3.Stream.$objProto.aggImplementation.call(this, ...args);
}
sumDbl() {
return C3.Stream.$objProto.sumDbl.call(this);
}
sumDiff(...args) {
return C3.Stream.$objProto.sumDiff.call(this, ...args);
}
cusum(...args) {
return C3.Stream.$objProto.cusum.call(this, ...args);
}
normalize() {
return C3.Stream.$objProto.normalize.call(this);
}
pluck(...args) {
return C3.Stream.$objProto.pluck.call(this, ...args);
}
firstNotNull(...args) {
return C3.Stream.$objProto.firstNotNull.call(this, ...args);
}
firstNotEmpty(...args) {
return C3.Stream.$objProto.firstNotEmpty.call(this, ...args);
}
last(...args) {
return C3.Stream.$objProto.last.call(this, ...args);
}
lastNotNull(...args) {
return C3.Stream.$objProto.lastNotNull.call(this, ...args);
}
lastNotEmpty(...args) {
return C3.Stream.$objProto.lastNotEmpty.call(this, ...args);
}
minImplementation(...args) {
return C3.Stream.$objProto.minImplementation.call(this, ...args);
}
minBy(...args) {
return C3.Stream.$objProto.minBy.call(this, ...args);
}
maxImplementation(...args) {
return C3.Stream.$objProto.maxImplementation.call(this, ...args);
}
maxBy(...args) {
return C3.Stream.$objProto.maxBy.call(this, ...args);
}
sumImplementation(...args) {
return C3.Stream.$objProto.sumImplementation.call(this, ...args);
}
allImplementation(...args) {
return C3.Stream.$objProto.allImplementation.call(this, ...args);
}
prod(...args) {
return C3.Stream.$objProto.prod.call(this, ...args);
}
avg() {
return C3.Stream.$objProto.avg.call(this);
}
avgDbl() {
return C3.Stream.$objProto.avgDbl.call(this);
}
median() {
return C3.Stream.$objProto.median.call(this);
}
medianDbl() {
return C3.Stream.$objProto.medianDbl.call(this);
}
percentile(...args) {
return C3.Stream.$objProto.percentile.call(this, ...args);
}
percentileDbl(...args) {
return C3.Stream.$objProto.percentileDbl.call(this, ...args);
}
stddev() {
return C3.Stream.$objProto.stddev.call(this);
}
stddevDbl() {
return C3.Stream.$objProto.stddevDbl.call(this);
}
variance() {
return C3.Stream.$objProto.variance.call(this);
}
varianceDbl() {
return C3.Stream.$objProto.varianceDbl.call(this);
}
aggDbl(...args) {
return C3.Stream.$objProto.aggDbl.call(this, ...args);
}
round(...args) {
return C3.Stream.$objProto.round.call(this, ...args);
}
invert() {
return C3.Stream.$objProto.invert.call(this);
}
isMissing() {
return C3.Stream.$objProto.isMissing.call(this);
}
only(...args) {
return C3.Stream.$objProto.only.call(this, ...args);
}
contains(...args) {
return C3.Stream.$objProto.contains.call(this, ...args);
}
containsAll(...args) {
return C3.Stream.$objProto.containsAll.call(this, ...args);
}
containsAny(...args) {
return C3.Stream.$objProto.containsAny.call(this, ...args);
}
findAny(...args) {
return C3.Stream.$objProto.findAny.call(this, ...args);
}
anyNotNull(...args) {
return C3.Stream.$objProto.anyNotNull.call(this, ...args);
}
anyNotEmpty(...args) {
return C3.Stream.$objProto.anyNotEmpty.call(this, ...args);
}
each(...args) {
C3.Stream.$objProto.each.call(this, ...args);
}
eachWhile(...args) {
return C3.Stream.$objProto.eachWhile.call(this, ...args);
}
mapToSame(...args) {
return C3.Stream.$objProto.mapToSame.call(this, ...args);
}
map(...args) {
return C3.Stream.$objProto.map.call(this, ...args);
}
mapToStr(...args) {
return C3.Stream.$objProto.mapToStr.call(this, ...args);
}
mapTo(...args) {
return C3.Stream.$objProto.mapTo.call(this, ...args);
}
flatMapToSame(...args) {
return C3.Stream.$objProto.flatMapToSame.call(this, ...args);
}
flatMap(...args) {
return C3.Stream.$objProto.flatMap.call(this, ...args);
}
flatMapTo(...args) {
return C3.Stream.$objProto.flatMapTo.call(this, ...args);
}
flatMapRecursive(...args) {
return C3.Stream.$objProto.flatMapRecursive.call(this, ...args);
}
fold(...args) {
return C3.Stream.$objProto.fold.call(this, ...args);
}
compact() {
return C3.Stream.$objProto.compact.call(this);
}
unique() {
return C3.Stream.$objProto.unique.call(this);
}
uniqueBy(...args) {
return C3.Stream.$objProto.uniqueBy.call(this, ...args);
}
filter(...args) {
return C3.Stream.$objProto.filter.call(this, ...args);
}
fillMissingBy(...args) {
return C3.Stream.$objProto.fillMissingBy.call(this, ...args);
}
fillMissing(...args) {
return C3.Stream.$objProto.fillMissing.call(this, ...args);
}
fieldNames() {
return C3.Stream.$objProto.fieldNames.call(this);
}
fieldValueType(...args) {
return C3.Stream.$objProto.fieldValueType.call(this, ...args);
}
reject(...args) {
return C3.Stream.$objProto.reject.call(this, ...args);
}
include(...args) {
return C3.Stream.$objProto.include.call(this, ...args);
}
fieldSlice(...args) {
return C3.Stream.$objProto.fieldSlice.call(this, ...args);
}
fieldSelect(...args) {
return C3.Stream.$objProto.fieldSelect.call(this, ...args);
}
exclude(...args) {
return C3.Stream.$objProto.exclude.call(this, ...args);
}
replaceByPredicate(...args) {
return C3.Stream.$objProto.replaceByPredicate.call(this, ...args);
}
sorted(...args) {
return C3.Stream.$objProto.sorted.call(this, ...args);
}
sortedBy(...args) {
return C3.Stream.$objProto.sortedBy.call(this, ...args);
}
sortedIndex(...args) {
return C3.Stream.$objProto.sortedIndex.call(this, ...args);
}
batch(...args) {
return C3.Stream.$objProto.batch.call(this, ...args);
}
partition(...args) {
return C3.Stream.$objProto.partition.call(this, ...args);
}
countBy(...args) {
return C3.Stream.$objProto.countBy.call(this, ...args);
}
every(...args) {
return C3.Stream.$objProto.every.call(this, ...args);
}
flatten(...args) {
return C3.Stream.$objProto.flatten.call(this, ...args);
}
sample(...args) {
return C3.Stream.$objProto.sample.call(this, ...args);
}
slice(...args) {
return C3.Stream.$objProto.slice.call(this, ...args);
}
sliceByKey(...args) {
return C3.Stream.$objProto.sliceByKey.call(this, ...args);
}
summarize(...args) {
return C3.Stream.$objProto.summarize.call(this, ...args);
}
downsample(...args) {
return C3.Stream.$objProto.downsample.call(this, ...args);
}
leastSquares() {
return C3.Stream.$objProto.leastSquares.call(this);
}
rollingDiff(...args) {
return C3.Stream.$objProto.rollingDiff.call(this, ...args);
}
pctChange(...args) {
return C3.Stream.$objProto.pctChange.call(this, ...args);
}
binaryOp(...args) {
return C3.Stream.$objProto.binaryOp.call(this, ...args);
}
unaryOp(...args) {
return C3.Stream.$objProto.unaryOp.call(this, ...args);
}
shape() {
return C3.Stream.$objProto.shape.call(this);
}
dimensionality() {
return C3.Stream.$objProto.dimensionality.call(this);
}
toObj() {
return C3.Stream.$objProto.toObj.call(this);
}
fetch(...args) {
return C3.Stream.$objProto.fetch.call(this, ...args);
}
largest(...args) {
return C3.Stream.$objProto.largest.call(this, ...args);
}
histogram(...args) {
return C3.Stream.$objProto.histogram.call(this, ...args);
}
neg() {
return C3.Stream.$objProto.neg.call(this);
}
describeImplementation(...args) {
return C3.Stream.$objProto.describeImplementation.call(this, ...args);
}
and(...args) {
return C3.Stream.$objProto.and.call(this, ...args);
}
approxMostFrequent(...args) {
return C3.Stream.$objProto.approxMostFrequent.call(this, ...args);
}
or(...args) {
return C3.Stream.$objProto.or.call(this, ...args);
}
timeseries(...args) {
return C3.Stream.$objProto.timeseries.call(this, ...args);
}
stream() {
return C3.Stream.$objProto.stream.call(this);
}
sub(...args) {
return C3.Stream.$objProto.sub.call(this, ...args);
}
mul(...args) {
return C3.Stream.$objProto.mul.call(this, ...args);
}
div(...args) {
return C3.Stream.$objProto.div.call(this, ...args);
}
truediv(...args) {
return C3.Stream.$objProto.truediv.call(this, ...args);
}
floordiv(...args) {
return C3.Stream.$objProto.floordiv.call(this, ...args);
}
mod(...args) {
return C3.Stream.$objProto.mod.call(this, ...args);
}
pow(...args) {
return C3.Stream.$objProto.pow.call(this, ...args);
}
radd(...args) {
return C3.Stream.$objProto.radd.call(this, ...args);
}
rsub(...args) {
return C3.Stream.$objProto.rsub.call(this, ...args);
}
rmul(...args) {
return C3.Stream.$objProto.rmul.call(this, ...args);
}
rdiv(...args) {
return C3.Stream.$objProto.rdiv.call(this, ...args);
}
rtruediv(...args) {
return C3.Stream.$objProto.rtruediv.call(this, ...args);
}
rfloordiv(...args) {
return C3.Stream.$objProto.rfloordiv.call(this, ...args);
}
rmod(...args) {
return C3.Stream.$objProto.rmod.call(this, ...args);
}
rpow(...args) {
return C3.Stream.$objProto.rpow.call(this, ...args);
}
eq(...args) {
return C3.Stream.$objProto.eq.call(this, ...args);
}
gt(...args) {
return C3.Stream.$objProto.gt.call(this, ...args);
}
ge(...args) {
return C3.Stream.$objProto.ge.call(this, ...args);
}
lt(...args) {
return C3.Stream.$objProto.lt.call(this, ...args);
}
le(...args) {
return C3.Stream.$objProto.le.call(this, ...args);
}
ne(...args) {
return C3.Stream.$objProto.ne.call(this, ...args);
}
approxUniqueCount() {
return C3.Stream.$objProto.approxUniqueCount.call(this);
}
approxMedian(...args) {
return C3.Stream.$objProto.approxMedian.call(this, ...args);
}
approxHistogram(...args) {
return C3.Stream.$objProto.approxHistogram.call(this, ...args);
}
truePercent() {
return C3.Stream.$objProto.truePercent.call(this);
}
nullCount() {
return C3.Stream.$objProto.nullCount.call(this);
}
toTypedJson(...args) {
return C3.Stream.$objProto.toTypedJson.call(this, ...args);
}
toJsonString() {
return C3.Stream.$objProto.toJsonString.call(this);
}
toTypedJsonString() {
return C3.Stream.$objProto.toTypedJsonString.call(this);
}
toJsString() {
return C3.Stream.$objProto.toJsString.call(this);
}
toXmlString() {
return C3.Stream.$objProto.toXmlString.call(this);
}
serialize(...args) {
return C3.Stream.$objProto.serialize.call(this, ...args);
}
fingerprint(...args) {
return C3.Stream.$objProto.fingerprint.call(this, ...args);
}
retainedMemory(...args) {
return C3.Stream.$objProto.retainedMemory.call(this, ...args);
}
replaceType(...args) {
return C3.Stream.$objProto.replaceType.call(this, ...args);
}
super(...args) {
return C3.Stream.$objProto.super.call(this, ...args);
}
zip(...args) {
return C3.Stream.$objProto.zip.call(this, ...args);
}
valueType() {
return C3.Stream.$objProto.valueType.call(this);
}
toNative(...args) {
return C3.Stream.$objProto.toNative.call(this, ...args);
}
validated() {
return C3.Stream.$objProto.validated.call(this);
}
inferType() {
return C3.Stream.$objProto.inferType.call(this);
}
hasNullElements() {
return C3.Stream.$objProto.hasNullElements.call(this);
}
isSame(...args) {
return C3.Stream.$objProto.isSame.call(this, ...args);
}
hasSameElements(...args) {
return C3.Stream.$objProto.hasSameElements.call(this, ...args);
}
isUnique() {
return C3.Stream.$objProto.isUnique.call(this);
}
isSorted() {
return C3.Stream.$objProto.isSorted.call(this);
}
isIndexed() {
return C3.Stream.$objProto.isIndexed.call(this);
}
indices() {
return C3.Stream.$objProto.indices.call(this);
}
indexOf(...args) {
return C3.Stream.$objProto.indexOf.call(this, ...args);
}
indexOfAny(...args) {
return C3.Stream.$objProto.indexOfAny.call(this, ...args);
}
lastIndexOf(...args) {
return C3.Stream.$objProto.lastIndexOf.call(this, ...args);
}
lastIndexOfAny(...args) {
return C3.Stream.$objProto.lastIndexOfAny.call(this, ...args);
}
min(...args) {
return C3.Stream.$objProto.min.call(this, ...args);
}
max(...args) {
return C3.Stream.$objProto.max.call(this, ...args);
}
sum(...args) {
return C3.Stream.$objProto.sum.call(this, ...args);
}
all(...args) {
return C3.Stream.$objProto.all.call(this, ...args);
}
agg(...args) {
return C3.Stream.$objProto.agg.call(this, ...args);
}
toArray(...args) {
return C3.Stream.$objProto.toArray.call(this, ...args);
}
toSet(...args) {
return C3.Stream.$objProto.toSet.call(this, ...args);
}
toStream(...args) {
return C3.Stream.$objProto.toStream.call(this, ...args);
}
toMap(...args) {
return C3.Stream.$objProto.toMap.call(this, ...args);
}
toMapOf(...args) {
return C3.Stream.$objProto.toMapOf.call(this, ...args);
}
toMapOfAny(...args) {
return C3.Stream.$objProto.toMapOfAny.call(this, ...args);
}
toMapOfType(...args) {
return C3.Stream.$objProto.toMapOfType.call(this, ...args);
}
toCollection(...args) {
return C3.Stream.$objProto.toCollection.call(this, ...args);
}
toMixingCollection(...args) {
return C3.Stream.$objProto.toMixingCollection.call(this, ...args);
}
toCollectionOfType(...args) {
return C3.Stream.$objProto.toCollectionOfType.call(this, ...args);
}
toInMemory() {
return C3.Stream.$objProto.toInMemory.call(this);
}
box() {
return C3.Stream.$objProto.box.call(this);
}
boxElements() {
return C3.Stream.$objProto.boxElements.call(this);
}
anonymize(...args) {
return C3.Stream.$objProto.anonymize.call(this, ...args);
}
descriptiveStatistics() {
return C3.Stream.$objProto.descriptiveStatistics.call(this);
}
withoutOutliers(...args) {
return C3.Stream.$objProto.withoutOutliers.call(this, ...args);
}
extractOutliers(...args) {
return C3.Stream.$objProto.extractOutliers.call(this, ...args);
}
isOutlier(...args) {
return C3.Stream.$objProto.isOutlier.call(this, ...args);
}
with(...args) {
return C3.Stream.$objProto.with.call(this, ...args);
}
withSome(...args) {
return C3.Stream.$objProto.withSome.call(this, ...args);
}
withAll(...args) {
return C3.Stream.$objProto.withAll.call(this, ...args);
}
without(...args) {
return C3.Stream.$objProto.without.call(this, ...args);
}
withoutSome(...args) {
return C3.Stream.$objProto.withoutSome.call(this, ...args);
}
withoutAny(...args) {
return C3.Stream.$objProto.withoutAny.call(this, ...args);
}
withoutAll(...args) {
return C3.Stream.$objProto.withoutAll.call(this, ...args);
}
difference(...args) {
return C3.Stream.$objProto.difference.call(this, ...args);
}
unzip() {
return C3.Stream.$objProto.unzip.call(this);
}
mergeSimilar(...args) {
return C3.Stream.$objProto.mergeSimilar.call(this, ...args);
}
mergeChildren(...args) {
return C3.Stream.$objProto.mergeChildren.call(this, ...args);
}
visit(...args) {
return C3.Stream.$objProto.visit.call(this, ...args);
}
withDefaults(...args) {
return C3.Stream.$objProto.withDefaults.call(this, ...args);
}
evalTimeseries(...args) {
return C3.Stream.$objProto.evalTimeseries.call(this, ...args);
}
groupBy(...args) {
return C3.Stream.$objProto.groupBy.call(this, ...args);
}
resample(...args) {
return C3.Stream.$objProto.resample.call(this, ...args);
}
rolling(...args) {
return C3.Stream.$objProto.rolling.call(this, ...args);
}
_item_(...args) {
return C3.Stream.$objProto._item_.call(this, ...args);
}
toData() {
return C3.Stream.$objProto.toData.call(this);
}
replace(...args) {
return C3.Stream.$objProto.replace.call(this, ...args);
}
initial(...args) {
return C3.Stream.$objProto.initial.call(this, ...args);
}
pairs() {
return C3.Stream.$objProto.pairs.call(this);
}
closed() {
return C3.Stream.$objProto.closed.call(this);
}
limit(...args) {
return C3.Stream.$objProto.limit.call(this, ...args);
}
offset(...args) {
return C3.Stream.$objProto.offset.call(this, ...args);
}
concat(...args) {
return C3.Stream.$objProto.concat.call(this, ...args);
}
split(...args) {
return C3.Stream.$objProto.split.call(this, ...args);
}
shuffle(...args) {
return C3.Stream.$objProto.shuffle.call(this, ...args);
}
buffer(...args) {
return C3.Stream.$objProto.buffer.call(this, ...args);
}
peek(...args) {
return C3.Stream.$objProto.peek.call(this, ...args);
}
}
$protos.StreamBase = StreamBase;
class AsyncStreamBase {
constructor(vt) {
let box = { type: vt, done: false, seen: 0 };
Object.defineProperty(this, '$private', { value: box });
}
async at(index) {
let v;
if (await this.skip(index) === index && await this.hasNext())
v = await this.next();
this.close();
return v;
}
async close() {
await this.doClose();
if (typeof this.$private.onClose === 'function') {
await this.$private.onClose.call(this);
}
}
async collect() {
let at = ArrayType.of(this.elementType());
let b = at.makeBuilder();
for await (let e of this) {
b.add(e);
}
return b.build();
}
collectionType() {
let vt = this.$private.type;
if (typeof vt.type === 'string') {
vt = StreamType.make(vt);
this.$private.type = vt;
}
return vt;
}
async doClose() {
this.$private.done = true;
if (typeof this.$private.close === 'function') {
return this.$private.close.call(this);
}
}
elementType() {
return this.collectionType().elementType;
}
async hasNext() {
if (!this.$private.done && typeof this.$private.hasNext === 'function') {
let h = await this.$private.hasNext.call(this);
if (!h) {
await this.doClose();
}
return h;
}
return false;
}
async isEmpty() {
return !await this.hasNext();
}
async next() {
if (!this.$private.done && typeof this.$private.next === 'function') {
let v = await this.$private.next.call(this);
this.$private.seen++;
return v;
}
}
seen() {
return this.$private.seen;
}
async skip(n) {
let count;
for (count = 0; count < n && await this.hasNext(); count++)
await this.next();
return count;
}
get size() {
return new Promise((resolve, reject) => this.count().then(count => resolve(this.seen() + count), reject));
}
async toJson() {
let et = this.elementType();
let a = [];
for await (let e of this) {
a.push(et.valueToJson(e));
}
return a;
}
async toJSON() {
return await this.toJson();
}
toString() {
return `[object ${this.constructor.name}(seen ${this.$private.seen}, done ${this.$private.done})]`;
}
type() {
return this.$cache.get('type', true, () => C3.Stream.bindVar(this.elementType()));
}
async wasEmpty() {
return await this.size == 0;
}
[Symbol.iterator]() {
const stream = this;
return { next: async function() {
if (await stream.hasNext()) {
return { value: await stream.next(), done: false };
} else {
return { value: undefined, done: true };
}
}
, stream };
}
async* _iter() {
for await (let e of this) {
yield e;
}
}
_build(...args) {
if (args.length == 1) {
return this.collectionType().buildStream(args[0]);
} else {
return StreamType.of(args[0]).buildStream(args[1]);
}
}
_singleton(e) {
return this.collectionType().buildStream(b => b.add(e));
}
_repr_() {
return C3.Stream.$objProto._repr_.call(this);
}
elementAgg(...args) {
return C3.Stream.$objProto.elementAgg.call(this, ...args);
}
elementAll(...args) {
return C3.Stream.$objProto.elementAll.call(this, ...args);
}
elementAvg(...args) {
return C3.Stream.$objProto.elementAvg.call(this, ...args);
}
elementCartesianProduct() {
return C3.Stream.$objProto.elementCartesianProduct.call(this);
}
elementMin(...args) {
return C3.Stream.$objProto.elementMin.call(this, ...args);
}
elementMax(...args) {
return C3.Stream.$objProto.elementMax.call(this, ...args);
}
elementSum(...args) {
return C3.Stream.$objProto.elementSum.call(this, ...args);
}
elementStddev(...args) {
return C3.Stream.$objProto.elementStddev.call(this, ...args);
}
elementVariance(...args) {
return C3.Stream.$objProto.elementVariance.call(this, ...args);
}
iter() {
return C3.Stream.$objProto.iter.call(this);
}
_iter_() {
return C3.Stream.$objProto._iter_.call(this);
}
_length_() {
return C3.Stream.$objProto._length_.call(this);
}
collectArrays(...args) {
return C3.Stream.$objProto.collectArrays.call(this, ...args);
}
abs() {
return C3.Stream.$objProto.abs.call(this);
}
aggImplementation(...args) {
return C3.Stream.$objProto.aggImplementation.call(this, ...args);
}
sumDbl() {
return C3.Stream.$objProto.sumDbl.call(this);
}
sumDiff(...args) {
return C3.Stream.$objProto.sumDiff.call(this, ...args);
}
cusum(...args) {
return C3.Stream.$objProto.cusum.call(this, ...args);
}
normalize() {
return C3.Stream.$objProto.normalize.call(this);
}
pluck(...args) {
return C3.Stream.$objProto.pluck.call(this, ...args);
}
first(...args) {
return C3.Stream.$objProto.first.call(this, ...args);
}
firstNotNull(...args) {
return C3.Stream.$objProto.firstNotNull.call(this, ...args);
}
firstNotEmpty(...args) {
return C3.Stream.$objProto.firstNotEmpty.call(this, ...args);
}
last(...args) {
return C3.Stream.$objProto.last.call(this, ...args);
}
lastNotNull(...args) {
return C3.Stream.$objProto.lastNotNull.call(this, ...args);
}
lastNotEmpty(...args) {
return C3.Stream.$objProto.lastNotEmpty.call(this, ...args);
}
minImplementation(...args) {
return C3.Stream.$objProto.minImplementation.call(this, ...args);
}
minBy(...args) {
return C3.Stream.$objProto.minBy.call(this, ...args);
}
maxImplementation(...args) {
return C3.Stream.$objProto.maxImplementation.call(this, ...args);
}
maxBy(...args) {
return C3.Stream.$objProto.maxBy.call(this, ...args);
}
count(...args) {
return C3.Stream.$objProto.count.call(this, ...args);
}
sumImplementation(...args) {
return C3.Stream.$objProto.sumImplementation.call(this, ...args);
}
allImplementation(...args) {
return C3.Stream.$objProto.allImplementation.call(this, ...args);
}
prod(...args) {
return C3.Stream.$objProto.prod.call(this, ...args);
}
avg() {
return C3.Stream.$objProto.avg.call(this);
}
avgDbl() {
return C3.Stream.$objProto.avgDbl.call(this);
}
median() {
return C3.Stream.$objProto.median.call(this);
}
medianDbl() {
return C3.Stream.$objProto.medianDbl.call(this);
}
percentile(...args) {
return C3.Stream.$objProto.percentile.call(this, ...args);
}
percentileDbl(...args) {
return C3.Stream.$objProto.percentileDbl.call(this, ...args);
}
stddev() {
return C3.Stream.$objProto.stddev.call(this);
}
stddevDbl() {
return C3.Stream.$objProto.stddevDbl.call(this);
}
variance() {
return C3.Stream.$objProto.variance.call(this);
}
varianceDbl() {
return C3.Stream.$objProto.varianceDbl.call(this);
}
aggDbl(...args) {
return C3.Stream.$objProto.aggDbl.call(this, ...args);
}
round(...args) {
return C3.Stream.$objProto.round.call(this, ...args);
}
invert() {
return C3.Stream.$objProto.invert.call(this);
}
isMissing() {
return C3.Stream.$objProto.isMissing.call(this);
}
only(...args) {
return C3.Stream.$objProto.only.call(this, ...args);
}
contains(...args) {
return C3.Stream.$objProto.contains.call(this, ...args);
}
containsAll(...args) {
return C3.Stream.$objProto.containsAll.call(this, ...args);
}
containsAny(...args) {
return C3.Stream.$objProto.containsAny.call(this, ...args);
}
findAny(...args) {
return C3.Stream.$objProto.findAny.call(this, ...args);
}
anyNotNull(...args) {
return C3.Stream.$objProto.anyNotNull.call(this, ...args);
}
anyNotEmpty(...args) {
return C3.Stream.$objProto.anyNotEmpty.call(this, ...args);
}
each(...args) {
C3.Stream.$objProto.each.call(this, ...args);
}
eachWhile(...args) {
return C3.Stream.$objProto.eachWhile.call(this, ...args);
}
mapToSame(...args) {
return C3.Stream.$objProto.mapToSame.call(this, ...args);
}
map(...args) {
return C3.Stream.$objProto.map.call(this, ...args);
}
mapToStr(...args) {
return C3.Stream.$objProto.mapToStr.call(this, ...args);
}
mapTo(...args) {
return C3.Stream.$objProto.mapTo.call(this, ...args);
}
flatMapToSame(...args) {
return C3.Stream.$objProto.flatMapToSame.call(this, ...args);
}
flatMap(...args) {
return C3.Stream.$objProto.flatMap.call(this, ...args);
}
flatMapTo(...args) {
return C3.Stream.$objProto.flatMapTo.call(this, ...args);
}
flatMapRecursive(...args) {
return C3.Stream.$objProto.flatMapRecursive.call(this, ...args);
}
fold(...args) {
return C3.Stream.$objProto.fold.call(this, ...args);
}
compact() {
return C3.Stream.$objProto.compact.call(this);
}
unique() {
return C3.Stream.$objProto.unique.call(this);
}
uniqueBy(...args) {
return C3.Stream.$objProto.uniqueBy.call(this, ...args);
}
filter(...args) {
return C3.Stream.$objProto.filter.call(this, ...args);
}
fillMissingBy(...args) {
return C3.Stream.$objProto.fillMissingBy.call(this, ...args);
}
fillMissing(...args) {
return C3.Stream.$objProto.fillMissing.call(this, ...args);
}
fieldNames() {
return C3.Stream.$objProto.fieldNames.call(this);
}
fieldValueType(...args) {
return C3.Stream.$objProto.fieldValueType.call(this, ...args);
}
reject(...args) {
return C3.Stream.$objProto.reject.call(this, ...args);
}
include(...args) {
return C3.Stream.$objProto.include.call(this, ...args);
}
fieldSlice(...args) {
return C3.Stream.$objProto.fieldSlice.call(this, ...args);
}
fieldSelect(...args) {
return C3.Stream.$objProto.fieldSelect.call(this, ...args);
}
exclude(...args) {
return C3.Stream.$objProto.exclude.call(this, ...args);
}
replaceByPredicate(...args) {
return C3.Stream.$objProto.replaceByPredicate.call(this, ...args);
}
sorted(...args) {
return C3.Stream.$objProto.sorted.call(this, ...args);
}
sortedBy(...args) {
return C3.Stream.$objProto.sortedBy.call(this, ...args);
}
sortedIndex(...args) {
return C3.Stream.$objProto.sortedIndex.call(this, ...args);
}
batch(...args) {
return C3.Stream.$objProto.batch.call(this, ...args);
}
partition(...args) {
return C3.Stream.$objProto.partition.call(this, ...args);
}
countBy(...args) {
return C3.Stream.$objProto.countBy.call(this, ...args);
}
every(...args) {
return C3.Stream.$objProto.every.call(this, ...args);
}
flatten(...args) {
return C3.Stream.$objProto.flatten.call(this, ...args);
}
sample(...args) {
return C3.Stream.$objProto.sample.call(this, ...args);
}
slice(...args) {
return C3.Stream.$objProto.slice.call(this, ...args);
}
sliceByKey(...args) {
return C3.Stream.$objProto.sliceByKey.call(this, ...args);
}
summarize(...args) {
return C3.Stream.$objProto.summarize.call(this, ...args);
}
downsample(...args) {
return C3.Stream.$objProto.downsample.call(this, ...args);
}
leastSquares() {
return C3.Stream.$objProto.leastSquares.call(this);
}
rollingDiff(...args) {
return C3.Stream.$objProto.rollingDiff.call(this, ...args);
}
pctChange(...args) {
return C3.Stream.$objProto.pctChange.call(this, ...args);
}
binaryOp(...args) {
return C3.Stream.$objProto.binaryOp.call(this, ...args);
}
unaryOp(...args) {
return C3.Stream.$objProto.unaryOp.call(this, ...args);
}
shape() {
return C3.Stream.$objProto.shape.call(this);
}
dimensionality() {
return C3.Stream.$objProto.dimensionality.call(this);
}
toObj() {
return C3.Stream.$objProto.toObj.call(this);
}
fetch(...args) {
return C3.Stream.$objProto.fetch.call(this, ...args);
}
largest(...args) {
return C3.Stream.$objProto.largest.call(this, ...args);
}
histogram(...args) {
return C3.Stream.$objProto.histogram.call(this, ...args);
}
neg() {
return C3.Stream.$objProto.neg.call(this);
}
describeImplementation(...args) {
return C3.Stream.$objProto.describeImplementation.call(this, ...args);
}
and(...args) {
return C3.Stream.$objProto.and.call(this, ...args);
}
approxMostFrequent(...args) {
return C3.Stream.$objProto.approxMostFrequent.call(this, ...args);
}
or(...args) {
return C3.Stream.$objProto.or.call(this, ...args);
}
timeseries(...args) {
return C3.Stream.$objProto.timeseries.call(this, ...args);
}
stream() {
return C3.Stream.$objProto.stream.call(this);
}
sub(...args) {
return C3.Stream.$objProto.sub.call(this, ...args);
}
mul(...args) {
return C3.Stream.$objProto.mul.call(this, ...args);
}
div(...args) {
return C3.Stream.$objProto.div.call(this, ...args);
}
truediv(...args) {
return C3.Stream.$objProto.truediv.call(this, ...args);
}
floordiv(...args) {
return C3.Stream.$objProto.floordiv.call(this, ...args);
}
mod(...args) {
return C3.Stream.$objProto.mod.call(this, ...args);
}
pow(...args) {
return C3.Stream.$objProto.pow.call(this, ...args);
}
radd(...args) {
return C3.Stream.$objProto.radd.call(this, ...args);
}
rsub(...args) {
return C3.Stream.$objProto.rsub.call(this, ...args);
}
rmul(...args) {
return C3.Stream.$objProto.rmul.call(this, ...args);
}
rdiv(...args) {
return C3.Stream.$objProto.rdiv.call(this, ...args);
}
rtruediv(...args) {
return C3.Stream.$objProto.rtruediv.call(this, ...args);
}
rfloordiv(...args) {
return C3.Stream.$objProto.rfloordiv.call(this, ...args);
}
rmod(...args) {
return C3.Stream.$objProto.rmod.call(this, ...args);
}
rpow(...args) {
return C3.Stream.$objProto.rpow.call(this, ...args);
}
eq(...args) {
return C3.Stream.$objProto.eq.call(this, ...args);
}
gt(...args) {
return C3.Stream.$objProto.gt.call(this, ...args);
}
ge(...args) {
return C3.Stream.$objProto.ge.call(this, ...args);
}
lt(...args) {
return C3.Stream.$objProto.lt.call(this, ...args);
}
le(...args) {
return C3.Stream.$objProto.le.call(this, ...args);
}
ne(...args) {
return C3.Stream.$objProto.ne.call(this, ...args);
}
approxUniqueCount() {
return C3.Stream.$objProto.approxUniqueCount.call(this);
}
approxMedian(...args) {
return C3.Stream.$objProto.approxMedian.call(this, ...args);
}
approxHistogram(...args) {
return C3.Stream.$objProto.approxHistogram.call(this, ...args);
}
truePercent() {
return C3.Stream.$objProto.truePercent.call(this);
}
nullCount() {
return C3.Stream.$objProto.nullCount.call(this);
}
toTypedJson(...args) {
return C3.Stream.$objProto.toTypedJson.call(this, ...args);
}
toJsonString() {
return C3.Stream.$objProto.toJsonString.call(this);
}
toTypedJsonString() {
return C3.Stream.$objProto.toTypedJsonString.call(this);
}
toJsString() {
return C3.Stream.$objProto.toJsString.call(this);
}
toXmlString() {
return C3.Stream.$objProto.toXmlString.call(this);
}
serialize(...args) {
return C3.Stream.$objProto.serialize.call(this, ...args);
}
fingerprint(...args) {
return C3.Stream.$objProto.fingerprint.call(this, ...args);
}
retainedMemory(...args) {
return C3.Stream.$objProto.retainedMemory.call(this, ...args);
}
replaceType(...args) {
return C3.Stream.$objProto.replaceType.call(this, ...args);
}
super(...args) {
return C3.Stream.$objProto.super.call(this, ...args);
}
zip(...args) {
return C3.Stream.$objProto.zip.call(this, ...args);
}
valueType() {
return C3.Stream.$objProto.valueType.call(this);
}
toNative(...args) {
return C3.Stream.$objProto.toNative.call(this, ...args);
}
validated() {
return C3.Stream.$objProto.validated.call(this);
}
inferType() {
return C3.Stream.$objProto.inferType.call(this);
}
hasNullElements() {
return C3.Stream.$objProto.hasNullElements.call(this);
}
isSame(...args) {
return C3.Stream.$objProto.isSame.call(this, ...args);
}
hasSameElements(...args) {
return C3.Stream.$objProto.hasSameElements.call(this, ...args);
}
isUnique() {
return C3.Stream.$objProto.isUnique.call(this);
}
isSorted() {
return C3.Stream.$objProto.isSorted.call(this);
}
isIndexed() {
return C3.Stream.$objProto.isIndexed.call(this);
}
indices() {
return C3.Stream.$objProto.indices.call(this);
}
indexOf(...args) {
return C3.Stream.$objProto.indexOf.call(this, ...args);
}
indexOfAny(...args) {
return C3.Stream.$objProto.indexOfAny.call(this, ...args);
}
lastIndexOf(...args) {
return C3.Stream.$objProto.lastIndexOf.call(this, ...args);
}
lastIndexOfAny(...args) {
return C3.Stream.$objProto.lastIndexOfAny.call(this, ...args);
}
min(...args) {
return C3.Stream.$objProto.min.call(this, ...args);
}
max(...args) {
return C3.Stream.$objProto.max.call(this, ...args);
}
sum(...args) {
return C3.Stream.$objProto.sum.call(this, ...args);
}
all(...args) {
return C3.Stream.$objProto.all.call(this, ...args);
}
agg(...args) {
return C3.Stream.$objProto.agg.call(this, ...args);
}
toArray(...args) {
return C3.Stream.$objProto.toArray.call(this, ...args);
}
toSet(...args) {
return C3.Stream.$objProto.toSet.call(this, ...args);
}
toStream(...args) {
return C3.Stream.$objProto.toStream.call(this, ...args);
}
toMap(...args) {
return C3.Stream.$objProto.toMap.call(this, ...args);
}
toMapOf(...args) {
return C3.Stream.$objProto.toMapOf.call(this, ...args);
}
toMapOfAny(...args) {
return C3.Stream.$objProto.toMapOfAny.call(this, ...args);
}
toMapOfType(...args) {
return C3.Stream.$objProto.toMapOfType.call(this, ...args);
}
toCollection(...args) {
return C3.Stream.$objProto.toCollection.call(this, ...args);
}
toMixingCollection(...args) {
return C3.Stream.$objProto.toMixingCollection.call(this, ...args);
}
toCollectionOfType(...args) {
return C3.Stream.$objProto.toCollectionOfType.call(this, ...args);
}
toInMemory() {
return C3.Stream.$objProto.toInMemory.call(this);
}
box() {
return C3.Stream.$objProto.box.call(this);
}
boxElements() {
return C3.Stream.$objProto.boxElements.call(this);
}
anonymize(...args) {
return C3.Stream.$objProto.anonymize.call(this, ...args);
}
descriptiveStatistics() {
return C3.Stream.$objProto.descriptiveStatistics.call(this);
}
withoutOutliers(...args) {
return C3.Stream.$objProto.withoutOutliers.call(this, ...args);
}
extractOutliers(...args) {
return C3.Stream.$objProto.extractOutliers.call(this, ...args);
}
isOutlier(...args) {
return C3.Stream.$objProto.isOutlier.call(this, ...args);
}
with(...args) {
return C3.Stream.$objProto.with.call(this, ...args);
}
withSome(...args) {
return C3.Stream.$objProto.withSome.call(this, ...args);
}
withAll(...args) {
return C3.Stream.$objProto.withAll.call(this, ...args);
}
without(...args) {
return C3.Stream.$objProto.without.call(this, ...args);
}
withoutSome(...args) {
return C3.Stream.$objProto.withoutSome.call(this, ...args);
}
withoutAny(...args) {
return C3.Stream.$objProto.withoutAny.call(this, ...args);
}
withoutAll(...args) {
return C3.Stream.$objProto.withoutAll.call(this, ...args);
}
difference(...args) {
return C3.Stream.$objProto.difference.call(this, ...args);
}
unzip() {
return C3.Stream.$objProto.unzip.call(this);
}
mergeSimilar(...args) {
return C3.Stream.$objProto.mergeSimilar.call(this, ...args);
}
mergeChildren(...args) {
return C3.Stream.$objProto.mergeChildren.call(this, ...args);
}
visit(...args) {
return C3.Stream.$objProto.visit.call(this, ...args);
}
withDefaults(...args) {
return C3.Stream.$objProto.withDefaults.call(this, ...args);
}
evalTimeseries(...args) {
return C3.Stream.$objProto.evalTimeseries.call(this, ...args);
}
groupBy(...args) {
return C3.Stream.$objProto.groupBy.call(this, ...args);
}
resample(...args) {
return C3.Stream.$objProto.resample.call(this, ...args);
}
rolling(...args) {
return C3.Stream.$objProto.rolling.call(this, ...args);
}
_item_(...args) {
return C3.Stream.$objProto._item_.call(this, ...args);
}
toData() {
return C3.Stream.$objProto.toData.call(this);
}
replace(...args) {
return C3.Stream.$objProto.replace.call(this, ...args);
}
initial(...args) {
return C3.Stream.$objProto.initial.call(this, ...args);
}
pairs() {
return C3.Stream.$objProto.pairs.call(this);
}
closed() {
return C3.Stream.$objProto.closed.call(this);
}
limit(...args) {
return C3.Stream.$objProto.limit.call(this, ...args);
}
offset(...args) {
return C3.Stream.$objProto.offset.call(this, ...args);
}
concat(...args) {
return C3.Stream.$objProto.concat.call(this, ...args);
}
split(...args) {
return C3.Stream.$objProto.split.call(this, ...args);
}
shuffle(...args) {
return C3.Stream.$objProto.shuffle.call(this, ...args);
}
buffer(...args) {
return C3.Stream.$objProto.buffer.call(this, ...args);
}
peek(...args) {
return C3.Stream.$objProto.peek.call(this, ...args);
}
}
$protos.AsyncStreamBase = AsyncStreamBase;
var $protos = $protos ?? {};
function sync() {
return this.connection().typeSystem();
}
function async() {
return this.connection().asyncTypeSystem();
}
function c3() {
return C3;
}
function clearCache(typeName, reimport) {
if (Val.isEmpty(typeName)) {
delete this.$names;
Object.defineProperty(this, '$cache', { value: {}, configurable: true });
this.connection().clearTypeCache();
} else {
let loaded = this.$conn.$typeCache[typeName] ? this.type(typeName) : undefined;
if (loaded != null) {
let subTypes = loaded.meta().subTypeNames();
subTypes.forEach(subTypeName => _clearCacheForSingleType(subTypeName, this, reimport));
_clearCacheForSingleType(typeName, this, reimport);
} else {
delete this.$cache[typeName];
}
if (reimport && _shouldImport(this, typeName)) {
this.$imported[typeName] = this.type(typeName);
}
}
}
function _shouldImport(ts, typeName) {
return typeName.indexOf('.') < 0 && typeName.indexOf('<') < 0 && ts.$imported != null;
}
function _clearCacheForSingleType(typeName, ths, reimport) {
delete ths.$cache[typeName];
ths.connection().clearTypeCache(typeName);
if (ths.$imported != null && ths.$imported[typeName] && ths.$imported[typeName].$c3type) {
delete ths.$imported[typeName];
}
if (reimport && _shouldImport(ths, typeName)) {
ths.$imported[typeName] = ths.type(typeName);
}
}
function cacheContainsType(typeName) {
return !!this.$cache[typeName];
}
function connection() {
return this.$conn;
}
function trackTypeChanges(notify) {
if (this.$trackTypeChanges == null) {
const listenRes = Pkg.listen();
Object.defineProperty(this, '$trackTypeChanges', { value: {
listenRes,
notify: [],
}});
listenRes.eventStream.onNext(e => {
if (this.$trackTypeChanges == null || e.kind == Pkg.Event.Kind.INFO) return;
const typeName = e.typeName();
if (typeName != null) {
let part = e.typePart();
let added = false;
let removed = false;
if (part === Pkg.File.TypePart.DEFINITION) {
added = e.kind === Pkg.Event.Kind.ADD;
removed = e.kind === Pkg.Event.Kind.REMOVE;
}
if (added) {
if (this.$names && this.$names.indexOf(typeName) < 0) {
Object.defineProperty(this, '$names', { value: this.$names.concat(typeName), configurable: true });
}
}
this.clearCache(typeName, !removed);
this.$trackTypeChanges.notify.forEach(cb => cb(e));
}
});
}
if (typeof notify === 'function' && this.$trackTypeChanges.notify.indexOf(notify) < 0) {
this.$trackTypeChanges.notify.push(notify);
}
}
function callRequest(typeName, methodName, ...args) {
return this.$conn.callRequest(typeName, methodName, ...args);
}
function inheritanceInvoker(mixin, funk) {
let f = function (...args) {
if (!this.$chain) {
return funk.apply(this, args);
}
this.$chain.push(mixin);
let rtn;
try {
rtn = funk.apply(this, args);
} finally {
this.$chain.pop();
}
return rtn;
};
Object.defineProperties(f, {
$impl: { value: funk.$impl || funk },
$wrapped: { value: funk },
});
return f;
}
class PropertyStub {
get [Symbol.toStringTag]() {
return 'PropertyStub';
}
toString() {
return '(proxy stub)';
}
}
const STUB = new PropertyStub();
function _instProxy(ts, name, type, preloaded) {
let wrapper = {};
let initialized = false;
function initialize(target) {
initialized = true;
if (ts.$conn.$interactive) {
if (type.$loaded.isWithType && !_hasOwnProperty(target, 'type')) {
target.type = STUB;
}
if (type.$init.fieldTypes) {
type.$init.fieldTypes.forEach(ft => {
if (!_hasOwnProperty(target, ft.name)) {
target[ft.name] = STUB;
}
});
}
if (type.$init.methods) {
type.$init.methods.forEach(m => {
if (m.hasAnyMember && !_hasOwnProperty(target, m.name)) {
target[m.name] = STUB;
}
});
}
}
}
Object.defineProperty(wrapper, '$initialize', { value: () => initialize(wrapper) });
if (preloaded) {
initialize(wrapper);
}
var objProxy;
let methods = {
get: (target, property, receiver) => {
if (_hasOwnProperty(target, property) &&
target[property] !== target.__proto__[property] &&
target[property] !== STUB) {
return target[property];
}
if (type.$loaded.$objProto && property in type.$loaded.$objProto &&
type.$loaded.$objProto[property] !== type.$loaded.$objProto.__proto__[property]) {
if (property === 'type' && type.$loaded.$withType) {
return target.type = function() { return type; };
}
if (/^\$/.test(property)) {
return type.$loaded.$objProto[property];
}
}
if (property == 'super') {
let currType = receiver.$chain[receiver.$chain.length - 1];
return _objSuper(ts, currType, receiver);
} else if (property == '$c3inst') {
return type;
} else if (property == '$c3obj') {
return type.$loaded.$init.isObj;
} else {
let ft = type.$fieldMap.get(property);
if (ft && ft.constant) {
return ft.defaultValue;
}
let f;
let method = type.$memberMap.get(property);
if (method != null) {
let chainedType = type;
if (_hasOwnProperty(type.$loaded.$objProto, property) &&
typeof type.$loaded.$objProto[property] == 'function' &&
type.$loaded.$objProto[property] !== type.$loaded.$objProto.__proto__[property]) {
f = type.$loaded.$objProto[property];
}
if (method.$nearestImplementedOn != null && method.$nearestImplementedOn != name && !type.$forceRemote) {
let mixin = ts.sync().type(method.$nearestImplementedOn, true);
let mf = mixin.$objProto[property];
if (typeof mf === 'function') {
chainedType = mixin;
if (!mf.$delegate) {
f = mf;
}
}
}
let delegate = false;
if (f == null) {
f = function (...args) {
return ts.call.apply(ts, [name, property, this].concat(args));
};
delegate = true;
}
if (method.isCached) {
const impl = f;
f = _cached(name, method, impl);
}
if (method.isProperty && receiver != type.$objProto) {
return f.call(receiver);
}
if (type.$loaded.$init.isWithType) {
f = inheritanceInvoker(chainedType, f);
}
if (delegate) {
Object.defineProperty(f, '$delegate', { value: true });
}
} else if (property == 'toString') {
f = new Function(`return "[object ${name}]";`);
}
if (f != null)
return target[property] = f;
}
if (type.$loaded.$objProto && property in type.$loaded.$objProto)
return type.$loaded.$objProto[property];
},
has: (target, property) => {
return (property in target && target[property] !== STUB) || type.$memberMap.has(property);
},
ownKeys: (target) => {
let keys = [];
Reflect.ownKeys(target).forEach(name => {
if (target[name] !== STUB) {
keys.push(name);
}
});
for (let [name, _m] of type.$memberMap) {
if (keys.indexOf(name) < 0) {
keys.push(name);
}
}
return keys;
},
getOwnPropertyDescriptor: (target, property) => {
if (property in target && target[property] !== STUB) {
return Object.getOwnPropertyDescriptor(target, property);
}
if (type.$memberMap.has(property))
return { configurable: true, enumerable: true };
}
};
objProxy = new Proxy(wrapper, methods);
return objProxy;
}
function _objSuper(ts, type, ths) {
return function (mixin) {
let mixinName;
if (mixin == null)
mixinName = undefined;
else if (mixin.$c3type)
mixinName = mixin.name();
else
mixinName = String(mixin);
const obj = ths; // the called on Obj instance
return new Proxy({}, {
get: (target, property, receiver) => {
if (property in target)
return target[property];
if (property === 'type' && type.$withType)
return target.type = _typeSuper(ts, type);
let method = type.$methods.find(m => m.name == property && m.hasAnyMember);
if (method != null) {
if (mixinName === type.meta().prototypeName()) {
return function (...args) {
return ts.call.apply(ts, [type.name(), property, obj].concat(args));
};
} else {
let mx = _findSuperMixin(ts, type, mixinName, method);
return inheritanceInvoker(mx, mx.$objProto[property]).bind(obj);
}
} else {
return obj[property];
}
}
});
};
}
function _typeProxy(ts, name, preloaded) {
let wrapper = Object.create({}, {
name: { value: function () { return name; }, enumerable: true },
typeSystem: { value: function () { return ts; }, enumerable: true },
$c3type: { value: true },
});
var typeProxy;
const propsKey = 'type-' + name + '-properties';
function setup(loaded, proxied) {
Object.defineProperty(proxied, '$loaded', { value: loaded });
let methods = loaded.$init.methods || [];
Object.defineProperty(proxied, '$methods', { value: methods });
let cache = new SimpleCache(name);
Object.defineProperty(proxied, '$cache', { value: cache });
methods.forEach(m => {
if (typeof loaded[m.name] == 'function' && m.isCached && m.hasAnyStatic) {
let property = m.name;
let impl = loaded[property];
Object.defineProperty(proxied, property, {
value: function (...args) {
return this.$cache.get(property, false, () => impl.apply(this, args));
}
});
}
});
if (loaded.$init.innerTypeNames) {
loaded.$init.innerTypeNames.forEach(innerName => {
let fullName = name + '.' + innerName;
proxied[innerName] = ts.type(fullName);
});
}
const fieldMap = new Map();
if (loaded.$init.fieldTypes) {
loaded.$init.fieldTypes.forEach(ft => fieldMap.set(ft.name, ft));
}
Object.defineProperty(proxied, '$fieldMap', { value: fieldMap });
const memberMap = new Map();
methods.forEach(m => {
if (m.hasAnyMember) {
memberMap.set(m.name, m);
}
});
Object.defineProperty(proxied, '$memberMap', { value: memberMap });
let bf = loaded.builder;
if (typeof bf == 'function' && bf.$std) {
proxied.builder = function (inst) {
let b = bf.call(typeProxy, inst);
b.$setup = function (inst) {
_setupInst(inst, typeProxy);
};
b.$findType = function(type, fields) {
let typeSerName = type.$init.typeSerName || 'type';
if (typeof fields[typeSerName] === 'string' && fields[typeSerName] !== name) {
type = ts.type(fields[typeSerName], true);
}
return type;
};
b.$makeField = function (ft, value) {
let vt = typeof ft.valueType === 'function' ? ft.valueType() : ft.valueType;
return _make(ts.$conn, value, vt, loaded.$init.isStateful);
};
return b;
};
} else {
proxied.$setupInst = function (inst) {
_setupInst(inst, typeProxy);
};
}
if (ts.$conn.$interactive) {
let properties = ['type', 'meta'];
if (!_hasOwnProperty(proxied, 'type')) {
proxied.type = STUB;
}
if (!_hasOwnProperty(proxied, 'meta')) {
proxied.meta = STUB;
}
if (loaded.$init.methods) {
loaded.$init.methods.forEach(m => {
if (m.hasAnyStatic || loaded.$defaultInst) {
properties.push(m.name);
if (!_hasOwnProperty(proxied, m.name)) proxied[m.name] = STUB;
}
});
}
if (loaded.$init.fieldTypes) {
loaded.$init.fieldTypes.forEach(ft => {
if (ft.constant) {
properties.push(ft.name);
if (!_hasOwnProperty(proxied, ft.name)) proxied[ft.name] = STUB;
}
});
}
if (ts.$conn.$localStorage) {
ts.$conn.$localStorage.setItem(propsKey, JSON.stringify(properties));
}
}
if (typeof proxied?.$objProto?.$initialize === 'function') {
proxied.$objProto.$initialize();
}
}
if (preloaded != null) {
setup(preloaded, wrapper);
} else if (ts.$conn.$interactive && ts.$conn.$localStorage) {
try {
const value = ts.$conn.$localStorage.getItem(propsKey);
const properties = value != null ? JSON.parse(value) : null;
if (Array.isArray(properties)) {
properties.forEach(p => {
if (!_hasOwnProperty(wrapper, p)) wrapper[p] = STUB;
});
}
} catch (e) {}
}
function loadedType(target) {
if (target.$loaded == null) {
setup(ts.$conn._loadType(name, true), target);
}
return target.$loaded;
}
function isSingletonField(target, property) {
return loadedType(target).$singleton && loadedType(target).$init.fieldTypes &&
loadedType(target).$init.fieldTypes.find(ft => ft.name == property && !ft.constant) &&
!Type.$init.methods.find(m => m.name === property);
}
typeProxy = new Proxy(wrapper, {
get: (target, property, receiver) => {
if (property == 'toString' || property == Symbol.toPrimitive ||
property == 'toJson' || property == 'toJSON' || property == 'toTypedJson') {
return new Function('return ' + _quote(name) + ';');
}
if (property in target && target[property] !== STUB) {
return target[property];
}
if (target.$loaded == null) {
if (property == 'then') return; // promise resolution calls this when returned from AsyncTypeSystem.type()
loadedType(target);
if (property in target && target[property] !== STUB) {
return target[property];
}
}
let f;
if (property in loadedType(target)) {
let p = loadedType(target)[property];
if (typeof p == 'function') {
f = inheritanceInvoker(receiver, p);
} else {
return target[property] = p;
}
}
if (isSingletonField(target, property)) {
let inst = typeProxy.inst();
return inst[property];
}
if (f == null) {
if (property == 'type') {
f = function () {
return ts.type('Type', true);
};
} else if (property == 'meta') {
f = function () {
return target.$cache.get('meta', false,
() => _make(ts.connection(), { ...wrapper.$loaded.$init, toType: typeProxy },
{ type: "ReferenceType", name: "TypeMeta" }));
};
} else if (property == 'myReferenceType') {
f = function () {
return target.$cache.get('myReferenceType', false,
() => _make(ts.connection(), { name, dereference: typeProxy },
{ type: "ReferenceType", name: "ReferenceType" }));
};
} else if (property == 'bindVar') {
f = function (...args) {
let bindings = args.length == 1 && Array.isArray(args[0]) ? args[0] : args;
let boundName = name + '<' + bindings.map(vt => vt.toString()).join(", ") + '>';
return C3.type(boundName);
};
} else if (property == 'super') {
const currType = receiver.$chain[receiver.$chain.length - 1];
return _typeSuper(ts, currType, receiver);
} else if (property == '_construct') {
f = function _construct() {
let inst = Object.create(this.$objProto);
_setupInst(inst, typeProxy);
return inst;
}
} else {
let method = target.$methods.find(m => m.name == property);
if (method != null && (method.hasAnyStatic || loadedType(target).$defaultInst)) {
let chainedType = receiver;
if (method.$nearestImplementedOn != null && method.$nearestImplementedOn != name) {
let mixin = ts.sync().type(method.$nearestImplementedOn, true);
let mf = mixin[property];
if (typeof mf === 'function') {
chainedType = mixin;
if (!mf.$delegate) {
f = mf;
}
}
}
let delegate = false;
if (f == null) {
if (loadedType(target).$defaultInst && method.hasAnyMember) {
f = function (...args) {
let inst = typeProxy.inst();
return inst[property].apply(inst, args);
};
} else if (method.isCached) {
f = _cached(name, method, (...args) => ts.call.apply(ts, [name, property, typeProxy].concat(args)));
} else {
f = function (...args) {
return ts.call.apply(ts, [name, property, typeProxy].concat(args));
};
}
delegate = true;
}
f = inheritanceInvoker(chainedType, f);
if (delegate) {
Object.defineProperty(f, '$delegate', { value: true });
}
} else {
let typeType = name === 'Type' ? target : ts.$conn.typeSystem().type('Type');
method = typeType.$methods.find(m => m.name == property);
if (method != null && method.hasAnyMember) {
f = typeType.$objProto[method.name];
}
}
}
}
if (f != null)
return target[property] = f;
},
has: (target, property) => {
if (property in target && target[property] !== STUB) {
return true;
}
const loaded = loadedType(target);
if (loaded.$init.fieldTypes.find(ft => ft.name == property && ft.constant)) {
return true;
}
if (target.$methods.find(m => m.name == property && (m.hasAnyStatic || loaded.$defaultInst)) != null) {
return true;
}
return false;
},
ownKeys: (target) => {
const loaded = loadedType(target);
let keys = [];
Reflect.ownKeys(target).forEach(name => {
if (target[name] !== STUB) keys.push(name);
});
loaded.$init.fieldTypes.forEach(ft => {
if (ft.constant && keys.indexOf(ft.name) < 0) keys.push(ft.name);
});
target.$methods.forEach(m => {
if ((m.hasAnyStatic || loaded.$defaultInst) && keys.indexOf(m.name) < 0)
keys.push(m.name);
});
return keys;
},
getOwnPropertyDescriptor: (target, property) => {
if (property in target && target[property] !== STUB) {
return Object.getOwnPropertyDescriptor(target, property);
}
const loaded = loadedType(target);
if (target.$methods.find(m => m.name == property && (m.hasAnyStatic || loaded.$defaultInst)) != null ||
loaded.$init.fieldTypes.find(ft => ft.name === property && ft.constant) != null) {
return { configurable: true, enumerable: true };
}
},
set: (target, property, value) => {
if (isSingletonField(target, property) && loadedType(target).$singleton) {
let inst = typeProxy.inst();
inst[property] = value;
return true;
}
return false;
},
deleteProperty: (target, property) => {
if (isSingletonField(target, property) && loadedType(target).$singleton) {
let inst = typeProxy.inst();
delete inst[property];
return true;
}
return false;
},
});
Object.defineProperty(wrapper, '$objProto', { value: _instProxy(ts, name, typeProxy, preloaded) });
Object.defineProperty(wrapper, '$chain', { value: [typeProxy] });
return typeProxy;
}
function _typeSuper(ts, type, ths) {
var proxy;
if (!ths) {
ths = type;
}
return function () {
if (proxy == null) {
let name = type.name() + '.super()';
proxy = new Proxy({}, {
get: (target, property, receiver) => {
if (property in target)
return target[property];
if (property == 'name')
return target[property] = new Function('return "' + name + '";');
if (property == 'meta' || property == 'super')
return target[property] = new Function(`throw Error('No ${property} for "${name}".');`);
let method = type.$methods.find(m => m.name == property);
if (method != null) {
var mx = _findSuperMixin(ts, type, null, method);
return target[property] = inheritanceInvoker(mx, mx[property]).bind(ths);
} else {
return ths[property];
}
}
});
}
return proxy;
};
}
function _findSuperMixin(ts, type, startName, method) {
let mixinType;
if (startName == null) {
type.meta().mixins().forEach(mx => {
if (mixinType != null)
return;
if (mx.meta().method(method.name) != null)
mixinType = mx;
});
if (mixinType == null)
throw new Error(`No mixin of ${type.name()} implements ${method.name} for super().`);
} else
mixinType = type.meta().mixin(startName, true);
if (!mixinType.$c3type)
mixinType = ts.type(mixinType.name, true);
return mixinType;
}
function _deser(conn, data, vt, mutableParent) {
if (data != null && typeof data === 'object') {
let keys = Object.keys(data).join();
if ((keys === 'type' || keys === 'type,value') && typeof data.type === 'string') {
vt = ValueType.fromString(data.type);
if (vt.isReference() && vt.prototypeName() === 'Boxed') {
vt = vt.dereference(true).meta().varBinding('V', true);
}
if (vt.name === 'Type' && typeof data.value === 'string') {
return conn.typeSystem().type(data.value, true);
}
if (!vt.isReference()) {
data = data.value;
if (keys === 'type') {
data = vt.defaultEmptyValue();
}
}
}
let type;
if (_valueType(vt) === 'ReferenceType') {
if (typeof data.type === 'string' && data.type !== vt.name) {
type = conn.typeSystem().type(data.type, true);
} else {
type = conn.typeSystem().type(vt.name, true);
}
} else if ((_valueType(vt) === 'AnyType' || _valueType(vt) === 'AnyOfType') && typeof data.type === 'string') {
type = conn.typeSystem().type(data.type, false);
}
if (type && type.$fromJson) {
return type.fromJson(data);
}
if (type && conn.$syncFull?.$imported) {
vt = type.meta().referenceType();
}
}
return _make(conn, data, vt, mutableParent, true);
}
function _make(conn, data, vt, mutableParent, deser) {
if (data == null) {
if (_isBoolean(vt) && vt.modifier === 'NON_EMPTY')
return false;
else if (!_isSpecificCollection(vt))
return null;
}
if (typeof data === 'object' && !!data && !!data.type && typeof data.type === 'string' && /^Boxed</.test(data.type)) {
return _deser(conn, data, vt, mutableParent);
}
let made;
let mutable = false;
let vtType = _valueType(vt);
if (vtType == 'VarReferenceType') {
if (vt.restriction != null) {
vt = vt.restriction;
vtType = _valueType(vt);
} else {
vt = AnyType.inst();
vtType = 'AnyType';
}
}
if (_isAnyCollection(vt)) {
if (_hasOwnProperty(data, 'type') && typeof data.type === 'string') {
vt = ValueType.fromString(data.type);
vtType = vt.type().name();
} else if (vtType === 'ReferenceType' && data != null && data.$c3coll) {
return data;
}
}
if (vtType == 'ArrayType') {
made = _array(conn, vt, mutableParent, data);
mutable = mutableParent;
} else if (vtType == 'SetType') {
made = _set(conn, vt, mutableParent, data);
mutable = mutableParent;
} else if (vtType == 'MapType') {
made = _map(conn, vt, mutableParent, data);
mutable = mutableParent;
} else if (_isTuple(vt)) {
if (Val.isTuple(data)) return data;
if (Object.keys(data).join() === 'type,values') {
let tt = ValueType.fromString(data.type);
made = tt.makeValue(data.values);
} else if (data.constructor.name === 'Object' && /^[!?]*\{/.test(data.type)) {
let tt = ValueType.fromString(data.type);
made = tt.makeValue(data);
} else {
if (vt.constructor.name === 'Object' && vt.type === 'TupleType') vt = TupleType.make(vt);
made = vt.makeValue(data);
}
mutable = false;
} else if (vtType == 'StreamType') {
made = _stream(conn, vt, mutableParent, data);
mutable = false;
} else if (vtType == 'ReferenceType') {
if (vt.name == 'Type') {
if (typeof data === 'string') {
return conn.typeSystem().type(data, true);
}
if (data.$c3type) {
return data;
}
}
if (data.$c3inst != null) {
const type = data.$c3inst;
if (!!type.meta && type.meta().isA(vt.name)) {
return data;
} else if (typeof type.then === 'function') {
return type.then(res => {
if (res.meta().isA(vt.name)) {
return data;
}
throw new Error(`Instance of type ${res.type().name()} does not match ${vt.name}`);
});
} else {
throw new Error(`Instance of type ${data.type().name()} does not match ${vt.name}`);
}
} else {
let typeName = vt.name;
let type = conn.typeSystem().type(typeName, true);
let typeSerName = type.$init.typeSerName || 'type';
if (typeof data[typeSerName] === 'string' && data[typeSerName] != typeName) {
typeName = data[typeSerName];
type = conn.typeSystem().type(typeName, true);
}
mutable = type.$init.isStateful;
if (/^Array</.test(typeName)) {
return _make(conn, data, ArrayType.of(type.meta().varBinding('E', true)), mutableParent, deser);
} else if (/^Set</.test(typeName)) {
return _make(conn, data, SetType.of(type.meta().varBinding('E', true)), mutableParent, deser);
} else if (/^Map</.test(typeName)) {
return _make(conn, data,
MapType.of(type.meta().varBinding('K', true)),
MapType.of(type.meta().varBinding('E', true)),
mutableParent, deser);
} else if (/^Stream</.test(typeName)) {
return _make(conn, data, StreamType.of(type.meta().varBinding('E', true)), mutableParent, deser);
}
if (/^Data.Lazy/.test(typeName) && data["lazies"]!=null || typeName == 'Action') {
return _deser(conn, data, vt, mutableParent)
}
let memoized = [];
if (type.$objProto) {
type.$methods.forEach(m => {
let serName = _annValue(m.overloads[0], 'ser', 'name') ?? m.name;
if (serName != 'type' && _hasOwnProperty(data, serName)) {
if (Object.isFrozen(data))
data = Object.assign({}, data);
memoized.push({ method: m, value: data[serName] });
delete data[serName];
}
});
}
if (deser && type.$init.hasSerNameFields) {
type.meta().fieldTypes().forEach(ft => {
if (ft.serName() !== ft.name && _hasOwnProperty(data, ft.serName()) && !_hasOwnProperty(data, ft.name)) {
if (Object.isFrozen(data)) {
data = Object.assign({}, data);
}
data[ft.name] = data[ft.serName()];
delete data[ft.serName()];
}
});
}
made = type._instantiate(data);
if (made) {
_setupInst(made, type);
memoized.forEach(info => {
let { method, value } = info, property = method.name;
if (method.cachedKey == 'arg') {
let cache = new SimpleCache(type.name(), property, method.mergeOverloads.params[0].default);
if (value != null) {
if (method.mergeOverloads.params[0].default) {
let wrapped = {};
let key = String(method.mergeOverloads.params[0].default);
wrapped[key] = value;
value = wrapped;
}
let vt = _returnType(typeName, method.name, method.mergedReturnType);
Object.keys(value).forEach(k => {
cache.putLambda(k, () => _make(conn, value[k], vt, mutable, deser));
});
}
made.$cache.put(property, cache);
} else {
made.$cache.putLambda(property, () => _make(conn, value,
_returnType(typeName, method.name, method.mergedReturnType),
mutable, deser));
}
});
}
}
} else if (_isNumber(vt)) {
if (vtType == 'BigIntType' || vtType === 'IntType' && _annValue(vt, 'js', 'bigInt') === true) {
try {
made = BigInt(data);
} catch (e) {
made = null;
}
} else if (typeof data == 'number') {
made = data;
} else if (typeof data == 'string') {
made = parseFloat(data);
} else
made = NaN;
if (typeof made === 'number' && vtType != 'FloatType' && vtType != 'DoubleType' && isNaN(made)) {
made = null;
}
} else if (vtType == 'BooleanType') {
if (typeof data == 'boolean')
made = data;
else if (data.type == 'number')
made = data !== 0;
else if (data.type == 'string')
made = data !== 'false' && data !== '';
else
made = true;
} else if (vtType == 'StringType') {
made = String(data);
if (made.trim() === '' && vt.modifier !== 'PRESERVES_EMPTY') {
made = null;
}
} else if (vtType == 'DateTimeType') {
made = data instanceof DateTime ? data : DateTime.fromString(String(data));
} else if (vtType == 'BinaryType') {
if (data instanceof ArrayBuffer)
made = data;
else if (ArrayBuffer.isView(data))
made = data.buffer;
else
made = Base64.decode(data);
} else if (vtType == 'JsonType') {
made = data;
} else if (vtType == 'LambdaType') {
if (typeof data === 'function') {
made = data;
} else if (typeof data === 'object') {
made = LambdaType.make().makeValue(data);
}
} else if (vtType == 'EventStreamType') {
vt = ValueType.fromString(data.type);
return _make(conn, data.id, vt, mutableParent, deser);
} else if (vtType == 'NativeType') {
made = data;
mutable = true;
} else if (vtType == 'AnyOfType') {
let guess = ValueType.guessConvertibleType(data);
let r = vt.restrictions.find(r => !r.exclude && _isA(conn, guess, r.valueType));
if (r == null && guess != null && guess.isDouble() && Math.round(data) === data) {
r = vt.restrictions.find(r => !r.exclude && _isInt(r.valueType));
}
if (r == null && typeof data === 'object' && data.constructor.name === 'Object') {
r = vt.restrictions.find(r => !r.exclude && _isMap(r.valueType));
}
if (r == null) {
throw new Error(`Invalid value "${data}" for anyof.`);
}
return _make(conn, data, r.valueType, mutableParent, deser);
} else if (vtType == 'AnyType') {
let guess = ValueType.guessConvertibleType(data);
if (guess != null) {
return _make(conn, data, guess, mutableParent, deser);
} else {
made = data;
}
} else {
throw new Error(`Unsupported value type ${vtType} to make.`);
}
return mutable ? made : Object.freeze(made);
}
function _isBoolean(vt) {
return _valueType(vt) === 'BooleanType';
}
function _isAnyCollection(vt) {
let vtType = _valueType(vt);
if (vtType === 'ReferenceType' && /^Collection(<.*)?$/.test(vt.name)) return true;
return _isSpecificCollection(vt);
}
function _isSpecificCollection(vt) {
let vtType = _valueType(vt);
return vtType === 'ArrayType' || vtType === 'SetType' || vtType === 'MapType' || vtType === 'StreamType';
}
function _isMap(vt) {
return _valueType(vt) === 'MapType';
}
function _isTuple(vt) {
let vtType = _valueType(vt);
if (vtType === 'ReferenceType' && vt.name === 'Tuple') return true;
return vtType === 'TupleType';
}
function _isInt(vt) {
return _valueType(vt) === 'IntType';
}
function _isNumber(vt) {
let vtType = _valueType(vt);
return vtType == 'ByteType' ||
vtType == 'DecimalType' ||
vtType == 'DoubleType' ||
vtType == 'FloatType' ||
vtType == 'IntType' ||
vtType == 'Int16Type' ||
vtType == 'Int32Type' ||
vtType == 'BigIntType' ||
vtType == 'NumberType';
}
function _isDateTime(vt) {
return _valueType(vt) == 'DateTimeType';
}
function _valueType(vt) {
return typeof vt.type === 'function' ? vt.type().name() : vt.type;
}
function _isA(conn, ths, other) {
if (_isDateTime(ths) && _isA(conn, other, DateTime.myReferenceType())) {
return true;
}
if (typeof ths.type === 'function' && typeof other.type === 'function') {
return ths.isA(other);
}
let otherType = typeof other.type === 'function' ? other.type().name() : other.type;
if (otherType == 'AnyType') {
return true;
}
if (_isNumber(ths) && otherType == 'NumberType') {
return true;
}
if (ths.isBoxed()) {
let unBoxed = ths.unboxType();
if (unBoxed.isPrimitive()) {
return ths.unboxPrimitiveType().$cache.type === otherType;
} else {
ths = unBoxed;
}
}
if (typeof ths.type === 'function') {
let vt = _make(conn, other, ValueType.myReferenceType(), false);
return ths.isA(vt);
} else {
return ths.type === otherType;
}
}
function _annValue(vt, ann, field) {
if (typeof vt.annotationValue === 'function')
return vt.annotationValue(ann, field);
if (vt.annotationsJson != null) {
return vt.annotationsJson.reduce((found, a) => {
if (found == null && a[ann] instanceof Array) {
found = a[ann].reduce((prev, f) => f.name == field ? f.value : prev, undefined);
}
if (typeof found === 'string' && typeof Str !== 'undefined') found = Str.unquote(found);
return found;
}, undefined);
}
}
function _makeCallResponse(conn, typeName, action, rsp, method) {
if (rsp.statusCode != 200 && rsp.statusCode != 204) {
return _handleUnsuccessfulCallResponse(conn, typeName, action, rsp);
}
if (method.mergedReturnType != null) {
let data;
if (rsp.statusCode == 204) {
data = null;
} else {
try {
data = rsp.json();
} catch (e) {
throw new Error('Action ' + typeName + '.' + action + ' returned invalid data.\n' + e);
}
}
return _deser(conn, data,
_returnType(typeName, action, method.mergedReturnType),
conn.typeSystem().type(typeName, true).$init.isStateful);
}
}
function _handleUnsuccessfulCallResponse(conn, typeName, action, rsp) {
if (rsp.statusCode === 302 && typeof conn.$tokenExpirationHandler === 'function' && typeof conn.$redirectLoginHandler === 'function') {
if (conn.$handlingTokenExpiration === true ) {
return;
} else {
Object.defineProperty(conn, '$handlingTokenExpiration', { value: true, configurable: true, writable: true });
}
return conn.$tokenExpirationHandler(rsp, conn.$redirectLoginHandler).then(function (token) {
if (!token) {
throw new Error('Failed to get the valid token from Idp login');
}
conn.$authz = token;
let ts = conn.typeSystem();
let args = rsp.request.entity && JSON.parse(rsp.request.entity).slice(1);
return ts.call.apply(ts, [typeName.name(), action, typeName].concat(args));
}).catch((e) => {
throw new Error(e);
}).finally(() => {
conn.$handlingTokenExpiration = false;
});
} else {
let m;
if (rsp.headers == null || rsp.headers['content-type'] == null || rsp.headers['content-type'] == 'text/plain') {
m = rsp.string();
} else if (rsp.headers['content-type'] == 'application/json') {
try {
m = rsp.json().message;
} catch (e) {
if (rsp.statusCode == 500) {
if (/^\s*[A-Z]/.test(rsp.string())) {
m = rsp.string();
}
}
}
}
if (m == null || m === '') {
m = 'Action ' + typeName + '.' + action + ' failed with status ' + rsp.statusCode + '.';
}
throw new Error(m);
}
}
function _returnType(typeName, action, vt) {
if (vt == null)
throw new Error('Missing return type for method ' + typeName + '.' + action);
return vt;
}
function _filterTypeNames(allNames, includeInnerTypes) {
return includeInnerTypes ? allNames : allNames.filter(n => n.indexOf('.') < 0);
}
class ImmutableArray extends ArrayBase {
constructor(vt) {
super(vt);
}
}
$protos.ImmutableArray = ImmutableArray;
class MutableArray extends ArrayBase {
constructor(vt) {
super(vt);
Object.defineProperty(this, '$mutable', { value: true });
}
}
$protos.MutableArray = MutableArray;
function _array(conn, vt, mutable, data) {
const MUTATORS = ['fill', 'pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'];
let array = mutable ? new MutableArray(vt) : new ImmutableArray(vt);
if (data != null) {
if (Array.isArray(data)) {
data.forEach(e => Array.prototype.push.call(array, _make(conn, e, vt.elementType, mutable)));
} else {
throw new Error(`Invalid value "${data}" to make an Array.`);
}
}
if (mutable) {
let proxy;
let $onChange, $parentObj = null, $noReparent = false;
function callOnChange(changed) {
if ($onChange) {
$onChange.call(proxy, changed);
}
}
var recurse = false;
function notify(property, prior) {
if (recurse)
return;
recurse = true;
try {
if (prior != null) {
prior.forEach(e => {
if (_isMutable(e) && array.indexOf(e) < 0) {
if (e.$parentObj == $parentObj && !$noReparent) {
e.$parentObj = null;
}
if (e.$onChange && e.$onChange.$owner === proxy) {
e.$onChange = null;
}
}
});
}
array.forEach(e => {
if (_isMutable(e)) {
if (!$noReparent) {
e.$parentObj = $parentObj;
}
if (e.$onChange == null || e.$onChange.$owner !== proxy) {
let f = function (childChanged) {
let index = array.indexOf(e);
if (index >= 0) {
callOnChange(childChanged.map(childPath => {
let path = '[' + index + ']';
if (childPath != null && childPath !== '') {
if (childPath[0] != '[') {
path += '.';
}
path += childPath;
}
return path;
}));
}
};
Object.defineProperty(f, '$owner', { value: proxy });
e.$onChange = f;
}
}
});
if ($onChange && prior) {
let changed = [];
let max = Math.max(array.length, prior.length);
for (let i = 0; i < max; i++) {
if ((prior[i] != null || array[i] != null) && prior[i] !== array[i]) {
changed.push('[' + i + ']');
}
}
if (changed.length > 0) {
callOnChange(changed);
}
}
} finally {
recurse = false;
}
}
const cache = {
$mutable: true,
add: function (v) {
this.push(_make(conn, v, vt.elementType, false));
return this;
},
remove: function (predicate) {
let prior;
let count = 0;
let i = 0;
while (i < array.length) {
if (predicate(array[i])) {
if (prior == null) {
prior = array.slice();
}
array.splice(i, 1);
count++;
} else {
i++;
}
}
if (prior) {
notify('remove', prior);
}
return count;
},
take: function (predicate) {
let prior;
let count = 0;
let i = 0;
let taken = [];
while (i < array.length) {
let e = array[i];
if (predicate(e)) {
if (prior == null) {
prior = array.slice();
}
array.splice(i, 1);
taken.push(e);
count++;
} else {
i++;
}
}
if (prior) {
notify('take', prior);
}
return _array(conn, vt, false, taken);
},
};
proxy = new Proxy(array, {
get: function (target, property) {
if (_hasOwnProperty(cache, property))
return cache[property];
if (property == '$onChange') {
return $onChange;
}
if (property == '$parentObj') {
return $parentObj;
} else if (MUTATORS.indexOf(property) >= 0) {
let f = function (...args) {
let prior = Array.from(array);
let retval = array[property].apply(array, args);
notify(property, prior);
return retval;
};
cache[property] = f;
return f;
} else {
return array[property];
}
},
set: function (target, property, value) {
if (property == '$onChange') {
$onChange = value;
return true;
} else if (property == '$parentObj') {
if ($parentObj !== value) {
$parentObj = value;
if (!$noReparent) {
array.forEach(e => {
if (_isMutable(e)) {
e.$parentObj = value;
}
});
}
}
return true;
} else if (property == '$noReparent') {
$noReparent = value;
return true;
} else if (property.charAt(0) == '$') {
target[property] = value;
return true;
} else if (property == 'length') {
if (array.length !== value) {
let prior = Array.from(array);
array.length = value;
notify(property, prior);
}
return true;
} else if (/^[0-9]+$/.test(property)) {
let i = parseInt(property);
if (array[i] !== value) {
let prior = Array.from(array);
array[i] = value;
notify(property, prior);
}
return true;
} else {
throw new TypeError('Cannot add property ' + property + ', Array is not extensible.');
}
},
deleteProperty: function (target, property) {
if (/^[0-9]+$/.test(property)) {
let i = parseInt(property);
if (i >= 0 && i < array[i] !== undefined) {
let prior = Array.from(array);
delete array[i];
notify(property, prior);
}
return true;
} else {
return false;
}
},
});
notify();
_setupColl(proxy, 'Array', vt);
return proxy;
}
_setupColl(array, 'Array', vt);
return array;
}
class ImmutableSet extends SetBase {
constructor(vt) {
super(vt);
}
add(value) {
throw new Error(`Cannot add "${value}", Set is not extensible.`);
}
delete(value) {
throw new Error(`Cannot delete "${value}", Set is not extensible.`);
}
clear() {
throw new Error(`Cannot clear, Set is not extensible.`);
}
}
$protos.ImmutableSet = ImmutableSet;
class MutableSet extends SetBase {
constructor(vt) {
super(vt);
Object.defineProperty(this, '$mutable', { value: true });
}
add(value) {
let vt = this.collectionType().elementType;
let made = _make(vt.type().$conn, value, vt, true);
if (this.has(made)) {
return this;
}
let index = this.size;
super.add(made);
this.$register(made);
this.$notify([index]);
return this;
}
delete(value) {
let index = this.indexOf(value);
if (index < 1) {
return false;
}
super.delete(value);
this.$unregister(value);
this.$notify([index]);
return true;
}
remove(predicate) {
const iter = this.values();
let indexes = [];
let next;
for (let i = 0; (next = iter.next()) && !next.done; i++) {
if (predicate.call(undefined, next.value)) {
super.delete(next.value);
this.$unregister(next.value);
indexes.push(i);
}
}
this.$notify(indexes);
return indexes.length;
}
take(predicate) {
const iter = this.values();
let indexes = [];
let values = [];
let next;
for (let i = 0; (next = iter.next()) && !next.done; i++) {
if (predicate.call(undefined, next.value)) {
super.delete(next.value);
this.$unregister(next.value);
indexes.push(i);
values.push(next.value);
}
}
this.$notify(indexes);
let vt = this.collectionType();
return _make(vt.type().$conn, values, ArrayType.of(vt.elementType), false);
}
clear() {
if (this.size > 0) {
let indexes = [];
let i = 0;
for (const e of this) {
this.$unregister(e);
indexes.push(i);
i++;
}
super.clear();
this.$notify(indexes);
}
}
$notify(indexes) {
if (this.$onChange && indexes.length > 0) {
this.$callOnChange(indexes.map(index => '[' + index + ']'));
}
}
get $onChange() {
return this.$private.onChange;
}
set $onChange(cb) {
if (typeof cb === 'function') {
this.$private.onChange = cb;
} else {
delete this.$private.onChange;
}
}
$callOnChange(changed) {
if (this.$onChange && !this.$private.recurse) {
this.$private.recurse = true;
try {
this.$onChange.call(this, changed);
} finally {
delete this.$private.recurse;
}
}
}
get $parentObj() {
return this.$private.parentObj;
}
set $parentObj(value) {
if (value === null) {
value = undefined;
}
if (this.$private.parentObj !== value) {
this.$private.parentObj = value;
if (!this.$noReparent) {
for (const e of this) {
if (_isMutable(e)) {
e.$parentObj = value;
}
}
}
}
}
$register(e) {
if (_isMutable(e)) {
if (!this.$noReparent) {
e.$parentObj = this.$parentObj;
}
if (e.$onChange == null || e.$onChange.$owner !== this) {
const set = this;
let f = function (childChanged) {
let index = set.indexOf(e);
if (index >= 0) {
set.$callOnChange(childChanged.map(childPath => {
let path = '[' + index + ']';
if (childPath != null && childPath !== '') {
if (childPath[0] != '[') {
path += '.';
}
path += childPath;
}
return path;
}));
}
};
Object.defineProperty(f, '$owner', { value: this });
e.$onChange = f;
}
}
}
$unregister(e) {
if (_isMutable(e)) {
if (e.$parentObj === this.$parentObj && this.$noReparent) {
e.$parentObj = null;
}
if (e.$onChange && e.$onChange.$owner === this) {
e.$onChange = null;
}
}
}
}
$protos.MutableSet = MutableSet;
function _set(conn, vt, mutable, data) {
if (!mutable && data instanceof ImmutableSet) {
if (!_isA(conn, data.collectionType(), vt)) {
let vtType = typeof vt.elementType.type === 'function' ? vt.elementType.type().name() : vt.elementType.type;
throw new Error(`Set of ${data.type().elementType.type().name()} does not match ${vtType}.`);
}
return data;
}
let fromSet;
if (data instanceof Set) {
fromSet = data;
} else {
fromSet = new Set();
if (Array.isArray(data)) {
data.forEach(v => fromSet.add(v));
} else if (data != null) {
throw new Error(`Invalid value "${data}" to make a Set.`);
}
}
let made;
if (mutable) {
made = new MutableSet(vt);
} else {
made = new ImmutableSet(vt);
}
_setupColl(made, 'Set', vt);
for (let v of fromSet) {
Set.prototype.add.call(made, v = _make(conn, v, vt.elementType, mutable));
if (mutable) {
made.$register(v);
}
}
return made;
}
class ImmutableMap extends MapBase {
constructor(vt) {
super(vt);
}
set(key, _value) {
throw new Error(`Cannot set key ${key}, Map is not extensible.`);
}
delete(key) {
throw new Error(`Cannot delete key ${key}, Map is not extensible.`);
}
clear() {
throw new Error(`Cannot clear, Map is not extensible.`);
}
}
$protos.ImmutableMap = ImmutableMap;
class MutableMap extends MapBase {
constructor(vt) {
super(vt);
Object.defineProperty(this, '$mutable', { value: true });
}
set(key, value) {
let kt = this.collectionType().keyType;
let vt = this.collectionType().elementType;
key = _make(vt.type().$conn, key, kt);
value = _make(vt.type().$conn, value, vt, true);
if (this.get(key) === value) {
return this;
}
super.set(key, value);
this.$register(key, value);
this.$notify([String(key)]);
return this;
}
delete(key) {
if (this.has(key)) {
const value = this.get(key);
super.delete(key);
this.$unregister(value);
this.$notify([String(key)]);
}
return true;
}
clear() {
if (this.size > 0) {
let keys = [];
for (const [k, v] of this) {
this.$unregister(v);
keys.push(String(k));
}
super.clear();
this.$notify(keys);
}
}
put(key, value) {
return this.set(key, value);
}
remove(predicate) {
let keys = [];
for (const [k, v] of this) {
if (predicate.call(undefined, v, k)) {
this.$unregister(v);
keys.push(String(k));
super.delete(k);
}
}
this.$notify(keys);
return keys.length;
}
take(predicate) {
let keys = [];
let values = [];
for (const [k, v] of this) {
if (predicate.call(undefined, v, k)) {
this.$unregister(v);
keys.push(String(k));
values.push(v);
super.delete(k);
}
}
this.$notify(keys);
let vt = this.collectionType();
return _make(vt.type().$conn, values, ArrayType.of(vt.elementType), false);
}
$notify(keys) {
if (this.$onChange && keys.length > 0) {
this.$callOnChange(keys.map(k => '[' + _quote(k) + ']'));
}
}
get $onChange() {
return this.$private.onChange;
}
set $onChange(cb) {
if (typeof cb === 'function') {
this.$private.onChange = cb;
} else {
delete this.$private.onChange;
}
}
$callOnChange(changed) {
if (this.$onChange && !this.$private.recurse) {
this.$private.recurse = true;
try {
this.$onChange.call(this, changed);
} finally {
delete this.$private.recurse;
}
}
}
get $parentObj() {
return this.$private.parentObj;
}
set $parentObj(value) {
if (value === null) {
value = undefined;
}
if (this.$private.parentObj !== value) {
this.$private.parentObj = value;
if (!this.$noReparent) {
for (const e of this) {
if (_isMutable(e)) {
e.$parentObj = value;
}
}
}
}
}
$register(key, e) {
if (_isMutable(e)) {
if (!this.$noReparent) {
e.$parentObj = this.$parentObj;
}
if (e.$onChange == null || e.$onChange.$owner !== this) {
const map = this;
let f = function (childChanged) {
if (map.get(key) === e) {
map.$callOnChange(childChanged.map(childPath => {
let path = '[' + _quote(String(key), '"') + ']';
if (childPath != null && childPath !== '') {
if (childPath[0] != '[') {
path += '.';
}
path += childPath;
}
return path;
}));
}
};
Object.defineProperty(f, '$owner', { value: this });
e.$onChange = f;
}
}
}
$unregister(e) {
if (_isMutable(e)) {
if (e.$parentObj === this.$parentObj && !this.$noReparent) {
e.$parentObj = null;
}
if (e.$onChange && e.$onChange.$owner === this) {
e.$onChange = null;
}
}
}
}
$protos.MutableMap = MutableMap;
function _map(conn, vt, mutable, data) {
let fromMap;
if (data instanceof Map) {
fromMap = data;
} else {
fromMap = new Map();
if (Array.isArray(data)) {
for (let i = 0; i < data.length; i++) {
fromMap.set(i, data[i]);
}
} else if (data != null && typeof data === 'object') {
Object.keys(data).forEach(p => {
fromMap.set(p, data[p]);
});
}
}
let made;
if (mutable) {
made = new MutableMap(vt);
} else {
made = new ImmutableMap(vt);
}
_setupColl(made, 'Map', vt);
for (let [k, v] of fromMap) {
Map.prototype.set.call(made,
k = _make(conn, k, vt.keyType, false),
v = _make(conn, v, vt.elementType, mutable));
if (mutable) {
made.$register(k, v);
}
}
return made;
}
class MakingStream extends StreamBase {
constructor(vt, values) {
super(vt);
this.$private.values = values || [];
this.$private.index = 0;
this.$private.hasNext = () => this.$private.index < this.$private.values.length;
this.$private.next = () => {
const vt = this.collectionType().elementType;
const made = _make(vt.type().$conn, this.$private.values[this.$private.index], vt);
this.$private.index++;
return made;
};
}
get size() {
this.doClose();
return this.$private.values.length;
}
}
class IteratorStream extends StreamBase {
constructor(vt, hasNext, next, close) {
super(vt);
this.$private.hasNext = hasNext;
this.$private.next = next;
this.$private.close = close;
}
}
function _stream(conn, vt, mutable, data) {
let made;
if (data instanceof Array) {
made = new MakingStream(vt, data);
} else if (data instanceof Object && typeof data.hasNext === 'function' && typeof data.next === 'function') {
made = new IteratorStream(vt,
data.hasNext.bind(data), data.next.bind(data),
typeof data.close === 'function' ? data.close.bind(data) : undefined);
} else {
made = new IteratorStream(vt, () => false, () => undefined);
}
_setupColl(made, 'Stream', vt);
return made;
}
function _cached(typeName, method, impl) {
const dfltVal = method.cachedKey == 'arg' ? method.mergeOverloads.params[0].default : null;
let f;
if (method.cachedKey == 'arg' && method.cachedFailIfMissing) {
f = function (key, failIfMissing) {
let secondary = this.$cache.get(method.name, false, () => new SimpleCache(typeName, method.name, dfltVal));
return secondary.get(key, failIfMissing, () => impl.call(this, key, false));
};
} else if (method.cachedKey == 'arg' && method.cachedReturnNullIfNotCached) {
f = function (key, returnNullIfNotCached) {
let secondary = this.$cache.get(method.name, false, () => new SimpleCache(typeName, method.name, dfltVal));
return secondary.get(key, false, () => returnNullIfNotCached ? null : impl.call(this, key, false), true);
};
} else if (method.cachedKey == 'arg') {
f = function (key) {
let secondary = this.$cache.get(method.name, false, () => new SimpleCache(typeName, method.name, dfltVal));
return secondary.get(key, false, () => impl.call(this, key));
};
} else if (method.cacheFailIfMissing) {
f = function (failIfMissing) {
return this.$cache.get(method.name, failIfMissing, () => impl.call(this, false));
};
} else if (method.cachedReturnNullIfNotCached) {
f = function (returnNullIfNotCached) {
return this.$cache.get(method.name, false, () => returnNullIfNotCached ? null : impl.call(this, false), true);
};
} else {
f = function () {
return this.$cache.get(method.name, false, () => impl.call(this));
};
}
Object.defineProperties(f, {
$impl: { value: impl.$impl || impl },
$wrapped: { value: impl },
});
return f;
}
function _setupInst(inst, type) {
if (!_hasOwnProperty(inst, '$cache')) {
Object.defineProperty(inst, '$cache', { value: new SimpleCache(type.name(), 'this') });
Object.defineProperty(inst, '$chain', { value: [type] });
if (type.$loaded.$mutable) {
Object.defineProperty(inst, '$mutable', { value: true });
}
}
if (!_hasOwnProperty(inst, '$parent') &&
(type.name() === 'FieldType' || type.name() === 'Method' ||
type.name() === 'MethodType' || type.name() === 'TypeDefaultUiField')) {
var parent;
Object.defineProperty(inst, '$parent', { get: () => parent, set: v => { parent = v; } });
}
}
function _setupColl(inst, typeName, vt) {
if (!_hasOwnProperty(inst, '$cache')) {
Object.defineProperty(inst, '$cache', { value: new SimpleCache(typeName, 'this') });
}
Object.defineProperty(inst, '$c3coll', { value: true });
}
function _hasOwnProperty(object, property) {
if (object == null) {
return false;
}
return Object.prototype.hasOwnProperty.call(object, property);
}
function _isMutable(e) {
return e != null && !e.$c3type && e.$mutable;
}
function _connReqWithJsonAuthzAndActionEngineHeaders(conn, method, path) {
return conn.request(method, path).withJsonHeaders().withActionEngineHeader().withAuthHeader(conn.$authz);
}
function _quote(s) {
if (s == null) return s;
return '"' + s.replace(/\\/g, '\\\\').replace(/"/g, '\\"') + '"';
}
function _serializeArg(arg) {
if (typeof arg === 'function') {
return Lambda.fromJsFunc(arg);
} else if (typeof arg === 'number' && !isFinite(arg)) {
return { type: 'Boxed<double>', value: String(arg) };
} else if (arg instanceof ArrayBuffer || ArrayBuffer.isView(arg)) {
return { type: 'Boxed<binary>', value: Base64.encode(arg) };
}
if (typeof arg === 'object' && arg !== null && typeof arg.toTypedJson === 'function') {
return arg.toTypedJson();
}
return arg;
}
function _boxThis(type, inst) {
if (inst == null)
return null;
if ((type.$init.isGeneric || type.$init.hasVarBindings) && !type.$init.isObj && inst.$c3coll) {
return inst.collectionType().valueToTypedJson(inst);
}
if (type.$init.mixins && type.$init.mixins.indexOf('WithRef') >= 0 &&
typeof inst.toRef === 'function' && !inst.toRef.$delegate) {
return inst.toRef();
}
return inst;
}
const http = require('http');
const https = require('https');
const { Readable } = require('stream');
var EventSource = require('eventsource');
function _readableStream(req, onData, onErr) {
return new Promise(async function (resolve, reject) {
class ReadableStream extends Readable {
constructor(options) {
super(options);
let self = this;
const req_ = (req.url.startsWith('https') ? https : http).request(
req.url,
{
method: 'POST',
headers: Object.fromEntries(req.allHeadersMerged()),
body: req.encodedBody,
},
function (res) {
res.on('data', chunk => {
onData(chunk).forEach(value => {
self.push({
value: value
});
})
});
res.on('end', () => {
self.push(null)
});
}
);
req_.on('error', e => {
self.push(null);
onErr(e);
});
req.entity && req_.write(req.entity);
req_.end();
}
_read() {
}
}
resolve(new ReadableStream({ objectMode: true }));
})
}
function TypeSystem(conn) {
if (conn == null)
throw new Error("TypeSystem: must pass server connection instance to constructor");
Object.defineProperties(this, {
$conn: { value: conn },
$cache: { value: {}, configurable: true },
$imported: { value: undefined, configurable: true },
$trackTypeChanges: { value: undefined, configurable: true },
_make: { value: function(data, vt, mutableParent) { return _make(this.$conn, data, vt, mutableParent); } },
_setupInst: { value: _setupInst },
});
}
if (typeof $protos === 'object') {
Object.defineProperty(TypeSystem, '$protos', { value: $protos });
}
TypeSystem.prototype._implementC3 = _implementC3;
function type(name, failIfMissing) {
const cache = this.$cache;
if (cache.hasOwnProperty(name)) {
let t = cache[name];
if (t == null && failIfMissing)
throw new Error('Unknown type "' + name + '".');
else
return t;
}
if (this.typeNames(true).indexOf(name) >= 0)
return cache[name] = _typeProxy(this, name);
let t = this.$conn._loadType(name, failIfMissing);
if (t == null) {
cache[name] = null;
return;
}
return cache[name] = _typeProxy(this, name, t);
}
function call(typeName, methodName, ...args) {
const conn = this.connection();
if (conn.$noRemote)
throw new Error(`Remoting calling disabled (${typeName}.${methodName}).`);
let type = this.type(typeName, true);
if (args != null && args[0] != null) {
if (args[0].$c3inst)
type = args[0].$c3inst;
else if (args[0].$c3coll)
type = args[0].type();
}
const method = type.$init.methods && type.$init.methods.filter(m => m.name == methodName)[0];
if (methodName === "toJson" || methodName === "toTypedJson")
throw new Error(`Cannot remote call to ${methodName} for ${typeName}`);
let req = _connReqWithJsonAuthzAndActionEngineHeaders(conn, 'POST', conn.callUrl(typeName, methodName));
if (args != null && args.length > 0) {
args[0] = _boxThis(type, args[0]);
for (let i = 0; i < args.length; i++) {
args[i] = _serializeArg(args[i]);
}
req = req.withBodyString(JSON.stringify(args, (k, v) => typeof v === 'bigint' ? v.toString() : v));
}
if (method && method.mergedReturnType) {
if (_hasEventStream(this, method.mergedReturnType)) {
if (conn.$clientId == undefined) {
Object.defineProperty(conn, '$clientId', {value: '' + Math.floor(Math.random() * 10 ** 17)});
}
req = req.withHeader(this.type('HttpHeaderName').CLIENT_ID, conn.$clientId);
let resp = _makeCallResponse(conn, type, methodName, req.sendSync(), method);
let sse = _sseClient(conn);
_cacheEventStreams(sse, Val.eventStreams(resp));
return resp;
}
}
let rsp = req.sendSync();
return _makeCallResponse(conn, type, methodName, rsp, method);
}
function _cacheEventStreams(sse, eventStreams) {
for (let i = 0; i < eventStreams.length; i++) {
let stream = eventStreams[i];
let id = stream.id;
if (!sse.$eventStreams.has(id)) {
sse.$eventStreams.set(id, stream);
} else {
throw Err.objectAlreadyExists('EventStream with id (' + id + ')');
}
}
}
function _hasEventStream(ths, returnType) {
return returnType.type == 'EventStreamType' || (ths.type != null && returnType.type == 'ReferenceType' && ths.type(returnType.name).$init.hasEventStream);
}
function _sseOnError(e, conn) {
console.error("SSE: received error: " + JSON.stringify(e));
if (conn.$sse.reconnectAttempts > 3) {
conn.$sse.close();
console.error("Max re-connect trial limit has been reached. SSE closed now!");
} else {
conn.$sse.reconnectAttempts = conn.$sse.reconnectAttempts + 1;
}
}
function _sseClient(conn) {
if (conn.$sse == null) {
const sseEndpoint = conn.$url + '/sse/8/' + conn.$clientId;
if (typeof EventSource !== 'function') {
throw Err.unsupportedForActionEngine("Server-sent events", C3.context().actionEngine.name);
}
const headers = {
Connection: "keep-alive",
...(conn.$authz ? { Authorization: conn.$authz } : {}),
...(_requestPing() ? { 'X-C3-SSE-Send-Ping': true } : {}),
};
const eventSource = new EventSource(sseEndpoint, {headers: headers});
Object.defineProperty(conn, '$sse', { value: eventSource, writable: true});
Object.defineProperty(conn.$sse, '$eventStreams', { value: new Map() });
conn.$sse.addEventListener('stream-close', e => _handleEventStreamClose(conn, e));
conn.$sse.addEventListener('stream-event', e => _handleEventStreamEvent(conn, e));
const resetSse = () => {
let eventStreams = Array.from(conn.$sse?.$eventStreams.values() || []);
conn.$sse?.close();
Object.defineProperty(conn, '$sse', { value: null, writable: true });
_sseClient(conn);
_cacheEventStreams(conn.$sse, eventStreams);
console.log("resetting SSE channel");
};
if (conn.$resetSse == null) {
Object.defineProperty(conn, '$resetSse', { value: resetSse, writable: true });
}
Object.defineProperty(conn.$sse, 'reconnectAttempts', { value: 0, writable: true });
conn.$sse.onerror = err => _sseOnError(err, conn);
_listenPing(conn.$sse, resetSse);
}
return conn.$sse;
}
function _handleEventStreamClose(conn, e) {
let eventStreamId = _eventStreamIdFromEvent(e);
conn.$sse.$eventStreams.delete(eventStreamId);
if (!conn.$sse.$eventStreams.size > 0) {
conn.$sse.close();
Object.defineProperty(conn, '$sse', {value: null, writable: true});
}
}
function _eventStreamIdFromEvent(e) {
return e.lastEventId.split("_")[0];
}
function _payloadFromEvent(conn, data, eventType) {
return _make(conn, JSON.parse(data), eventType, false);
}
function _handleEventStreamEvent(conn, e) {
let eventStreamId = _eventStreamIdFromEvent(e);
let eventStream = conn.$sse.$eventStreams.get(eventStreamId);
let eventType = eventStream.eventType();
for (let data of e.data.split("\n")) {
let payload = _payloadFromEvent(conn, data, eventType);
if (eventStream.$onNext) {
eventStream.$onNext(payload);
} else {
console.error(`Error: EventStream (id: ${eventStream.id}) doesn't have event handler.`);
}
}
}
function typeNames(includeInnerTypes) {
if (this.$names == null) {
let req = _connReqWithJsonAuthzAndActionEngineHeaders(this.connection(), 'GET', '/typesys/8/names.json?includeInnerTypes');
let rsp = req.sendSync();
Object.defineProperty(this, '$names', { value: Object.freeze(rsp.json()), configurable: true });
}
return _filterTypeNames(this.$names, includeInnerTypes);
}
function _implementC3(C3) {
C3.pkg = function() { return this.$pkg != null ? this.$pkg : this.$pkg = this.Pkg.inst(); };
C3.type = this.type.bind(this);
C3.$typesystem = this;
C3.typeSystem = function() { return this.$typesystem; };
C3.rnd = function() { return this.$rnd != null ? this.$rnd : this.$rnd = this.Rnd.make(); };
C3.logger = function(name) { return this.Logger.for(name); };
C3.context = function() { return this.$context != null ? this.$context : this.$context = this.Context.inst(); };
C3.env = function() { return this.context()?.env; };
C3.app = function() { return this.context()?.app; };
C3.cluster = function() { return this.$cls != null ? this.$cls : this.$cls = this.Cluster.inst(); };
C3.action = function() { return Ctx.currentAction(); };
if (!C3.performance) {
Object.defineProperty(C3, 'performance', {
get: function() {
if (typeof window === 'object')
return window.performance;
if (typeof module === 'object')
return require('perf_hooks').performance;
},
enumerable: true,
configurable: true,
});
}
}
function importTypes(scope) {
if (typeof scope.type === 'undefined') {
scope.type = this.type.bind(this);
}
this._implementC3(scope.C3);
Object.getOwnPropertyNames(scope).forEach(name => {
if (/^webkit/.test(name) || name.startsWith('_'))
return;
if (scope[name] && scope[name]['$c3type'])
delete scope[name];
if (scope.C3 === C3 && C3[name] && C3[name]['$c3type'])
delete scope.C3[name];
});
let map = {};
this.typeNames().forEach(name => {
let type = this.type(name);
if (typeof scope[name] === 'undefined')
scope[name] = type;
if (scope.C3 === C3)
scope.C3[name] = type;
map[name] = type;
});
['Val', 'Str', 'Bin', 'Num', 'DateTime', 'ExpressionEngineFunction'].forEach(name => {
let type = this.type(name);
if (typeof scope[name] === 'undefined')
scope[name] = type;
if (scope.C3 === C3)
scope.C3[name] = type;
map[name] = type;
});
Object.defineProperty(this, '$imported', { value: scope, configurable: true });
return map;
}
function _removeTypeDefinitions(o) {
Object.keys(o).forEach(key => {
if (o[key] && Object.hasOwn(o[key], '$c3type')) {
delete o[key];
}
});
}
function _resetC3(c3) {
_removeTypeDefinitions(c3);
delete c3.pkg;
delete c3.$pkg;
delete c3.type;
delete c3.typeSystem;
delete c3.$$typesystem;
delete c3.rnd;
delete c3.$rnd;
delete c3.logger;
delete c3.$context;
delete c3.context;
delete c3.env;
delete c3.app;
delete c3.$cls;
delete c3.cluster;
delete c3.action;
delete c3.performance;
}
function clearImports() {
if (this.$imported && this.$imported.C3.typeSystem() == this) {
_removeTypeDefinitions(this.$imported);
_resetC3(this.$imported.C3);
}
}
function _listenPing(sse, resetSse) {
let timeoutInterval = null;
sse.addEventListener('ping', e => {
timeoutInterval && clearTimeout(timeoutInterval);
timeoutInterval = setTimeout(resetSse, 1000 * 20);
})
}
function _requestPing() {
return true;
}
let $logger;
function log() {
if ($logger == null) {
$logger = C3.Logger.for($type.name());
}
return $logger;
};
const $type = TypeSystem;
$type.__proto__ = Type$Proto;
Type$Proto.call($type, $conn, $init);
const $proto = new (function TypeSystem() {});
Object.defineProperty($proto, '$conn', { value: $conn });
Object.defineProperties($type, {
$objProto: { value: $proto }
});
Object.defineProperty($type, Symbol.hasInstance, { value: function(inst) { return inst != null && inst.$c3inst && inst.$c3inst.meta().isA(this); } });
$type.prototype.cacheContainsType = cacheContainsType;
$proto.cacheContainsType = cacheContainsType;
$type.prototype.connection = connection;
$proto.connection = connection;
$type.prototype.c3 = c3;
$proto.c3 = c3;
$type.prototype.trackTypeChanges = trackTypeChanges;
$proto.trackTypeChanges = trackTypeChanges;
$type.prototype.call = call;
$proto.call = call;
$type.prototype.importTypes = importTypes;
$proto.importTypes = importTypes;
$type.prototype.callRequest = callRequest;
$proto.callRequest = callRequest;
$type.prototype.type = type;
$proto.type = type;
$type.prototype.sync = sync;
$proto.sync = sync;
$type.prototype.clearCache = clearCache;
$proto.clearCache = clearCache;
$type.prototype.typeNames = typeNames;
$proto.typeNames = typeNames;
$type.prototype.async = async;
$proto.async = async;
$type.prototype.clearImports = clearImports;
$proto.clearImports = clearImports;
$type._instantiate = function _instantiate(...args) {
let inst = Object.create(this.$objProto);
const r = TypeSystem.apply(inst, args);
if (typeof this.$setupInst === 'function') {
this.$setupInst(inst);
}
return r ?? inst;
};
$type.prototype.log = log;
$proto.log = log;
$proto.toJSON = function toJSON() { return '$value' in this ? this.$value : null; };
Object.freeze($type);
Object.freeze($proto);
return $type;
})());
$conn._registerType((function() {
const $init = _deepFreeze({
"type" : "TypeMeta",
"metadataPath" : "platform/src/remote/TypeSystemBase.c3typ",
"package" : "platform",
"packageSubPath" : "remote",
"name" : "TypeSystemBase",
"doc" : "Base type for a C3 Remote full type system. This is extended by synchronous and asynchronous versions.\n\nThe \"full\" type system is distinguished from the {@link ThinTypeSystemBase thin type system} by the fact that\nvalues have the full C3 semantics and Obj instances expose the declared methods directly.",
"declaredAbstract" : true,
"declaredInline" : true,
"declaredMixinRefTypes" : [ {
"name" : "Value"
} ],
"declaredFieldTypes" : [ {
"doc" : "Get a full type by name.",
"name" : "type",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "AnyType"
},
"abstract" : true,
"member" : true
}
}, {
"doc" : "Get a synchronous instance of the full type system for this connection. If this instance is a synchronous version,\nthe same value is returned.\n\n@return instance of this type system that dispatches actions in a synchronous manner",
"name" : "sync",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeSystem"
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Get an asynchronous instance of the full type system for this connection. If this instance is an asynchronous\nversion, the same value is returned.\n\n@return instance of this type system that dispatches actions in an asynchronous manner using Promise",
"name" : "async",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "AsyncTypeSystem"
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"annotationsJson" : [ {
"call" : [ {
"name" : "stayInEngine",
"value" : {
"py" : "true"
}
} ]
} ],
"doc" : "Get the connection on which this type system operates.\n\n@return server connection",
"name" : "connection",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerConnection"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"annotationsJson" : [ {
"call" : [ {
"name" : "stayInEngine",
"value" : true
} ]
} ],
"doc" : "When no argument is provided, discard all cached metadata on this connection. When a typename is specified,\nremove cached metadata for the given type, and all sub types that mixes this type. This is typically used in\nclient SDKs to refresh cache for updated types. Note that existing instances will still continue to use the old\ntypes, but references to types through this type system itself will reload after this call.\n\n@param typeName specific type to clear or null for all\n@param reimport if true, re-import single type if `importTypes` was called",
"name" : "clearCache",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"name" : "reimport",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "True if the type with the given typeName is cached in TypeSystem.",
"name" : "cacheContainsType",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Returns a native c3 \"namespace object\". In general, this object has a field for each {@link Type} declared in\na given package. This object also has all fields and methods of any {@link GlobalProtocol} sub-type. In Python,\nthis method returns an object of the same type as the \"c3\" global variable. In JS, this method returns an object of\nthe same type as the \"C3\" variable.",
"name" : "c3",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"cached" : true,
"member" : true,
"actionRequirementNames" : [ "py", "js", "java" ]
}
}, {
"doc" : "Listens for changes occurring on the server and updates the local state as necessary. This is useful on development\nsystems (apps in `DEV` mode) where types are being actively developed.\n\n@param notify lambda called each time a type change is detected\n\n@see Pkg#listen",
"name" : "trackTypeChanges",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "notify",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "e",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg.Event"
}
} ]
}
} ],
"member" : true,
"actionRequirementNames" : [ "js-client" ]
}
}, {
"doc" : "Build a request instance usable for calling the specified method. The type and method name are required to form\nthe URL. The HTTP method will always be `POST`.\n\nIf any arguments are specified, the body of the request will be JSON and it will have the JSON-related\nheaders, including `Accept: application/json`. Otherwise, the request will have no body and `Accept: *\\/*`.\n\n@param type the name of the type on which to call the method\n@param action the name of the method to call\n@param args the arguments to pass, with `this` or the type name first\n@return the HTTP request to make this call",
"name" : "callRequest",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "action",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "args",
"valueType" : {
"type" : "AnyType"
},
"varArgs" : true
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
} ],
"isWithType" : false,
"isObj" : false,
"isMutable" : false,
"isStateful" : false,
"isSingleton" : false,
"isDefaultInstance" : false,
"isAbstract" : true,
"hasEventStream" : false,
"isGeneric" : false,
"isNativeRemix" : false,
"hasVarBindings" : false,
"prototypeName" : "TypeSystemBase",
"typeSerName" : "type",
"hasSerNameFields" : false,
"annotations" : {
"type" : "Annotations"
},
"mixins" : [ "Value" ],
"referenceType" : {
"type" : "ReferenceType",
"name" : "TypeSystemBase"
},
"mixinsWithSourceCode" : {
"js-ide-vscode-client-node" : [ ]
},
"methods" : [ {
"type" : "Method",
"name" : "type",
"hasAnyStatic" : false,
"hasAnyAbstract" : true,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "AnyType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : false,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get a full type by name.",
"name" : "type",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "AnyType"
},
"abstract" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "type",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "AnyType"
},
"paramNames" : [ "name", "failIfMissing" ]
}
}, {
"type" : "Method",
"name" : "sync",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeSystem"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeSystemBase" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeSystemBase"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get a synchronous instance of the full type system for this connection. If this instance is a synchronous version,\nthe same value is returned.\n\n@return instance of this type system that dispatches actions in a synchronous manner",
"name" : "sync",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeSystem"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "sync",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeSystem"
}
},
"$nearestImplementedOn" : "TypeSystemBase"
}, {
"type" : "Method",
"name" : "async",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "AsyncTypeSystem"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeSystemBase" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeSystemBase"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get an asynchronous instance of the full type system for this connection. If this instance is an asynchronous\nversion, the same value is returned.\n\n@return instance of this type system that dispatches actions in an asynchronous manner using Promise",
"name" : "async",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "AsyncTypeSystem"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "async",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "AsyncTypeSystem"
}
},
"$nearestImplementedOn" : "TypeSystemBase"
}, {
"type" : "Method",
"name" : "connection",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerConnection"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeSystemBase" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeSystemBase"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"call" : [ {
"name" : "stayInEngine",
"value" : {
"py" : "true"
}
} ]
} ],
"doc" : "Get the connection on which this type system operates.\n\n@return server connection",
"name" : "connection",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerConnection"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"call" : [ {
"name" : "stayInEngine",
"value" : {
"py" : "true"
}
} ]
} ],
"name" : "connection",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerConnection"
}
},
"$nearestImplementedOn" : "TypeSystemBase"
}, {
"type" : "Method",
"name" : "clearCache",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeSystemBase" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeSystemBase"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"call" : [ {
"name" : "stayInEngine",
"value" : true
} ]
} ],
"doc" : "When no argument is provided, discard all cached metadata on this connection. When a typename is specified,\nremove cached metadata for the given type, and all sub types that mixes this type. This is typically used in\nclient SDKs to refresh cache for updated types. Note that existing instances will still continue to use the old\ntypes, but references to types through this type system itself will reload after this call.\n\n@param typeName specific type to clear or null for all\n@param reimport if true, re-import single type if `importTypes` was called",
"name" : "clearCache",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"name" : "reimport",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"call" : [ {
"name" : "stayInEngine",
"value" : true
} ]
} ],
"name" : "clearCache",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"name" : "reimport",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"paramNames" : [ "typeName", "reimport" ]
},
"$nearestImplementedOn" : "TypeSystemBase"
}, {
"type" : "Method",
"name" : "cacheContainsType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeSystemBase" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeSystemBase"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "True if the type with the given typeName is cached in TypeSystem.",
"name" : "cacheContainsType",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "cacheContainsType",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "typeName" ]
},
"$nearestImplementedOn" : "TypeSystemBase"
}, {
"type" : "Method",
"name" : "c3",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeSystemBase" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeSystemBase"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns a native c3 \"namespace object\". In general, this object has a field for each {@link Type} declared in\na given package. This object also has all fields and methods of any {@link GlobalProtocol} sub-type. In Python,\nthis method returns an object of the same type as the \"c3\" global variable. In JS, this method returns an object of\nthe same type as the \"C3\" variable.",
"name" : "c3",
"returnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"cached" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "py", "js", "java" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "c3",
"returnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
}
},
"$nearestImplementedOn" : "TypeSystemBase"
}, {
"type" : "Method",
"name" : "trackTypeChanges",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeSystemBase" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeSystemBase"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Listens for changes occurring on the server and updates the local state as necessary. This is useful on development\nsystems (apps in `DEV` mode) where types are being actively developed.\n\n@param notify lambda called each time a type change is detected\n\n@see Pkg#listen",
"name" : "trackTypeChanges",
"params" : [ {
"name" : "notify",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "e",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg.Event"
}
} ]
}
} ],
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "js-client" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "trackTypeChanges",
"params" : [ {
"name" : "notify",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "e",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg.Event"
}
} ]
}
} ],
"paramNames" : [ "notify" ]
},
"$nearestImplementedOn" : "TypeSystemBase"
}, {
"type" : "Method",
"name" : "callRequest",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeSystemBase" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeSystemBase"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Build a request instance usable for calling the specified method. The type and method name are required to form\nthe URL. The HTTP method will always be `POST`.\n\nIf any arguments are specified, the body of the request will be JSON and it will have the JSON-related\nheaders, including `Accept: application/json`. Otherwise, the request will have no body and `Accept: *\\/*`.\n\n@param type the name of the type on which to call the method\n@param action the name of the method to call\n@param args the arguments to pass, with `this` or the type name first\n@return the HTTP request to make this call",
"name" : "callRequest",
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "action",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "args",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "callRequest",
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "action",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "args",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ServerRequest"
},
"paramNames" : [ "type", "action", "args" ]
},
"$nearestImplementedOn" : "TypeSystemBase"
} ],
"hasSourceCode" : {
"js-ide-vscode-client-node" : true
},
"fieldTypes" : [ ]
});
var $protos = {};
class ArrayBase extends Array {
constructor(vt) {
super(typeof vt === 'number' ? vt : 0);
if (new.target == ArrayBase) {
throw new TypeError('Cannot construct ArrayBase class directly.');
}
if (vt == null || typeof vt == 'number') {
vt = ArrayType.ofAny();
}
let box = { type: vt };
Object.defineProperty(this, '$private', { value: box });
}
collectionType() {
let vt = this.$private.type;
if (typeof vt.type === 'string') {
vt = ArrayType.make(vt);
this.$private.type = vt;
}
return vt;
}
contains(e) {
return super.indexOf(e) >= 0;
}
elementType() {
return this.collectionType().elementType;
}
first(arg) {
if (typeof arg === 'number' && arg > 1) {
let vt = this.collectionType();
return _make(vt.type().$conn, super.slice(0, arg), vt, false);
} else if (typeof arg === 'function') {
return this.find(arg);
} else {
return this[0];
}
}
isEmpty() {
return this.length === 0;
}
get size() {
return this.length;
}
toJSON() {
return this.toJson();
}
_toJson(typed, omitTopLevelType) {
let toJsonFunc = typed ? 'valueToTypedJson' : 'valueToJson';
let vt = this.collectionType();
let et = vt.elementType;
let a = [];
this.forEach(e => a.push(et[toJsonFunc](e)));
return typed && !omitTopLevelType ? { type: this.type().toString(), value: a } : a;
}
toJson() {
return this._toJson(false);
}
toTypedJson(omitTopLevelType) {
return this._toJson(true, omitTopLevelType);
}
fromJson(json) {
_make(this.type().$conn, json, this.collectionType(), false);
}
type() {
return this.$cache.get('type', true, () => C3.Array.bindVar(this.elementType()));
}
*_iter() {
for (let e of this) {
yield e;
}
}
_build(...args) {
if (args.length == 1) {
return this.collectionType().buildArray(args[0]);
} else {
return ArrayType.of(args[0]).buildArray(args[1]);
}
}
_singleton(e) {
return this.collectionType().buildArray(b => b.add(e));
}
approxUniqueCount() {
return C3.Array.$objProto.approxUniqueCount.call(this);
}
approxMedian(...args) {
return C3.Array.$objProto.approxMedian.call(this, ...args);
}
approxHistogram(...args) {
return C3.Array.$objProto.approxHistogram.call(this, ...args);
}
truePercent() {
return C3.Array.$objProto.truePercent.call(this);
}
nullCount() {
return C3.Array.$objProto.nullCount.call(this);
}
toJsonString() {
return C3.Array.$objProto.toJsonString.call(this);
}
toTypedJsonString() {
return C3.Array.$objProto.toTypedJsonString.call(this);
}
toJsString() {
return C3.Array.$objProto.toJsString.call(this);
}
toXmlString() {
return C3.Array.$objProto.toXmlString.call(this);
}
serialize(...args) {
return C3.Array.$objProto.serialize.call(this, ...args);
}
toString(...args) {
return C3.Array.$objProto.toString.call(this, ...args);
}
fingerprint(...args) {
return C3.Array.$objProto.fingerprint.call(this, ...args);
}
retainedMemory(...args) {
return C3.Array.$objProto.retainedMemory.call(this, ...args);
}
elementAgg(...args) {
return C3.Array.$objProto.elementAgg.call(this, ...args);
}
elementAll(...args) {
return C3.Array.$objProto.elementAll.call(this, ...args);
}
elementAvg(...args) {
return C3.Array.$objProto.elementAvg.call(this, ...args);
}
elementCartesianProduct() {
return C3.Array.$objProto.elementCartesianProduct.call(this);
}
elementMin(...args) {
return C3.Array.$objProto.elementMin.call(this, ...args);
}
elementMax(...args) {
return C3.Array.$objProto.elementMax.call(this, ...args);
}
elementSum(...args) {
return C3.Array.$objProto.elementSum.call(this, ...args);
}
elementStddev(...args) {
return C3.Array.$objProto.elementStddev.call(this, ...args);
}
elementVariance(...args) {
return C3.Array.$objProto.elementVariance.call(this, ...args);
}
iter() {
return C3.Array.$objProto.iter.call(this);
}
_iter_() {
return C3.Array.$objProto._iter_.call(this);
}
_length_() {
return C3.Array.$objProto._length_.call(this);
}
collect(...args) {
return C3.Array.$objProto.collect.call(this, ...args);
}
collectArrays(...args) {
return C3.Array.$objProto.collectArrays.call(this, ...args);
}
abs() {
return C3.Array.$objProto.abs.call(this);
}
aggImplementation(...args) {
return C3.Array.$objProto.aggImplementation.call(this, ...args);
}
sumDbl() {
return C3.Array.$objProto.sumDbl.call(this);
}
sumDiff(...args) {
return C3.Array.$objProto.sumDiff.call(this, ...args);
}
cusum(...args) {
return C3.Array.$objProto.cusum.call(this, ...args);
}
normalize() {
return C3.Array.$objProto.normalize.call(this);
}
at(...args) {
return C3.Array.$objProto.at.call(this, ...args);
}
pluck(...args) {
return C3.Array.$objProto.pluck.call(this, ...args);
}
firstNotNull(...args) {
return C3.Array.$objProto.firstNotNull.call(this, ...args);
}
firstNotEmpty(...args) {
return C3.Array.$objProto.firstNotEmpty.call(this, ...args);
}
last(...args) {
return C3.Array.$objProto.last.call(this, ...args);
}
lastNotNull(...args) {
return C3.Array.$objProto.lastNotNull.call(this, ...args);
}
lastNotEmpty(...args) {
return C3.Array.$objProto.lastNotEmpty.call(this, ...args);
}
minImplementation(...args) {
return C3.Array.$objProto.minImplementation.call(this, ...args);
}
minBy(...args) {
return C3.Array.$objProto.minBy.call(this, ...args);
}
maxImplementation(...args) {
return C3.Array.$objProto.maxImplementation.call(this, ...args);
}
maxBy(...args) {
return C3.Array.$objProto.maxBy.call(this, ...args);
}
count(...args) {
return C3.Array.$objProto.count.call(this, ...args);
}
sumImplementation(...args) {
return C3.Array.$objProto.sumImplementation.call(this, ...args);
}
allImplementation(...args) {
return C3.Array.$objProto.allImplementation.call(this, ...args);
}
prod(...args) {
return C3.Array.$objProto.prod.call(this, ...args);
}
avg() {
return C3.Array.$objProto.avg.call(this);
}
avgDbl() {
return C3.Array.$objProto.avgDbl.call(this);
}
median() {
return C3.Array.$objProto.median.call(this);
}
medianDbl() {
return C3.Array.$objProto.medianDbl.call(this);
}
percentile(...args) {
return C3.Array.$objProto.percentile.call(this, ...args);
}
percentileDbl(...args) {
return C3.Array.$objProto.percentileDbl.call(this, ...args);
}
stddev() {
return C3.Array.$objProto.stddev.call(this);
}
stddevDbl() {
return C3.Array.$objProto.stddevDbl.call(this);
}
variance() {
return C3.Array.$objProto.variance.call(this);
}
varianceDbl() {
return C3.Array.$objProto.varianceDbl.call(this);
}
aggDbl(...args) {
return C3.Array.$objProto.aggDbl.call(this, ...args);
}
round(...args) {
return C3.Array.$objProto.round.call(this, ...args);
}
invert() {
return C3.Array.$objProto.invert.call(this);
}
isMissing() {
return C3.Array.$objProto.isMissing.call(this);
}
only(...args) {
return C3.Array.$objProto.only.call(this, ...args);
}
containsAll(...args) {
return C3.Array.$objProto.containsAll.call(this, ...args);
}
containsAny(...args) {
return C3.Array.$objProto.containsAny.call(this, ...args);
}
findAny(...args) {
return C3.Array.$objProto.findAny.call(this, ...args);
}
anyNotNull(...args) {
return C3.Array.$objProto.anyNotNull.call(this, ...args);
}
anyNotEmpty(...args) {
return C3.Array.$objProto.anyNotEmpty.call(this, ...args);
}
each(...args) {
C3.Array.$objProto.each.call(this, ...args);
}
eachWhile(...args) {
return C3.Array.$objProto.eachWhile.call(this, ...args);
}
mapToSame(...args) {
return C3.Array.$objProto.mapToSame.call(this, ...args);
}
map(...args) {
return C3.Array.$objProto.map.call(this, ...args);
}
mapToStr(...args) {
return C3.Array.$objProto.mapToStr.call(this, ...args);
}
mapTo(...args) {
return C3.Array.$objProto.mapTo.call(this, ...args);
}
flatMapToSame(...args) {
return C3.Array.$objProto.flatMapToSame.call(this, ...args);
}
flatMap(...args) {
return C3.Array.$objProto.flatMap.call(this, ...args);
}
flatMapTo(...args) {
return C3.Array.$objProto.flatMapTo.call(this, ...args);
}
flatMapRecursive(...args) {
return C3.Array.$objProto.flatMapRecursive.call(this, ...args);
}
fold(...args) {
return C3.Array.$objProto.fold.call(this, ...args);
}
compact() {
return C3.Array.$objProto.compact.call(this);
}
unique() {
return C3.Array.$objProto.unique.call(this);
}
uniqueBy(...args) {
return C3.Array.$objProto.uniqueBy.call(this, ...args);
}
fillMissingBy(...args) {
return C3.Array.$objProto.fillMissingBy.call(this, ...args);
}
fillMissing(...args) {
return C3.Array.$objProto.fillMissing.call(this, ...args);
}
fieldNames() {
return C3.Array.$objProto.fieldNames.call(this);
}
fieldValueType(...args) {
return C3.Array.$objProto.fieldValueType.call(this, ...args);
}
reject(...args) {
return C3.Array.$objProto.reject.call(this, ...args);
}
include(...args) {
return C3.Array.$objProto.include.call(this, ...args);
}
fieldSlice(...args) {
return C3.Array.$objProto.fieldSlice.call(this, ...args);
}
fieldSelect(...args) {
return C3.Array.$objProto.fieldSelect.call(this, ...args);
}
exclude(...args) {
return C3.Array.$objProto.exclude.call(this, ...args);
}
replaceByPredicate(...args) {
return C3.Array.$objProto.replaceByPredicate.call(this, ...args);
}
sorted(...args) {
return C3.Array.$objProto.sorted.call(this, ...args);
}
sortedBy(...args) {
return C3.Array.$objProto.sortedBy.call(this, ...args);
}
sortedIndex(...args) {
return C3.Array.$objProto.sortedIndex.call(this, ...args);
}
batch(...args) {
return C3.Array.$objProto.batch.call(this, ...args);
}
partition(...args) {
return C3.Array.$objProto.partition.call(this, ...args);
}
countBy(...args) {
return C3.Array.$objProto.countBy.call(this, ...args);
}
every(...args) {
return C3.Array.$objProto.every.call(this, ...args);
}
flatten(...args) {
return C3.Array.$objProto.flatten.call(this, ...args);
}
sample(...args) {
return C3.Array.$objProto.sample.call(this, ...args);
}
sliceByKey(...args) {
return C3.Array.$objProto.sliceByKey.call(this, ...args);
}
summarize(...args) {
return C3.Array.$objProto.summarize.call(this, ...args);
}
downsample(...args) {
return C3.Array.$objProto.downsample.call(this, ...args);
}
leastSquares() {
return C3.Array.$objProto.leastSquares.call(this);
}
rollingDiff(...args) {
return C3.Array.$objProto.rollingDiff.call(this, ...args);
}
pctChange(...args) {
return C3.Array.$objProto.pctChange.call(this, ...args);
}
binaryOp(...args) {
return C3.Array.$objProto.binaryOp.call(this, ...args);
}
unaryOp(...args) {
return C3.Array.$objProto.unaryOp.call(this, ...args);
}
shape() {
return C3.Array.$objProto.shape.call(this);
}
dimensionality() {
return C3.Array.$objProto.dimensionality.call(this);
}
toObj() {
return C3.Array.$objProto.toObj.call(this);
}
fetch(...args) {
return C3.Array.$objProto.fetch.call(this, ...args);
}
largest(...args) {
return C3.Array.$objProto.largest.call(this, ...args);
}
histogram(...args) {
return C3.Array.$objProto.histogram.call(this, ...args);
}
neg() {
return C3.Array.$objProto.neg.call(this);
}
describeImplementation(...args) {
return C3.Array.$objProto.describeImplementation.call(this, ...args);
}
and(...args) {
return C3.Array.$objProto.and.call(this, ...args);
}
approxMostFrequent(...args) {
return C3.Array.$objProto.approxMostFrequent.call(this, ...args);
}
or(...args) {
return C3.Array.$objProto.or.call(this, ...args);
}
timeseries(...args) {
return C3.Array.$objProto.timeseries.call(this, ...args);
}
stream() {
return C3.Array.$objProto.stream.call(this);
}
sub(...args) {
return C3.Array.$objProto.sub.call(this, ...args);
}
mul(...args) {
return C3.Array.$objProto.mul.call(this, ...args);
}
div(...args) {
return C3.Array.$objProto.div.call(this, ...args);
}
truediv(...args) {
return C3.Array.$objProto.truediv.call(this, ...args);
}
floordiv(...args) {
return C3.Array.$objProto.floordiv.call(this, ...args);
}
mod(...args) {
return C3.Array.$objProto.mod.call(this, ...args);
}
pow(...args) {
return C3.Array.$objProto.pow.call(this, ...args);
}
radd(...args) {
return C3.Array.$objProto.radd.call(this, ...args);
}
rsub(...args) {
return C3.Array.$objProto.rsub.call(this, ...args);
}
rmul(...args) {
return C3.Array.$objProto.rmul.call(this, ...args);
}
rdiv(...args) {
return C3.Array.$objProto.rdiv.call(this, ...args);
}
rtruediv(...args) {
return C3.Array.$objProto.rtruediv.call(this, ...args);
}
rfloordiv(...args) {
return C3.Array.$objProto.rfloordiv.call(this, ...args);
}
rmod(...args) {
return C3.Array.$objProto.rmod.call(this, ...args);
}
rpow(...args) {
return C3.Array.$objProto.rpow.call(this, ...args);
}
eq(...args) {
return C3.Array.$objProto.eq.call(this, ...args);
}
gt(...args) {
return C3.Array.$objProto.gt.call(this, ...args);
}
ge(...args) {
return C3.Array.$objProto.ge.call(this, ...args);
}
lt(...args) {
return C3.Array.$objProto.lt.call(this, ...args);
}
le(...args) {
return C3.Array.$objProto.le.call(this, ...args);
}
ne(...args) {
return C3.Array.$objProto.ne.call(this, ...args);
}
replaceType(...args) {
return C3.Array.$objProto.replaceType.call(this, ...args);
}
super(...args) {
return C3.Array.$objProto.super.call(this, ...args);
}
zip(...args) {
return C3.Array.$objProto.zip.call(this, ...args);
}
valueType() {
return C3.Array.$objProto.valueType.call(this);
}
toNative(...args) {
return C3.Array.$objProto.toNative.call(this, ...args);
}
validated() {
return C3.Array.$objProto.validated.call(this);
}
inferType() {
return C3.Array.$objProto.inferType.call(this);
}
hasNullElements() {
return C3.Array.$objProto.hasNullElements.call(this);
}
isSame(...args) {
return C3.Array.$objProto.isSame.call(this, ...args);
}
hasSameElements(...args) {
return C3.Array.$objProto.hasSameElements.call(this, ...args);
}
isUnique() {
return C3.Array.$objProto.isUnique.call(this);
}
isSorted() {
return C3.Array.$objProto.isSorted.call(this);
}
isIndexed() {
return C3.Array.$objProto.isIndexed.call(this);
}
indices() {
return C3.Array.$objProto.indices.call(this);
}
indexOf(...args) {
return C3.Array.$objProto.indexOf.call(this, ...args);
}
indexOfAny(...args) {
return C3.Array.$objProto.indexOfAny.call(this, ...args);
}
lastIndexOf(...args) {
return C3.Array.$objProto.lastIndexOf.call(this, ...args);
}
lastIndexOfAny(...args) {
return C3.Array.$objProto.lastIndexOfAny.call(this, ...args);
}
min(...args) {
return C3.Array.$objProto.min.call(this, ...args);
}
max(...args) {
return C3.Array.$objProto.max.call(this, ...args);
}
sum(...args) {
return C3.Array.$objProto.sum.call(this, ...args);
}
all(...args) {
return C3.Array.$objProto.all.call(this, ...args);
}
agg(...args) {
return C3.Array.$objProto.agg.call(this, ...args);
}
toArray(...args) {
return C3.Array.$objProto.toArray.call(this, ...args);
}
toSet(...args) {
return C3.Array.$objProto.toSet.call(this, ...args);
}
toStream(...args) {
return C3.Array.$objProto.toStream.call(this, ...args);
}
toMap(...args) {
return C3.Array.$objProto.toMap.call(this, ...args);
}
toMapOf(...args) {
return C3.Array.$objProto.toMapOf.call(this, ...args);
}
toMapOfAny(...args) {
return C3.Array.$objProto.toMapOfAny.call(this, ...args);
}
toMapOfType(...args) {
return C3.Array.$objProto.toMapOfType.call(this, ...args);
}
toCollection(...args) {
return C3.Array.$objProto.toCollection.call(this, ...args);
}
toMixingCollection(...args) {
return C3.Array.$objProto.toMixingCollection.call(this, ...args);
}
toCollectionOfType(...args) {
return C3.Array.$objProto.toCollectionOfType.call(this, ...args);
}
toInMemory() {
return C3.Array.$objProto.toInMemory.call(this);
}
box() {
return C3.Array.$objProto.box.call(this);
}
boxElements() {
return C3.Array.$objProto.boxElements.call(this);
}
anonymize(...args) {
return C3.Array.$objProto.anonymize.call(this, ...args);
}
descriptiveStatistics() {
return C3.Array.$objProto.descriptiveStatistics.call(this);
}
withoutOutliers(...args) {
return C3.Array.$objProto.withoutOutliers.call(this, ...args);
}
extractOutliers(...args) {
return C3.Array.$objProto.extractOutliers.call(this, ...args);
}
isOutlier(...args) {
return C3.Array.$objProto.isOutlier.call(this, ...args);
}
with(...args) {
return C3.Array.$objProto.with.call(this, ...args);
}
withSome(...args) {
return C3.Array.$objProto.withSome.call(this, ...args);
}
withAll(...args) {
return C3.Array.$objProto.withAll.call(this, ...args);
}
without(...args) {
return C3.Array.$objProto.without.call(this, ...args);
}
withoutSome(...args) {
return C3.Array.$objProto.withoutSome.call(this, ...args);
}
withoutAny(...args) {
return C3.Array.$objProto.withoutAny.call(this, ...args);
}
withoutAll(...args) {
return C3.Array.$objProto.withoutAll.call(this, ...args);
}
difference(...args) {
return C3.Array.$objProto.difference.call(this, ...args);
}
unzip() {
return C3.Array.$objProto.unzip.call(this);
}
mergeSimilar(...args) {
return C3.Array.$objProto.mergeSimilar.call(this, ...args);
}
mergeChildren(...args) {
return C3.Array.$objProto.mergeChildren.call(this, ...args);
}
visit(...args) {
return C3.Array.$objProto.visit.call(this, ...args);
}
withDefaults(...args) {
return C3.Array.$objProto.withDefaults.call(this, ...args);
}
evalTimeseries(...args) {
return C3.Array.$objProto.evalTimeseries.call(this, ...args);
}
groupBy(...args) {
return C3.Array.$objProto.groupBy.call(this, ...args);
}
resample(...args) {
return C3.Array.$objProto.resample.call(this, ...args);
}
rolling(...args) {
return C3.Array.$objProto.rolling.call(this, ...args);
}
_item_(...args) {
return C3.Array.$objProto._item_.call(this, ...args);
}
toData() {
return C3.Array.$objProto.toData.call(this);
}
replace(...args) {
return C3.Array.$objProto.replace.call(this, ...args);
}
initial(...args) {
return C3.Array.$objProto.initial.call(this, ...args);
}
pairs() {
return C3.Array.$objProto.pairs.call(this);
}
isCompressed() {
return C3.Array.$objProto.isCompressed.call(this);
}
compress() {
return C3.Array.$objProto.compress.call(this);
}
uncompress() {
return C3.Array.$objProto.uncompress.call(this);
}
isPacked() {
return C3.Array.$objProto.isPacked.call(this);
}
pack() {
return C3.Array.$objProto.pack.call(this);
}
unpack() {
return C3.Array.$objProto.unpack.call(this);
}
reversed() {
return C3.Array.$objProto.reversed.call(this);
}
withIfMissing(...args) {
return C3.Array.$objProto.withIfMissing.call(this, ...args);
}
get(...args) {
return C3.Array.$objProto.get.call(this, ...args);
}
insertAt(...args) {
return C3.Array.$objProto.insertAt.call(this, ...args);
}
removeAt(...args) {
return C3.Array.$objProto.removeAt.call(this, ...args);
}
shuffle() {
return C3.Array.$objProto.shuffle.call(this);
}
permute() {
return C3.Array.$objProto.permute.call(this);
}
toBuilder() {
return C3.Array.$objProto.toBuilder.call(this);
}
withFirst(...args) {
return C3.Array.$objProto.withFirst.call(this, ...args);
}
withoutFirst() {
return C3.Array.$objProto.withoutFirst.call(this);
}
withoutLast() {
return C3.Array.$objProto.withoutLast.call(this);
}
withFill(...args) {
return C3.Array.$objProto.withFill.call(this, ...args);
}
withSplice(...args) {
return C3.Array.$objProto.withSplice.call(this, ...args);
}
boolArray() {
return C3.Array.$objProto.boolArray.call(this);
}
doubleArray() {
return C3.Array.$objProto.doubleArray.call(this);
}
floatArray() {
return C3.Array.$objProto.floatArray.call(this);
}
intArray() {
return C3.Array.$objProto.intArray.call(this);
}
int16Array() {
return C3.Array.$objProto.int16Array.call(this);
}
int32Array() {
return C3.Array.$objProto.int32Array.call(this);
}
byteArray() {
return C3.Array.$objProto.byteArray.call(this);
}
boolAt(...args) {
return C3.Array.$objProto.boolAt.call(this, ...args);
}
doubleAt(...args) {
return C3.Array.$objProto.doubleAt.call(this, ...args);
}
floatAt(...args) {
return C3.Array.$objProto.floatAt.call(this, ...args);
}
intAt(...args) {
return C3.Array.$objProto.intAt.call(this, ...args);
}
int16At(...args) {
return C3.Array.$objProto.int16At.call(this, ...args);
}
int32At(...args) {
return C3.Array.$objProto.int32At.call(this, ...args);
}
byteAt(...args) {
return C3.Array.$objProto.byteAt.call(this, ...args);
}
atOf(...args) {
return C3.Array.$objProto.atOf.call(this, ...args);
}
}
$protos.ArrayBase = ArrayBase;
class SetBase extends Set {
constructor(vt) {
super();
if (new.target == SetBase) {
throw new TypeError('Cannot construct SetBase class directly.');
}
let box = { type: vt };
Object.defineProperty(this, '$private', { value: box });
}
collectionType() {
let vt = this.$private.type;
if (typeof vt.type === 'string') {
vt = SetType.make(vt);
this.$private.type = vt;
}
return vt;
}
contains(e) {
return super.has(e);
}
elementType() {
return this.collectionType().elementType;
}
first(arg) {
if (typeof arg === 'number') {
let array = [];
let i = 0;
for (const e of this) {
if (i >= arg) {
break;
}
array.push(e);
i++;
}
return array;
} else if (typeof arg === 'function') {
for (const e of this) {
if (arg.call(undefined, e)) {
return e;
}
}
} else {
for (const e of this) {
return e;
}
}
}
get(index) {
let i = 0;
for (const value of this) {
if (index === i) {
return value;
}
i++;
}
}
isEmpty() {
return super.size === 0;
}
get size() {
return super.size;
}
toJSON() {
return this.toJson();
}
type() {
return this.$cache.get('type', true, () => C3.Set.bindVar(this.elementType()));
}
_toJson(typed, omitTopLevelType) {
let toJsonFunc = typed ? 'valueToTypedJson' : 'valueToJson';
let vt = this.collectionType();
let et = vt.elementType;
let a = [];
this.forEach(e => a.push(et[toJsonFunc](e)));
return typed && !omitTopLevelType ? { type: this.type().toString(), value: a } : a;
}
toJson() {
return this._toJson(false);
}
toTypedJson(omitTopLevelType) {
return this._toJson(true, omitTopLevelType);
}
fromJson(json) {
_make(this.type().$conn, json, this.collectionType(), false);
}
*_iter() {
for (let e of this)
yield e;
}
_build(...args) {
if (args.length == 1) {
return this.collectionType().buildSet(args[0]);
} else {
return SetType.of(args[0]).buildSet(args[1]);
}
}
_singleton(e) {
return this.collectionType().buildSet(b => b.add(e));
}
approxUniqueCount() {
return C3.Set.$objProto.approxUniqueCount.call(this);
}
approxMedian(...args) {
return C3.Set.$objProto.approxMedian.call(this, ...args);
}
approxHistogram(...args) {
return C3.Set.$objProto.approxHistogram.call(this, ...args);
}
truePercent() {
return C3.Set.$objProto.truePercent.call(this);
}
nullCount() {
return C3.Set.$objProto.nullCount.call(this);
}
toJsonString() {
return C3.Set.$objProto.toJsonString.call(this);
}
toTypedJsonString() {
return C3.Set.$objProto.toTypedJsonString.call(this);
}
toJsString() {
return C3.Set.$objProto.toJsString.call(this);
}
toXmlString() {
return C3.Set.$objProto.toXmlString.call(this);
}
serialize(...args) {
return C3.Set.$objProto.serialize.call(this, ...args);
}
toString(...args) {
return C3.Set.$objProto.toString.call(this, ...args);
}
fingerprint(...args) {
return C3.Set.$objProto.fingerprint.call(this, ...args);
}
retainedMemory(...args) {
return C3.Set.$objProto.retainedMemory.call(this, ...args);
}
elementAgg(...args) {
return C3.Set.$objProto.elementAgg.call(this, ...args);
}
elementAll(...args) {
return C3.Set.$objProto.elementAll.call(this, ...args);
}
elementAvg(...args) {
return C3.Set.$objProto.elementAvg.call(this, ...args);
}
elementCartesianProduct() {
return C3.Set.$objProto.elementCartesianProduct.call(this);
}
elementMin(...args) {
return C3.Set.$objProto.elementMin.call(this, ...args);
}
elementMax(...args) {
return C3.Set.$objProto.elementMax.call(this, ...args);
}
elementSum(...args) {
return C3.Set.$objProto.elementSum.call(this, ...args);
}
elementStddev(...args) {
return C3.Set.$objProto.elementStddev.call(this, ...args);
}
elementVariance(...args) {
return C3.Set.$objProto.elementVariance.call(this, ...args);
}
iter() {
return C3.Set.$objProto.iter.call(this);
}
_iter_() {
return C3.Set.$objProto._iter_.call(this);
}
_length_() {
return C3.Set.$objProto._length_.call(this);
}
collect(...args) {
return C3.Set.$objProto.collect.call(this, ...args);
}
collectArrays(...args) {
return C3.Set.$objProto.collectArrays.call(this, ...args);
}
abs() {
return C3.Set.$objProto.abs.call(this);
}
aggImplementation(...args) {
return C3.Set.$objProto.aggImplementation.call(this, ...args);
}
sumDbl() {
return C3.Set.$objProto.sumDbl.call(this);
}
sumDiff(...args) {
return C3.Set.$objProto.sumDiff.call(this, ...args);
}
cusum(...args) {
return C3.Set.$objProto.cusum.call(this, ...args);
}
normalize() {
return C3.Set.$objProto.normalize.call(this);
}
at(...args) {
return C3.Set.$objProto.at.call(this, ...args);
}
pluck(...args) {
return C3.Set.$objProto.pluck.call(this, ...args);
}
firstNotNull(...args) {
return C3.Set.$objProto.firstNotNull.call(this, ...args);
}
firstNotEmpty(...args) {
return C3.Set.$objProto.firstNotEmpty.call(this, ...args);
}
last(...args) {
return C3.Set.$objProto.last.call(this, ...args);
}
lastNotNull(...args) {
return C3.Set.$objProto.lastNotNull.call(this, ...args);
}
lastNotEmpty(...args) {
return C3.Set.$objProto.lastNotEmpty.call(this, ...args);
}
minImplementation(...args) {
return C3.Set.$objProto.minImplementation.call(this, ...args);
}
minBy(...args) {
return C3.Set.$objProto.minBy.call(this, ...args);
}
maxImplementation(...args) {
return C3.Set.$objProto.maxImplementation.call(this, ...args);
}
maxBy(...args) {
return C3.Set.$objProto.maxBy.call(this, ...args);
}
count(...args) {
return C3.Set.$objProto.count.call(this, ...args);
}
sumImplementation(...args) {
return C3.Set.$objProto.sumImplementation.call(this, ...args);
}
allImplementation(...args) {
return C3.Set.$objProto.allImplementation.call(this, ...args);
}
prod(...args) {
return C3.Set.$objProto.prod.call(this, ...args);
}
avg() {
return C3.Set.$objProto.avg.call(this);
}
avgDbl() {
return C3.Set.$objProto.avgDbl.call(this);
}
median() {
return C3.Set.$objProto.median.call(this);
}
medianDbl() {
return C3.Set.$objProto.medianDbl.call(this);
}
percentile(...args) {
return C3.Set.$objProto.percentile.call(this, ...args);
}
percentileDbl(...args) {
return C3.Set.$objProto.percentileDbl.call(this, ...args);
}
stddev() {
return C3.Set.$objProto.stddev.call(this);
}
stddevDbl() {
return C3.Set.$objProto.stddevDbl.call(this);
}
variance() {
return C3.Set.$objProto.variance.call(this);
}
varianceDbl() {
return C3.Set.$objProto.varianceDbl.call(this);
}
aggDbl(...args) {
return C3.Set.$objProto.aggDbl.call(this, ...args);
}
round(...args) {
return C3.Set.$objProto.round.call(this, ...args);
}
invert() {
return C3.Set.$objProto.invert.call(this);
}
isMissing() {
return C3.Set.$objProto.isMissing.call(this);
}
only(...args) {
return C3.Set.$objProto.only.call(this, ...args);
}
containsAll(...args) {
return C3.Set.$objProto.containsAll.call(this, ...args);
}
containsAny(...args) {
return C3.Set.$objProto.containsAny.call(this, ...args);
}
findAny(...args) {
return C3.Set.$objProto.findAny.call(this, ...args);
}
anyNotNull(...args) {
return C3.Set.$objProto.anyNotNull.call(this, ...args);
}
anyNotEmpty(...args) {
return C3.Set.$objProto.anyNotEmpty.call(this, ...args);
}
each(...args) {
C3.Set.$objProto.each.call(this, ...args);
}
eachWhile(...args) {
return C3.Set.$objProto.eachWhile.call(this, ...args);
}
mapToSame(...args) {
return C3.Set.$objProto.mapToSame.call(this, ...args);
}
map(...args) {
return C3.Set.$objProto.map.call(this, ...args);
}
mapToStr(...args) {
return C3.Set.$objProto.mapToStr.call(this, ...args);
}
mapTo(...args) {
return C3.Set.$objProto.mapTo.call(this, ...args);
}
flatMapToSame(...args) {
return C3.Set.$objProto.flatMapToSame.call(this, ...args);
}
flatMap(...args) {
return C3.Set.$objProto.flatMap.call(this, ...args);
}
flatMapTo(...args) {
return C3.Set.$objProto.flatMapTo.call(this, ...args);
}
flatMapRecursive(...args) {
return C3.Set.$objProto.flatMapRecursive.call(this, ...args);
}
fold(...args) {
return C3.Set.$objProto.fold.call(this, ...args);
}
compact() {
return C3.Set.$objProto.compact.call(this);
}
unique() {
return C3.Set.$objProto.unique.call(this);
}
uniqueBy(...args) {
return C3.Set.$objProto.uniqueBy.call(this, ...args);
}
filter(...args) {
return C3.Set.$objProto.filter.call(this, ...args);
}
fillMissingBy(...args) {
return C3.Set.$objProto.fillMissingBy.call(this, ...args);
}
fillMissing(...args) {
return C3.Set.$objProto.fillMissing.call(this, ...args);
}
fieldNames() {
return C3.Set.$objProto.fieldNames.call(this);
}
fieldValueType(...args) {
return C3.Set.$objProto.fieldValueType.call(this, ...args);
}
reject(...args) {
return C3.Set.$objProto.reject.call(this, ...args);
}
include(...args) {
return C3.Set.$objProto.include.call(this, ...args);
}
fieldSlice(...args) {
return C3.Set.$objProto.fieldSlice.call(this, ...args);
}
fieldSelect(...args) {
return C3.Set.$objProto.fieldSelect.call(this, ...args);
}
exclude(...args) {
return C3.Set.$objProto.exclude.call(this, ...args);
}
replaceByPredicate(...args) {
return C3.Set.$objProto.replaceByPredicate.call(this, ...args);
}
sorted(...args) {
return C3.Set.$objProto.sorted.call(this, ...args);
}
sortedBy(...args) {
return C3.Set.$objProto.sortedBy.call(this, ...args);
}
sortedIndex(...args) {
return C3.Set.$objProto.sortedIndex.call(this, ...args);
}
batch(...args) {
return C3.Set.$objProto.batch.call(this, ...args);
}
partition(...args) {
return C3.Set.$objProto.partition.call(this, ...args);
}
countBy(...args) {
return C3.Set.$objProto.countBy.call(this, ...args);
}
every(...args) {
return C3.Set.$objProto.every.call(this, ...args);
}
flatten(...args) {
return C3.Set.$objProto.flatten.call(this, ...args);
}
sample(...args) {
return C3.Set.$objProto.sample.call(this, ...args);
}
slice(...args) {
return C3.Set.$objProto.slice.call(this, ...args);
}
sliceByKey(...args) {
return C3.Set.$objProto.sliceByKey.call(this, ...args);
}
summarize(...args) {
return C3.Set.$objProto.summarize.call(this, ...args);
}
downsample(...args) {
return C3.Set.$objProto.downsample.call(this, ...args);
}
leastSquares() {
return C3.Set.$objProto.leastSquares.call(this);
}
rollingDiff(...args) {
return C3.Set.$objProto.rollingDiff.call(this, ...args);
}
pctChange(...args) {
return C3.Set.$objProto.pctChange.call(this, ...args);
}
binaryOp(...args) {
return C3.Set.$objProto.binaryOp.call(this, ...args);
}
unaryOp(...args) {
return C3.Set.$objProto.unaryOp.call(this, ...args);
}
shape() {
return C3.Set.$objProto.shape.call(this);
}
dimensionality() {
return C3.Set.$objProto.dimensionality.call(this);
}
toObj() {
return C3.Set.$objProto.toObj.call(this);
}
fetch(...args) {
return C3.Set.$objProto.fetch.call(this, ...args);
}
largest(...args) {
return C3.Set.$objProto.largest.call(this, ...args);
}
histogram(...args) {
return C3.Set.$objProto.histogram.call(this, ...args);
}
neg() {
return C3.Set.$objProto.neg.call(this);
}
describeImplementation(...args) {
return C3.Set.$objProto.describeImplementation.call(this, ...args);
}
and(...args) {
return C3.Set.$objProto.and.call(this, ...args);
}
approxMostFrequent(...args) {
return C3.Set.$objProto.approxMostFrequent.call(this, ...args);
}
or(...args) {
return C3.Set.$objProto.or.call(this, ...args);
}
timeseries(...args) {
return C3.Set.$objProto.timeseries.call(this, ...args);
}
stream() {
return C3.Set.$objProto.stream.call(this);
}
sub(...args) {
return C3.Set.$objProto.sub.call(this, ...args);
}
mul(...args) {
return C3.Set.$objProto.mul.call(this, ...args);
}
div(...args) {
return C3.Set.$objProto.div.call(this, ...args);
}
truediv(...args) {
return C3.Set.$objProto.truediv.call(this, ...args);
}
floordiv(...args) {
return C3.Set.$objProto.floordiv.call(this, ...args);
}
mod(...args) {
return C3.Set.$objProto.mod.call(this, ...args);
}
pow(...args) {
return C3.Set.$objProto.pow.call(this, ...args);
}
radd(...args) {
return C3.Set.$objProto.radd.call(this, ...args);
}
rsub(...args) {
return C3.Set.$objProto.rsub.call(this, ...args);
}
rmul(...args) {
return C3.Set.$objProto.rmul.call(this, ...args);
}
rdiv(...args) {
return C3.Set.$objProto.rdiv.call(this, ...args);
}
rtruediv(...args) {
return C3.Set.$objProto.rtruediv.call(this, ...args);
}
rfloordiv(...args) {
return C3.Set.$objProto.rfloordiv.call(this, ...args);
}
rmod(...args) {
return C3.Set.$objProto.rmod.call(this, ...args);
}
rpow(...args) {
return C3.Set.$objProto.rpow.call(this, ...args);
}
eq(...args) {
return C3.Set.$objProto.eq.call(this, ...args);
}
gt(...args) {
return C3.Set.$objProto.gt.call(this, ...args);
}
ge(...args) {
return C3.Set.$objProto.ge.call(this, ...args);
}
lt(...args) {
return C3.Set.$objProto.lt.call(this, ...args);
}
le(...args) {
return C3.Set.$objProto.le.call(this, ...args);
}
ne(...args) {
return C3.Set.$objProto.ne.call(this, ...args);
}
replaceType(...args) {
return C3.Set.$objProto.replaceType.call(this, ...args);
}
super(...args) {
return C3.Set.$objProto.super.call(this, ...args);
}
zip(...args) {
return C3.Set.$objProto.zip.call(this, ...args);
}
valueType() {
return C3.Set.$objProto.valueType.call(this);
}
toNative(...args) {
return C3.Set.$objProto.toNative.call(this, ...args);
}
validated() {
return C3.Set.$objProto.validated.call(this);
}
inferType() {
return C3.Set.$objProto.inferType.call(this);
}
hasNullElements() {
return C3.Set.$objProto.hasNullElements.call(this);
}
isSame(...args) {
return C3.Set.$objProto.isSame.call(this, ...args);
}
hasSameElements(...args) {
return C3.Set.$objProto.hasSameElements.call(this, ...args);
}
isUnique() {
return C3.Set.$objProto.isUnique.call(this);
}
isSorted() {
return C3.Set.$objProto.isSorted.call(this);
}
isIndexed() {
return C3.Set.$objProto.isIndexed.call(this);
}
indices() {
return C3.Set.$objProto.indices.call(this);
}
indexOf(...args) {
return C3.Set.$objProto.indexOf.call(this, ...args);
}
indexOfAny(...args) {
return C3.Set.$objProto.indexOfAny.call(this, ...args);
}
lastIndexOf(...args) {
return C3.Set.$objProto.lastIndexOf.call(this, ...args);
}
lastIndexOfAny(...args) {
return C3.Set.$objProto.lastIndexOfAny.call(this, ...args);
}
min(...args) {
return C3.Set.$objProto.min.call(this, ...args);
}
max(...args) {
return C3.Set.$objProto.max.call(this, ...args);
}
sum(...args) {
return C3.Set.$objProto.sum.call(this, ...args);
}
all(...args) {
return C3.Set.$objProto.all.call(this, ...args);
}
agg(...args) {
return C3.Set.$objProto.agg.call(this, ...args);
}
toArray(...args) {
return C3.Set.$objProto.toArray.call(this, ...args);
}
toSet(...args) {
return C3.Set.$objProto.toSet.call(this, ...args);
}
toStream(...args) {
return C3.Set.$objProto.toStream.call(this, ...args);
}
toMap(...args) {
return C3.Set.$objProto.toMap.call(this, ...args);
}
toMapOf(...args) {
return C3.Set.$objProto.toMapOf.call(this, ...args);
}
toMapOfAny(...args) {
return C3.Set.$objProto.toMapOfAny.call(this, ...args);
}
toMapOfType(...args) {
return C3.Set.$objProto.toMapOfType.call(this, ...args);
}
toCollection(...args) {
return C3.Set.$objProto.toCollection.call(this, ...args);
}
toMixingCollection(...args) {
return C3.Set.$objProto.toMixingCollection.call(this, ...args);
}
toCollectionOfType(...args) {
return C3.Set.$objProto.toCollectionOfType.call(this, ...args);
}
toInMemory() {
return C3.Set.$objProto.toInMemory.call(this);
}
box() {
return C3.Set.$objProto.box.call(this);
}
boxElements() {
return C3.Set.$objProto.boxElements.call(this);
}
anonymize(...args) {
return C3.Set.$objProto.anonymize.call(this, ...args);
}
descriptiveStatistics() {
return C3.Set.$objProto.descriptiveStatistics.call(this);
}
withoutOutliers(...args) {
return C3.Set.$objProto.withoutOutliers.call(this, ...args);
}
extractOutliers(...args) {
return C3.Set.$objProto.extractOutliers.call(this, ...args);
}
isOutlier(...args) {
return C3.Set.$objProto.isOutlier.call(this, ...args);
}
with(...args) {
return C3.Set.$objProto.with.call(this, ...args);
}
withSome(...args) {
return C3.Set.$objProto.withSome.call(this, ...args);
}
withAll(...args) {
return C3.Set.$objProto.withAll.call(this, ...args);
}
without(...args) {
return C3.Set.$objProto.without.call(this, ...args);
}
withoutSome(...args) {
return C3.Set.$objProto.withoutSome.call(this, ...args);
}
withoutAny(...args) {
return C3.Set.$objProto.withoutAny.call(this, ...args);
}
withoutAll(...args) {
return C3.Set.$objProto.withoutAll.call(this, ...args);
}
difference(...args) {
return C3.Set.$objProto.difference.call(this, ...args);
}
unzip() {
return C3.Set.$objProto.unzip.call(this);
}
mergeSimilar(...args) {
return C3.Set.$objProto.mergeSimilar.call(this, ...args);
}
mergeChildren(...args) {
return C3.Set.$objProto.mergeChildren.call(this, ...args);
}
visit(...args) {
return C3.Set.$objProto.visit.call(this, ...args);
}
withDefaults(...args) {
return C3.Set.$objProto.withDefaults.call(this, ...args);
}
evalTimeseries(...args) {
return C3.Set.$objProto.evalTimeseries.call(this, ...args);
}
groupBy(...args) {
return C3.Set.$objProto.groupBy.call(this, ...args);
}
resample(...args) {
return C3.Set.$objProto.resample.call(this, ...args);
}
rolling(...args) {
return C3.Set.$objProto.rolling.call(this, ...args);
}
_item_(...args) {
return C3.Set.$objProto._item_.call(this, ...args);
}
toData() {
return C3.Set.$objProto.toData.call(this);
}
replace(...args) {
return C3.Set.$objProto.replace.call(this, ...args);
}
initial(...args) {
return C3.Set.$objProto.initial.call(this, ...args);
}
pairs() {
return C3.Set.$objProto.pairs.call(this);
}
isCompressed() {
return C3.Set.$objProto.isCompressed.call(this);
}
compress() {
return C3.Set.$objProto.compress.call(this);
}
uncompress() {
return C3.Set.$objProto.uncompress.call(this);
}
isPacked() {
return C3.Set.$objProto.isPacked.call(this);
}
pack() {
return C3.Set.$objProto.pack.call(this);
}
unpack() {
return C3.Set.$objProto.unpack.call(this);
}
reversed() {
return C3.Set.$objProto.reversed.call(this);
}
withIfMissing(...args) {
return C3.Set.$objProto.withIfMissing.call(this, ...args);
}
toBuilder() {
return C3.Set.$objProto.toBuilder.call(this);
}
}
$protos.SetBase = SetBase;
class MapBase extends Map {
constructor(vt) {
super();
if (new.target == MapBase) {
throw new TypeError('Cannot construct MapBase class directly.');
}
let box = { type: vt };
Object.defineProperty(this, '$private', { value: box });
}
collectionType() {
let vt = this.$private.type;
if (typeof vt.type === 'string') {
vt = MapType.make(vt);
this.$private.type = vt;
}
return vt;
}
type() {
return this.$cache.get('type', true, () => C3.Map.bindVar(this.keyType(), this.elementType()));
}
containsKey(key) {
return super.has(key);
}
elementType() {
return this.collectionType().elementType;
}
first(arg) {
if (typeof arg === 'number') {
let array = [];
let i = 0;
for (const [k, v] of this) {
if (i >= arg) {
break;
}
array.push(v);
i++;
}
return array;
} else if (typeof arg === 'function') {
for (const [k, v] of this) {
if (arg.call(undefined, v, k)) {
return v;
}
}
} else {
for (const [k, v] of this) {
return v;
}
}
}
get(k, ifMissing) {
if (super.has(k)) {
return super.get(k);
}
if (ifMissing) {
return ifMissing.call(undefined, k);
}
}
isEmpty() {
return super.size === 0;
}
keyType() {
return this.collectionType().keyType;
}
get size() {
return super.size;
}
toJSON() {
return this.toJson();
}
_toJson(typed, omitTopLevelType) {
let toJsonFunc = typed ? 'valueToTypedJson' : 'valueToJson';
let vt = this.collectionType();
let et = vt.elementType;
let o = {};
this.forEach((v, k) => o[k] = et[toJsonFunc](v));
return typed && !omitTopLevelType ? { type: this.type().toString(), value: o } : o;
}
toJson() {
return this._toJson(false);
}
toTypedJson(omitTopLevelType) {
return this._toJson(true, omitTopLevelType);
}
fromJson(json) {
_make(this.type().$conn, json, this.collectionType(), false);
}
*_iter() {
for (let [k, e] of this)
yield e;
}
_build(...args) {
if (args.length == 1) {
return this.collectionType().buildMap(args[0]);
} else {
return MapType.of(this.keyType(), args[0]).buildMap(args[1]);
}
}
approxUniqueCount() {
return C3.Map.$objProto.approxUniqueCount.call(this);
}
approxMedian(...args) {
return C3.Map.$objProto.approxMedian.call(this, ...args);
}
approxHistogram(...args) {
return C3.Map.$objProto.approxHistogram.call(this, ...args);
}
truePercent() {
return C3.Map.$objProto.truePercent.call(this);
}
nullCount() {
return C3.Map.$objProto.nullCount.call(this);
}
toJsonString() {
return C3.Map.$objProto.toJsonString.call(this);
}
toTypedJsonString() {
return C3.Map.$objProto.toTypedJsonString.call(this);
}
toJsString() {
return C3.Map.$objProto.toJsString.call(this);
}
toXmlString() {
return C3.Map.$objProto.toXmlString.call(this);
}
serialize(...args) {
return C3.Map.$objProto.serialize.call(this, ...args);
}
toString(...args) {
return C3.Map.$objProto.toString.call(this, ...args);
}
fingerprint(...args) {
return C3.Map.$objProto.fingerprint.call(this, ...args);
}
retainedMemory(...args) {
return C3.Map.$objProto.retainedMemory.call(this, ...args);
}
elementAgg(...args) {
return C3.Map.$objProto.elementAgg.call(this, ...args);
}
elementAll(...args) {
return C3.Map.$objProto.elementAll.call(this, ...args);
}
elementAvg(...args) {
return C3.Map.$objProto.elementAvg.call(this, ...args);
}
elementCartesianProduct() {
return C3.Map.$objProto.elementCartesianProduct.call(this);
}
elementMin(...args) {
return C3.Map.$objProto.elementMin.call(this, ...args);
}
elementMax(...args) {
return C3.Map.$objProto.elementMax.call(this, ...args);
}
elementSum(...args) {
return C3.Map.$objProto.elementSum.call(this, ...args);
}
elementStddev(...args) {
return C3.Map.$objProto.elementStddev.call(this, ...args);
}
elementVariance(...args) {
return C3.Map.$objProto.elementVariance.call(this, ...args);
}
iter() {
return C3.Map.$objProto.iter.call(this);
}
_iter_() {
return C3.Map.$objProto._iter_.call(this);
}
_length_() {
return C3.Map.$objProto._length_.call(this);
}
collect(...args) {
return C3.Map.$objProto.collect.call(this, ...args);
}
collectArrays(...args) {
return C3.Map.$objProto.collectArrays.call(this, ...args);
}
abs() {
return C3.Map.$objProto.abs.call(this);
}
aggImplementation(...args) {
return C3.Map.$objProto.aggImplementation.call(this, ...args);
}
sumDbl() {
return C3.Map.$objProto.sumDbl.call(this);
}
sumDiff(...args) {
return C3.Map.$objProto.sumDiff.call(this, ...args);
}
cusum(...args) {
return C3.Map.$objProto.cusum.call(this, ...args);
}
normalize() {
return C3.Map.$objProto.normalize.call(this);
}
at(...args) {
return C3.Map.$objProto.at.call(this, ...args);
}
pluck(...args) {
return C3.Map.$objProto.pluck.call(this, ...args);
}
firstNotNull(...args) {
return C3.Map.$objProto.firstNotNull.call(this, ...args);
}
firstNotEmpty(...args) {
return C3.Map.$objProto.firstNotEmpty.call(this, ...args);
}
last(...args) {
return C3.Map.$objProto.last.call(this, ...args);
}
lastNotNull(...args) {
return C3.Map.$objProto.lastNotNull.call(this, ...args);
}
lastNotEmpty(...args) {
return C3.Map.$objProto.lastNotEmpty.call(this, ...args);
}
minImplementation(...args) {
return C3.Map.$objProto.minImplementation.call(this, ...args);
}
minBy(...args) {
return C3.Map.$objProto.minBy.call(this, ...args);
}
maxImplementation(...args) {
return C3.Map.$objProto.maxImplementation.call(this, ...args);
}
maxBy(...args) {
return C3.Map.$objProto.maxBy.call(this, ...args);
}
count(...args) {
return C3.Map.$objProto.count.call(this, ...args);
}
sumImplementation(...args) {
return C3.Map.$objProto.sumImplementation.call(this, ...args);
}
allImplementation(...args) {
return C3.Map.$objProto.allImplementation.call(this, ...args);
}
prod(...args) {
return C3.Map.$objProto.prod.call(this, ...args);
}
avg() {
return C3.Map.$objProto.avg.call(this);
}
avgDbl() {
return C3.Map.$objProto.avgDbl.call(this);
}
median() {
return C3.Map.$objProto.median.call(this);
}
medianDbl() {
return C3.Map.$objProto.medianDbl.call(this);
}
percentile(...args) {
return C3.Map.$objProto.percentile.call(this, ...args);
}
percentileDbl(...args) {
return C3.Map.$objProto.percentileDbl.call(this, ...args);
}
stddev() {
return C3.Map.$objProto.stddev.call(this);
}
stddevDbl() {
return C3.Map.$objProto.stddevDbl.call(this);
}
variance() {
return C3.Map.$objProto.variance.call(this);
}
varianceDbl() {
return C3.Map.$objProto.varianceDbl.call(this);
}
aggDbl(...args) {
return C3.Map.$objProto.aggDbl.call(this, ...args);
}
round(...args) {
return C3.Map.$objProto.round.call(this, ...args);
}
invert() {
return C3.Map.$objProto.invert.call(this);
}
isMissing() {
return C3.Map.$objProto.isMissing.call(this);
}
only(...args) {
return C3.Map.$objProto.only.call(this, ...args);
}
contains(...args) {
return C3.Map.$objProto.contains.call(this, ...args);
}
containsAll(...args) {
return C3.Map.$objProto.containsAll.call(this, ...args);
}
containsAny(...args) {
return C3.Map.$objProto.containsAny.call(this, ...args);
}
findAny(...args) {
return C3.Map.$objProto.findAny.call(this, ...args);
}
anyNotNull(...args) {
return C3.Map.$objProto.anyNotNull.call(this, ...args);
}
anyNotEmpty(...args) {
return C3.Map.$objProto.anyNotEmpty.call(this, ...args);
}
each(...args) {
C3.Map.$objProto.each.call(this, ...args);
}
eachWhile(...args) {
return C3.Map.$objProto.eachWhile.call(this, ...args);
}
mapToSame(...args) {
return C3.Map.$objProto.mapToSame.call(this, ...args);
}
map(...args) {
return C3.Map.$objProto.map.call(this, ...args);
}
mapToStr(...args) {
return C3.Map.$objProto.mapToStr.call(this, ...args);
}
mapTo(...args) {
return C3.Map.$objProto.mapTo.call(this, ...args);
}
flatMapToSame(...args) {
return C3.Map.$objProto.flatMapToSame.call(this, ...args);
}
flatMap(...args) {
return C3.Map.$objProto.flatMap.call(this, ...args);
}
flatMapTo(...args) {
return C3.Map.$objProto.flatMapTo.call(this, ...args);
}
flatMapRecursive(...args) {
return C3.Map.$objProto.flatMapRecursive.call(this, ...args);
}
fold(...args) {
return C3.Map.$objProto.fold.call(this, ...args);
}
compact() {
return C3.Map.$objProto.compact.call(this);
}
unique() {
return C3.Map.$objProto.unique.call(this);
}
uniqueBy(...args) {
return C3.Map.$objProto.uniqueBy.call(this, ...args);
}
filter(...args) {
return C3.Map.$objProto.filter.call(this, ...args);
}
fillMissingBy(...args) {
return C3.Map.$objProto.fillMissingBy.call(this, ...args);
}
fillMissing(...args) {
return C3.Map.$objProto.fillMissing.call(this, ...args);
}
fieldNames() {
return C3.Map.$objProto.fieldNames.call(this);
}
fieldValueType(...args) {
return C3.Map.$objProto.fieldValueType.call(this, ...args);
}
reject(...args) {
return C3.Map.$objProto.reject.call(this, ...args);
}
include(...args) {
return C3.Map.$objProto.include.call(this, ...args);
}
fieldSlice(...args) {
return C3.Map.$objProto.fieldSlice.call(this, ...args);
}
fieldSelect(...args) {
return C3.Map.$objProto.fieldSelect.call(this, ...args);
}
exclude(...args) {
return C3.Map.$objProto.exclude.call(this, ...args);
}
replaceByPredicate(...args) {
return C3.Map.$objProto.replaceByPredicate.call(this, ...args);
}
sorted(...args) {
return C3.Map.$objProto.sorted.call(this, ...args);
}
sortedBy(...args) {
return C3.Map.$objProto.sortedBy.call(this, ...args);
}
sortedIndex(...args) {
return C3.Map.$objProto.sortedIndex.call(this, ...args);
}
batch(...args) {
return C3.Map.$objProto.batch.call(this, ...args);
}
partition(...args) {
return C3.Map.$objProto.partition.call(this, ...args);
}
countBy(...args) {
return C3.Map.$objProto.countBy.call(this, ...args);
}
every(...args) {
return C3.Map.$objProto.every.call(this, ...args);
}
flatten(...args) {
return C3.Map.$objProto.flatten.call(this, ...args);
}
sample(...args) {
return C3.Map.$objProto.sample.call(this, ...args);
}
slice(...args) {
return C3.Map.$objProto.slice.call(this, ...args);
}
sliceByKey(...args) {
return C3.Map.$objProto.sliceByKey.call(this, ...args);
}
summarize(...args) {
return C3.Map.$objProto.summarize.call(this, ...args);
}
downsample(...args) {
return C3.Map.$objProto.downsample.call(this, ...args);
}
leastSquares() {
return C3.Map.$objProto.leastSquares.call(this);
}
rollingDiff(...args) {
return C3.Map.$objProto.rollingDiff.call(this, ...args);
}
pctChange(...args) {
return C3.Map.$objProto.pctChange.call(this, ...args);
}
binaryOp(...args) {
return C3.Map.$objProto.binaryOp.call(this, ...args);
}
unaryOp(...args) {
return C3.Map.$objProto.unaryOp.call(this, ...args);
}
shape() {
return C3.Map.$objProto.shape.call(this);
}
dimensionality() {
return C3.Map.$objProto.dimensionality.call(this);
}
toObj() {
return C3.Map.$objProto.toObj.call(this);
}
fetch(...args) {
return C3.Map.$objProto.fetch.call(this, ...args);
}
largest(...args) {
return C3.Map.$objProto.largest.call(this, ...args);
}
histogram(...args) {
return C3.Map.$objProto.histogram.call(this, ...args);
}
neg() {
return C3.Map.$objProto.neg.call(this);
}
describeImplementation(...args) {
return C3.Map.$objProto.describeImplementation.call(this, ...args);
}
and(...args) {
return C3.Map.$objProto.and.call(this, ...args);
}
approxMostFrequent(...args) {
return C3.Map.$objProto.approxMostFrequent.call(this, ...args);
}
or(...args) {
return C3.Map.$objProto.or.call(this, ...args);
}
timeseries(...args) {
return C3.Map.$objProto.timeseries.call(this, ...args);
}
stream() {
return C3.Map.$objProto.stream.call(this);
}
sub(...args) {
return C3.Map.$objProto.sub.call(this, ...args);
}
mul(...args) {
return C3.Map.$objProto.mul.call(this, ...args);
}
div(...args) {
return C3.Map.$objProto.div.call(this, ...args);
}
truediv(...args) {
return C3.Map.$objProto.truediv.call(this, ...args);
}
floordiv(...args) {
return C3.Map.$objProto.floordiv.call(this, ...args);
}
mod(...args) {
return C3.Map.$objProto.mod.call(this, ...args);
}
pow(...args) {
return C3.Map.$objProto.pow.call(this, ...args);
}
radd(...args) {
return C3.Map.$objProto.radd.call(this, ...args);
}
rsub(...args) {
return C3.Map.$objProto.rsub.call(this, ...args);
}
rmul(...args) {
return C3.Map.$objProto.rmul.call(this, ...args);
}
rdiv(...args) {
return C3.Map.$objProto.rdiv.call(this, ...args);
}
rtruediv(...args) {
return C3.Map.$objProto.rtruediv.call(this, ...args);
}
rfloordiv(...args) {
return C3.Map.$objProto.rfloordiv.call(this, ...args);
}
rmod(...args) {
return C3.Map.$objProto.rmod.call(this, ...args);
}
rpow(...args) {
return C3.Map.$objProto.rpow.call(this, ...args);
}
eq(...args) {
return C3.Map.$objProto.eq.call(this, ...args);
}
gt(...args) {
return C3.Map.$objProto.gt.call(this, ...args);
}
ge(...args) {
return C3.Map.$objProto.ge.call(this, ...args);
}
lt(...args) {
return C3.Map.$objProto.lt.call(this, ...args);
}
le(...args) {
return C3.Map.$objProto.le.call(this, ...args);
}
ne(...args) {
return C3.Map.$objProto.ne.call(this, ...args);
}
replaceType(...args) {
return C3.Map.$objProto.replaceType.call(this, ...args);
}
super(...args) {
return C3.Map.$objProto.super.call(this, ...args);
}
zip(...args) {
return C3.Map.$objProto.zip.call(this, ...args);
}
valueType() {
return C3.Map.$objProto.valueType.call(this);
}
toNative(...args) {
return C3.Map.$objProto.toNative.call(this, ...args);
}
validated() {
return C3.Map.$objProto.validated.call(this);
}
inferType() {
return C3.Map.$objProto.inferType.call(this);
}
hasNullElements() {
return C3.Map.$objProto.hasNullElements.call(this);
}
isSame(...args) {
return C3.Map.$objProto.isSame.call(this, ...args);
}
hasSameElements(...args) {
return C3.Map.$objProto.hasSameElements.call(this, ...args);
}
isUnique() {
return C3.Map.$objProto.isUnique.call(this);
}
isSorted() {
return C3.Map.$objProto.isSorted.call(this);
}
isIndexed() {
return C3.Map.$objProto.isIndexed.call(this);
}
indices() {
return C3.Map.$objProto.indices.call(this);
}
indexOf(...args) {
return C3.Map.$objProto.indexOf.call(this, ...args);
}
indexOfAny(...args) {
return C3.Map.$objProto.indexOfAny.call(this, ...args);
}
lastIndexOf(...args) {
return C3.Map.$objProto.lastIndexOf.call(this, ...args);
}
lastIndexOfAny(...args) {
return C3.Map.$objProto.lastIndexOfAny.call(this, ...args);
}
min(...args) {
return C3.Map.$objProto.min.call(this, ...args);
}
max(...args) {
return C3.Map.$objProto.max.call(this, ...args);
}
sum(...args) {
return C3.Map.$objProto.sum.call(this, ...args);
}
all(...args) {
return C3.Map.$objProto.all.call(this, ...args);
}
agg(...args) {
return C3.Map.$objProto.agg.call(this, ...args);
}
toArray(...args) {
return C3.Map.$objProto.toArray.call(this, ...args);
}
toSet(...args) {
return C3.Map.$objProto.toSet.call(this, ...args);
}
toStream(...args) {
return C3.Map.$objProto.toStream.call(this, ...args);
}
toMap(...args) {
return C3.Map.$objProto.toMap.call(this, ...args);
}
toMapOf(...args) {
return C3.Map.$objProto.toMapOf.call(this, ...args);
}
toMapOfAny(...args) {
return C3.Map.$objProto.toMapOfAny.call(this, ...args);
}
toMapOfType(...args) {
return C3.Map.$objProto.toMapOfType.call(this, ...args);
}
toCollection(...args) {
return C3.Map.$objProto.toCollection.call(this, ...args);
}
toMixingCollection(...args) {
return C3.Map.$objProto.toMixingCollection.call(this, ...args);
}
toCollectionOfType(...args) {
return C3.Map.$objProto.toCollectionOfType.call(this, ...args);
}
toInMemory() {
return C3.Map.$objProto.toInMemory.call(this);
}
box() {
return C3.Map.$objProto.box.call(this);
}
boxElements() {
return C3.Map.$objProto.boxElements.call(this);
}
anonymize(...args) {
return C3.Map.$objProto.anonymize.call(this, ...args);
}
descriptiveStatistics() {
return C3.Map.$objProto.descriptiveStatistics.call(this);
}
withoutOutliers(...args) {
return C3.Map.$objProto.withoutOutliers.call(this, ...args);
}
extractOutliers(...args) {
return C3.Map.$objProto.extractOutliers.call(this, ...args);
}
isOutlier(...args) {
return C3.Map.$objProto.isOutlier.call(this, ...args);
}
with(...args) {
return C3.Map.$objProto.with.call(this, ...args);
}
withSome(...args) {
return C3.Map.$objProto.withSome.call(this, ...args);
}
withAll(...args) {
return C3.Map.$objProto.withAll.call(this, ...args);
}
without(...args) {
return C3.Map.$objProto.without.call(this, ...args);
}
withoutSome(...args) {
return C3.Map.$objProto.withoutSome.call(this, ...args);
}
withoutAny(...args) {
return C3.Map.$objProto.withoutAny.call(this, ...args);
}
withoutAll(...args) {
return C3.Map.$objProto.withoutAll.call(this, ...args);
}
difference(...args) {
return C3.Map.$objProto.difference.call(this, ...args);
}
unzip() {
return C3.Map.$objProto.unzip.call(this);
}
mergeSimilar(...args) {
return C3.Map.$objProto.mergeSimilar.call(this, ...args);
}
mergeChildren(...args) {
return C3.Map.$objProto.mergeChildren.call(this, ...args);
}
visit(...args) {
return C3.Map.$objProto.visit.call(this, ...args);
}
withDefaults(...args) {
return C3.Map.$objProto.withDefaults.call(this, ...args);
}
evalTimeseries(...args) {
return C3.Map.$objProto.evalTimeseries.call(this, ...args);
}
groupBy(...args) {
return C3.Map.$objProto.groupBy.call(this, ...args);
}
resample(...args) {
return C3.Map.$objProto.resample.call(this, ...args);
}
rolling(...args) {
return C3.Map.$objProto.rolling.call(this, ...args);
}
_item_(...args) {
return C3.Map.$objProto._item_.call(this, ...args);
}
toData() {
return C3.Map.$objProto.toData.call(this);
}
isCompressed() {
return C3.Map.$objProto.isCompressed.call(this);
}
compress() {
return C3.Map.$objProto.compress.call(this);
}
uncompress() {
return C3.Map.$objProto.uncompress.call(this);
}
isPacked() {
return C3.Map.$objProto.isPacked.call(this);
}
pack() {
return C3.Map.$objProto.pack.call(this);
}
unpack() {
return C3.Map.$objProto.unpack.call(this);
}
reversed() {
return C3.Map.$objProto.reversed.call(this);
}
withIfMissing(...args) {
return C3.Map.$objProto.withIfMissing.call(this, ...args);
}
entryType() {
return C3.Map.$objProto.entryType.call(this);
}
hasNullKeys() {
return C3.Map.$objProto.hasNullKeys.call(this);
}
elements(...args) {
return C3.Map.$objProto.elements.call(this, ...args);
}
keys(...args) {
return C3.Map.$objProto.keys.call(this, ...args);
}
entries(...args) {
return C3.Map.$objProto.entries.call(this, ...args);
}
findAnyElement(...args) {
return C3.Map.$objProto.findAnyElement.call(this, ...args);
}
findAnyEntry(...args) {
return C3.Map.$objProto.findAnyEntry.call(this, ...args);
}
findAnyKey(...args) {
return C3.Map.$objProto.findAnyKey.call(this, ...args);
}
withoutKey(...args) {
return C3.Map.$objProto.withoutKey.call(this, ...args);
}
withoutKeys(...args) {
return C3.Map.$objProto.withoutKeys.call(this, ...args);
}
pickKeys(...args) {
return C3.Map.$objProto.pickKeys.call(this, ...args);
}
merge(...args) {
return C3.Map.$objProto.merge.call(this, ...args);
}
mapEntries(...args) {
return C3.Map.$objProto.mapEntries.call(this, ...args);
}
invertEntries() {
return C3.Map.$objProto.invertEntries.call(this);
}
sortKeys(...args) {
return C3.Map.$objProto.sortKeys.call(this, ...args);
}
toBuilder() {
return C3.Map.$objProto.toBuilder.call(this);
}
}
$protos.MapBase = MapBase;
class AbstractMapBase extends Map {
constructor(vt) {
super();
if (new.target == AbstractMapBase) {
throw new TypeError('Cannot construct AbstractMapBase class directly.');
}
let box = { type: vt };
Object.defineProperty(this, '$private', { value: box });
}
_unsupported(method) {
throw new Error(`Unsupported operation Map#${method}.`);
}
collectionType() {
let vt = this.$private.type;
if (typeof vt.type === 'string') {
vt = MapType.make(vt);
this.$private.type = vt;
}
return vt;
}
type() {
return this.$cache.get('type', true, () => C3.Map.bindVar(this.keyType(), this.elementType()));
}
containsKey(key) {
return super.has(key);
}
elementType() {
return this.collectionType().elementType;
}
get(k, ifMissing) {
if (super.has(k)) {
return super.get(k);
}
if (ifMissing) {
return ifMissing.call(undefined, k);
}
}
isEmpty() {
return super.size === 0;
}
keyType() {
return this.collectionType().keyType;
}
get size() {
return super.size;
}
*_iter() {
for (let [k, e] of this)
yield e;
}
_build(...args) {
if (args.length == 1) {
return this.collectionType().buildMap(args[0]);
} else {
return MapType.of(this.keyType(), args[0]).buildMap(args[1]);
}
}
approxUniqueCount() {
this._unsupported('approxUniqueCount');
}
approxMedian() {
this._unsupported('approxMedian');
}
approxHistogram() {
this._unsupported('approxHistogram');
}
truePercent() {
this._unsupported('truePercent');
}
nullCount() {
this._unsupported('nullCount');
}
toJson() {
this._unsupported('toJson');
}
toTypedJson() {
this._unsupported('toTypedJson');
}
toJsonString() {
this._unsupported('toJsonString');
}
toTypedJsonString() {
this._unsupported('toTypedJsonString');
}
toJsString() {
this._unsupported('toJsString');
}
toXmlString() {
this._unsupported('toXmlString');
}
serialize() {
this._unsupported('serialize');
}
toString() {
this._unsupported('toString');
}
fingerprint() {
this._unsupported('fingerprint');
}
retainedMemory() {
this._unsupported('retainedMemory');
}
elementAgg() {
this._unsupported('elementAgg');
}
elementAll() {
this._unsupported('elementAll');
}
elementAvg() {
this._unsupported('elementAvg');
}
elementCartesianProduct() {
this._unsupported('elementCartesianProduct');
}
elementMin() {
this._unsupported('elementMin');
}
elementMax() {
this._unsupported('elementMax');
}
elementSum() {
this._unsupported('elementSum');
}
elementStddev() {
this._unsupported('elementStddev');
}
elementVariance() {
this._unsupported('elementVariance');
}
iter() {
this._unsupported('iter');
}
_iter_() {
this._unsupported('_iter_');
}
_length_() {
this._unsupported('_length_');
}
collect() {
this._unsupported('collect');
}
collectArrays() {
this._unsupported('collectArrays');
}
abs() {
this._unsupported('abs');
}
aggImplementation() {
this._unsupported('aggImplementation');
}
sumDbl() {
this._unsupported('sumDbl');
}
sumDiff() {
this._unsupported('sumDiff');
}
cusum() {
this._unsupported('cusum');
}
normalize() {
this._unsupported('normalize');
}
at() {
this._unsupported('at');
}
pluck() {
this._unsupported('pluck');
}
first() {
this._unsupported('first');
}
firstNotNull() {
this._unsupported('firstNotNull');
}
firstNotEmpty() {
this._unsupported('firstNotEmpty');
}
last() {
this._unsupported('last');
}
lastNotNull() {
this._unsupported('lastNotNull');
}
lastNotEmpty() {
this._unsupported('lastNotEmpty');
}
minImplementation() {
this._unsupported('minImplementation');
}
minBy() {
this._unsupported('minBy');
}
maxImplementation() {
this._unsupported('maxImplementation');
}
maxBy() {
this._unsupported('maxBy');
}
count() {
this._unsupported('count');
}
sumImplementation() {
this._unsupported('sumImplementation');
}
allImplementation() {
this._unsupported('allImplementation');
}
prod() {
this._unsupported('prod');
}
avg() {
this._unsupported('avg');
}
avgDbl() {
this._unsupported('avgDbl');
}
median() {
this._unsupported('median');
}
medianDbl() {
this._unsupported('medianDbl');
}
percentile() {
this._unsupported('percentile');
}
percentileDbl() {
this._unsupported('percentileDbl');
}
stddev() {
this._unsupported('stddev');
}
stddevDbl() {
this._unsupported('stddevDbl');
}
variance() {
this._unsupported('variance');
}
varianceDbl() {
this._unsupported('varianceDbl');
}
aggDbl() {
this._unsupported('aggDbl');
}
round() {
this._unsupported('round');
}
invert() {
this._unsupported('invert');
}
isMissing() {
this._unsupported('isMissing');
}
only() {
this._unsupported('only');
}
contains() {
this._unsupported('contains');
}
containsAll() {
this._unsupported('containsAll');
}
containsAny() {
this._unsupported('containsAny');
}
findAny() {
this._unsupported('findAny');
}
anyNotNull() {
this._unsupported('anyNotNull');
}
anyNotEmpty() {
this._unsupported('anyNotEmpty');
}
each() {
this._unsupported('each');
}
eachWhile() {
this._unsupported('eachWhile');
}
mapToSame() {
this._unsupported('mapToSame');
}
map() {
this._unsupported('map');
}
mapToStr() {
this._unsupported('mapToStr');
}
mapTo() {
this._unsupported('mapTo');
}
flatMapToSame() {
this._unsupported('flatMapToSame');
}
flatMap() {
this._unsupported('flatMap');
}
flatMapTo() {
this._unsupported('flatMapTo');
}
flatMapRecursive() {
this._unsupported('flatMapRecursive');
}
fold() {
this._unsupported('fold');
}
compact() {
this._unsupported('compact');
}
unique() {
this._unsupported('unique');
}
uniqueBy() {
this._unsupported('uniqueBy');
}
filter() {
this._unsupported('filter');
}
fillMissingBy() {
this._unsupported('fillMissingBy');
}
fillMissing() {
this._unsupported('fillMissing');
}
fieldNames() {
this._unsupported('fieldNames');
}
fieldValueType() {
this._unsupported('fieldValueType');
}
reject() {
this._unsupported('reject');
}
include() {
this._unsupported('include');
}
fieldSlice() {
this._unsupported('fieldSlice');
}
fieldSelect() {
this._unsupported('fieldSelect');
}
exclude() {
this._unsupported('exclude');
}
replaceByPredicate() {
this._unsupported('replaceByPredicate');
}
sorted() {
this._unsupported('sorted');
}
sortedBy() {
this._unsupported('sortedBy');
}
sortedIndex() {
this._unsupported('sortedIndex');
}
batch() {
this._unsupported('batch');
}
partition() {
this._unsupported('partition');
}
countBy() {
this._unsupported('countBy');
}
every() {
this._unsupported('every');
}
flatten() {
this._unsupported('flatten');
}
sample() {
this._unsupported('sample');
}
slice() {
this._unsupported('slice');
}
sliceByKey() {
this._unsupported('sliceByKey');
}
summarize() {
this._unsupported('summarize');
}
downsample() {
this._unsupported('downsample');
}
leastSquares() {
this._unsupported('leastSquares');
}
rollingDiff() {
this._unsupported('rollingDiff');
}
pctChange() {
this._unsupported('pctChange');
}
binaryOp() {
this._unsupported('binaryOp');
}
unaryOp() {
this._unsupported('unaryOp');
}
shape() {
this._unsupported('shape');
}
dimensionality() {
this._unsupported('dimensionality');
}
toObj() {
this._unsupported('toObj');
}
fetch() {
this._unsupported('fetch');
}
largest() {
this._unsupported('largest');
}
histogram() {
this._unsupported('histogram');
}
neg() {
this._unsupported('neg');
}
describeImplementation() {
this._unsupported('describeImplementation');
}
and() {
this._unsupported('and');
}
approxMostFrequent() {
this._unsupported('approxMostFrequent');
}
or() {
this._unsupported('or');
}
timeseries() {
this._unsupported('timeseries');
}
stream() {
this._unsupported('stream');
}
sub() {
this._unsupported('sub');
}
mul() {
this._unsupported('mul');
}
div() {
this._unsupported('div');
}
truediv() {
this._unsupported('truediv');
}
floordiv() {
this._unsupported('floordiv');
}
mod() {
this._unsupported('mod');
}
pow() {
this._unsupported('pow');
}
radd() {
this._unsupported('radd');
}
rsub() {
this._unsupported('rsub');
}
rmul() {
this._unsupported('rmul');
}
rdiv() {
this._unsupported('rdiv');
}
rtruediv() {
this._unsupported('rtruediv');
}
rfloordiv() {
this._unsupported('rfloordiv');
}
rmod() {
this._unsupported('rmod');
}
rpow() {
this._unsupported('rpow');
}
eq() {
this._unsupported('eq');
}
gt() {
this._unsupported('gt');
}
ge() {
this._unsupported('ge');
}
lt() {
this._unsupported('lt');
}
le() {
this._unsupported('le');
}
ne() {
this._unsupported('ne');
}
replaceType() {
this._unsupported('replaceType');
}
super() {
this._unsupported('super');
}
zip() {
this._unsupported('zip');
}
valueType() {
this._unsupported('valueType');
}
toNative() {
this._unsupported('toNative');
}
validated() {
this._unsupported('validated');
}
inferType() {
this._unsupported('inferType');
}
hasNullElements() {
this._unsupported('hasNullElements');
}
isSame() {
this._unsupported('isSame');
}
hasSameElements() {
this._unsupported('hasSameElements');
}
isUnique() {
this._unsupported('isUnique');
}
isSorted() {
this._unsupported('isSorted');
}
isIndexed() {
this._unsupported('isIndexed');
}
indices() {
this._unsupported('indices');
}
indexOf() {
this._unsupported('indexOf');
}
indexOfAny() {
this._unsupported('indexOfAny');
}
lastIndexOf() {
this._unsupported('lastIndexOf');
}
lastIndexOfAny() {
this._unsupported('lastIndexOfAny');
}
min() {
this._unsupported('min');
}
max() {
this._unsupported('max');
}
sum() {
this._unsupported('sum');
}
all() {
this._unsupported('all');
}
agg() {
this._unsupported('agg');
}
toArray() {
this._unsupported('toArray');
}
toSet() {
this._unsupported('toSet');
}
toStream() {
this._unsupported('toStream');
}
toMap() {
this._unsupported('toMap');
}
toMapOf() {
this._unsupported('toMapOf');
}
toMapOfAny() {
this._unsupported('toMapOfAny');
}
toMapOfType() {
this._unsupported('toMapOfType');
}
toCollection() {
this._unsupported('toCollection');
}
toMixingCollection() {
this._unsupported('toMixingCollection');
}
toCollectionOfType() {
this._unsupported('toCollectionOfType');
}
toInMemory() {
this._unsupported('toInMemory');
}
box() {
this._unsupported('box');
}
boxElements() {
this._unsupported('boxElements');
}
anonymize() {
this._unsupported('anonymize');
}
descriptiveStatistics() {
this._unsupported('descriptiveStatistics');
}
withoutOutliers() {
this._unsupported('withoutOutliers');
}
extractOutliers() {
this._unsupported('extractOutliers');
}
isOutlier() {
this._unsupported('isOutlier');
}
with() {
this._unsupported('with');
}
withSome() {
this._unsupported('withSome');
}
withAll() {
this._unsupported('withAll');
}
without() {
this._unsupported('without');
}
withoutSome() {
this._unsupported('withoutSome');
}
withoutAny() {
this._unsupported('withoutAny');
}
withoutAll() {
this._unsupported('withoutAll');
}
difference() {
this._unsupported('difference');
}
unzip() {
this._unsupported('unzip');
}
mergeSimilar() {
this._unsupported('mergeSimilar');
}
mergeChildren() {
this._unsupported('mergeChildren');
}
visit() {
this._unsupported('visit');
}
withDefaults() {
this._unsupported('withDefaults');
}
evalTimeseries() {
this._unsupported('evalTimeseries');
}
groupBy() {
this._unsupported('groupBy');
}
resample() {
this._unsupported('resample');
}
rolling() {
this._unsupported('rolling');
}
_item_() {
this._unsupported('_item_');
}
toData() {
this._unsupported('toData');
}
isCompressed() {
this._unsupported('isCompressed');
}
compress() {
this._unsupported('compress');
}
uncompress() {
this._unsupported('uncompress');
}
isPacked() {
this._unsupported('isPacked');
}
pack() {
this._unsupported('pack');
}
unpack() {
this._unsupported('unpack');
}
reversed() {
this._unsupported('reversed');
}
withIfMissing() {
this._unsupported('withIfMissing');
}
entryType() {
this._unsupported('entryType');
}
hasNullKeys() {
this._unsupported('hasNullKeys');
}
elements() {
this._unsupported('elements');
}
keys() {
this._unsupported('keys');
}
entries() {
this._unsupported('entries');
}
findAnyElement() {
this._unsupported('findAnyElement');
}
findAnyEntry() {
this._unsupported('findAnyEntry');
}
findAnyKey() {
this._unsupported('findAnyKey');
}
withoutKey() {
this._unsupported('withoutKey');
}
withoutKeys() {
this._unsupported('withoutKeys');
}
pickKeys() {
this._unsupported('pickKeys');
}
merge() {
this._unsupported('merge');
}
mapEntries() {
this._unsupported('mapEntries');
}
invertEntries() {
this._unsupported('invertEntries');
}
sortKeys() {
this._unsupported('sortKeys');
}
toBuilder() {
this._unsupported('toBuilder');
}
}
$protos.AbstractMapBase = AbstractMapBase;
class StreamBase {
constructor(vt) {
let box = { type: vt, done: false, seen: 0 };
Object.defineProperty(this, '$private', { value: box });
}
at(index) {
let v;
if (this.skip(index) === index && this.hasNext())
v = this.next();
this.close();
return v;
}
close() {
this.doClose();
if (typeof this.$private.onClose === 'function') {
this.$private.onClose.call(this);
}
}
collect(limit) {
let at = ArrayType.of(this.elementType());
let b = at.makeBuilder();
if (typeof limit === 'number' && limit >= 0) {
let n = 0;
for (let e of this) {
if (n >= limit)
break;
b.add(e);
n++;
}
this.close();
} else {
for (let e of this) {
b.add(e);
}
}
return b.build();
}
collectionType() {
let vt = this.$private.type;
if (typeof vt.type === 'string') {
vt = StreamType.make(vt);
this.$private.type = vt;
}
return vt;
}
count() {
let count = 0;
for (let e of this) {
count++;
}
return count;
}
doClose() {
this.$private.done = true;
if (typeof this.$private.close === 'function') {
this.$private.close.call(this);
}
}
elementType() {
return this.collectionType().elementType;
}
first(arg) {
if (typeof arg === 'number' && arg > 1) {
let elts = [];
for (let i = 0; i < arg && this.hasNext(); i++) {
elts.push(this.next());
}
let vt = this.collectionType();
return _make(vt.type().$conn, elts, vt, false);
} else if (typeof arg === 'function') {
return this.find(arg);
} else {
if (this.hasNext()) {
let e = this.next();
this.doClose();
return e;
}
}
}
hasNext() {
if (!this.$private.done && typeof this.$private.hasNext === 'function') {
let h = this.$private.hasNext.call(this);
if (!h) {
this.doClose();
}
return h;
}
return false;
}
isEmpty() {
return !this.hasNext();
}
next() {
if (!this.$private.done && typeof this.$private.next === 'function') {
let v = this.$private.next.call(this);
this.$private.seen++;
return v;
}
}
seen() {
return this.$private.seen;
}
get size() {
return this.seen() + this.count();
}
skip(n) {
let count;
for (count = 0; count < n && this.hasNext(); count++)
this.next();
return count;
}
toJson() {
let et = this.elementType();
let a = [];
for (let e of this) {
a.push(et.valueToJson(e));
}
return a;
}
toJSON() {
return this.toJson();
}
toString() {
return `[object ${this.constructor.name}(seen ${this.$private.seen}, done ${this.$private.done})]`;
}
type() {
return this.$cache.get('type', true, () => C3.Stream.bindVar(this.elementType()));
}
wasEmpty() {
return this.size == 0;
}
[Symbol.iterator]() {
const stream = this;
return { next: function() {
if (stream.hasNext()) {
return { value: stream.next(), done: false };
} else {
return { value: undefined, done: true };
}
}
, stream };
}
*_iter() {
for (let e of this) {
yield e;
}
}
_build(...args) {
if (args.length == 1) {
return this.collectionType().buildStream(args[0]);
} else {
return StreamType.of(args[0]).buildStream(args[1]);
}
}
_singleton(e) {
return this.collectionType().buildStream(b => b.add(e));
}
_repr_() {
return C3.Stream.$objProto._repr_.call(this);
}
elementAgg(...args) {
return C3.Stream.$objProto.elementAgg.call(this, ...args);
}
elementAll(...args) {
return C3.Stream.$objProto.elementAll.call(this, ...args);
}
elementAvg(...args) {
return C3.Stream.$objProto.elementAvg.call(this, ...args);
}
elementCartesianProduct() {
return C3.Stream.$objProto.elementCartesianProduct.call(this);
}
elementMin(...args) {
return C3.Stream.$objProto.elementMin.call(this, ...args);
}
elementMax(...args) {
return C3.Stream.$objProto.elementMax.call(this, ...args);
}
elementSum(...args) {
return C3.Stream.$objProto.elementSum.call(this, ...args);
}
elementStddev(...args) {
return C3.Stream.$objProto.elementStddev.call(this, ...args);
}
elementVariance(...args) {
return C3.Stream.$objProto.elementVariance.call(this, ...args);
}
iter() {
return C3.Stream.$objProto.iter.call(this);
}
_iter_() {
return C3.Stream.$objProto._iter_.call(this);
}
_length_() {
return C3.Stream.$objProto._length_.call(this);
}
collectArrays(...args) {
return C3.Stream.$objProto.collectArrays.call(this, ...args);
}
abs() {
return C3.Stream.$objProto.abs.call(this);
}
aggImplementation(...args) {
return C3.Stream.$objProto.aggImplementation.call(this, ...args);
}
sumDbl() {
return C3.Stream.$objProto.sumDbl.call(this);
}
sumDiff(...args) {
return C3.Stream.$objProto.sumDiff.call(this, ...args);
}
cusum(...args) {
return C3.Stream.$objProto.cusum.call(this, ...args);
}
normalize() {
return C3.Stream.$objProto.normalize.call(this);
}
pluck(...args) {
return C3.Stream.$objProto.pluck.call(this, ...args);
}
firstNotNull(...args) {
return C3.Stream.$objProto.firstNotNull.call(this, ...args);
}
firstNotEmpty(...args) {
return C3.Stream.$objProto.firstNotEmpty.call(this, ...args);
}
last(...args) {
return C3.Stream.$objProto.last.call(this, ...args);
}
lastNotNull(...args) {
return C3.Stream.$objProto.lastNotNull.call(this, ...args);
}
lastNotEmpty(...args) {
return C3.Stream.$objProto.lastNotEmpty.call(this, ...args);
}
minImplementation(...args) {
return C3.Stream.$objProto.minImplementation.call(this, ...args);
}
minBy(...args) {
return C3.Stream.$objProto.minBy.call(this, ...args);
}
maxImplementation(...args) {
return C3.Stream.$objProto.maxImplementation.call(this, ...args);
}
maxBy(...args) {
return C3.Stream.$objProto.maxBy.call(this, ...args);
}
sumImplementation(...args) {
return C3.Stream.$objProto.sumImplementation.call(this, ...args);
}
allImplementation(...args) {
return C3.Stream.$objProto.allImplementation.call(this, ...args);
}
prod(...args) {
return C3.Stream.$objProto.prod.call(this, ...args);
}
avg() {
return C3.Stream.$objProto.avg.call(this);
}
avgDbl() {
return C3.Stream.$objProto.avgDbl.call(this);
}
median() {
return C3.Stream.$objProto.median.call(this);
}
medianDbl() {
return C3.Stream.$objProto.medianDbl.call(this);
}
percentile(...args) {
return C3.Stream.$objProto.percentile.call(this, ...args);
}
percentileDbl(...args) {
return C3.Stream.$objProto.percentileDbl.call(this, ...args);
}
stddev() {
return C3.Stream.$objProto.stddev.call(this);
}
stddevDbl() {
return C3.Stream.$objProto.stddevDbl.call(this);
}
variance() {
return C3.Stream.$objProto.variance.call(this);
}
varianceDbl() {
return C3.Stream.$objProto.varianceDbl.call(this);
}
aggDbl(...args) {
return C3.Stream.$objProto.aggDbl.call(this, ...args);
}
round(...args) {
return C3.Stream.$objProto.round.call(this, ...args);
}
invert() {
return C3.Stream.$objProto.invert.call(this);
}
isMissing() {
return C3.Stream.$objProto.isMissing.call(this);
}
only(...args) {
return C3.Stream.$objProto.only.call(this, ...args);
}
contains(...args) {
return C3.Stream.$objProto.contains.call(this, ...args);
}
containsAll(...args) {
return C3.Stream.$objProto.containsAll.call(this, ...args);
}
containsAny(...args) {
return C3.Stream.$objProto.containsAny.call(this, ...args);
}
findAny(...args) {
return C3.Stream.$objProto.findAny.call(this, ...args);
}
anyNotNull(...args) {
return C3.Stream.$objProto.anyNotNull.call(this, ...args);
}
anyNotEmpty(...args) {
return C3.Stream.$objProto.anyNotEmpty.call(this, ...args);
}
each(...args) {
C3.Stream.$objProto.each.call(this, ...args);
}
eachWhile(...args) {
return C3.Stream.$objProto.eachWhile.call(this, ...args);
}
mapToSame(...args) {
return C3.Stream.$objProto.mapToSame.call(this, ...args);
}
map(...args) {
return C3.Stream.$objProto.map.call(this, ...args);
}
mapToStr(...args) {
return C3.Stream.$objProto.mapToStr.call(this, ...args);
}
mapTo(...args) {
return C3.Stream.$objProto.mapTo.call(this, ...args);
}
flatMapToSame(...args) {
return C3.Stream.$objProto.flatMapToSame.call(this, ...args);
}
flatMap(...args) {
return C3.Stream.$objProto.flatMap.call(this, ...args);
}
flatMapTo(...args) {
return C3.Stream.$objProto.flatMapTo.call(this, ...args);
}
flatMapRecursive(...args) {
return C3.Stream.$objProto.flatMapRecursive.call(this, ...args);
}
fold(...args) {
return C3.Stream.$objProto.fold.call(this, ...args);
}
compact() {
return C3.Stream.$objProto.compact.call(this);
}
unique() {
return C3.Stream.$objProto.unique.call(this);
}
uniqueBy(...args) {
return C3.Stream.$objProto.uniqueBy.call(this, ...args);
}
filter(...args) {
return C3.Stream.$objProto.filter.call(this, ...args);
}
fillMissingBy(...args) {
return C3.Stream.$objProto.fillMissingBy.call(this, ...args);
}
fillMissing(...args) {
return C3.Stream.$objProto.fillMissing.call(this, ...args);
}
fieldNames() {
return C3.Stream.$objProto.fieldNames.call(this);
}
fieldValueType(...args) {
return C3.Stream.$objProto.fieldValueType.call(this, ...args);
}
reject(...args) {
return C3.Stream.$objProto.reject.call(this, ...args);
}
include(...args) {
return C3.Stream.$objProto.include.call(this, ...args);
}
fieldSlice(...args) {
return C3.Stream.$objProto.fieldSlice.call(this, ...args);
}
fieldSelect(...args) {
return C3.Stream.$objProto.fieldSelect.call(this, ...args);
}
exclude(...args) {
return C3.Stream.$objProto.exclude.call(this, ...args);
}
replaceByPredicate(...args) {
return C3.Stream.$objProto.replaceByPredicate.call(this, ...args);
}
sorted(...args) {
return C3.Stream.$objProto.sorted.call(this, ...args);
}
sortedBy(...args) {
return C3.Stream.$objProto.sortedBy.call(this, ...args);
}
sortedIndex(...args) {
return C3.Stream.$objProto.sortedIndex.call(this, ...args);
}
batch(...args) {
return C3.Stream.$objProto.batch.call(this, ...args);
}
partition(...args) {
return C3.Stream.$objProto.partition.call(this, ...args);
}
countBy(...args) {
return C3.Stream.$objProto.countBy.call(this, ...args);
}
every(...args) {
return C3.Stream.$objProto.every.call(this, ...args);
}
flatten(...args) {
return C3.Stream.$objProto.flatten.call(this, ...args);
}
sample(...args) {
return C3.Stream.$objProto.sample.call(this, ...args);
}
slice(...args) {
return C3.Stream.$objProto.slice.call(this, ...args);
}
sliceByKey(...args) {
return C3.Stream.$objProto.sliceByKey.call(this, ...args);
}
summarize(...args) {
return C3.Stream.$objProto.summarize.call(this, ...args);
}
downsample(...args) {
return C3.Stream.$objProto.downsample.call(this, ...args);
}
leastSquares() {
return C3.Stream.$objProto.leastSquares.call(this);
}
rollingDiff(...args) {
return C3.Stream.$objProto.rollingDiff.call(this, ...args);
}
pctChange(...args) {
return C3.Stream.$objProto.pctChange.call(this, ...args);
}
binaryOp(...args) {
return C3.Stream.$objProto.binaryOp.call(this, ...args);
}
unaryOp(...args) {
return C3.Stream.$objProto.unaryOp.call(this, ...args);
}
shape() {
return C3.Stream.$objProto.shape.call(this);
}
dimensionality() {
return C3.Stream.$objProto.dimensionality.call(this);
}
toObj() {
return C3.Stream.$objProto.toObj.call(this);
}
fetch(...args) {
return C3.Stream.$objProto.fetch.call(this, ...args);
}
largest(...args) {
return C3.Stream.$objProto.largest.call(this, ...args);
}
histogram(...args) {
return C3.Stream.$objProto.histogram.call(this, ...args);
}
neg() {
return C3.Stream.$objProto.neg.call(this);
}
describeImplementation(...args) {
return C3.Stream.$objProto.describeImplementation.call(this, ...args);
}
and(...args) {
return C3.Stream.$objProto.and.call(this, ...args);
}
approxMostFrequent(...args) {
return C3.Stream.$objProto.approxMostFrequent.call(this, ...args);
}
or(...args) {
return C3.Stream.$objProto.or.call(this, ...args);
}
timeseries(...args) {
return C3.Stream.$objProto.timeseries.call(this, ...args);
}
stream() {
return C3.Stream.$objProto.stream.call(this);
}
sub(...args) {
return C3.Stream.$objProto.sub.call(this, ...args);
}
mul(...args) {
return C3.Stream.$objProto.mul.call(this, ...args);
}
div(...args) {
return C3.Stream.$objProto.div.call(this, ...args);
}
truediv(...args) {
return C3.Stream.$objProto.truediv.call(this, ...args);
}
floordiv(...args) {
return C3.Stream.$objProto.floordiv.call(this, ...args);
}
mod(...args) {
return C3.Stream.$objProto.mod.call(this, ...args);
}
pow(...args) {
return C3.Stream.$objProto.pow.call(this, ...args);
}
radd(...args) {
return C3.Stream.$objProto.radd.call(this, ...args);
}
rsub(...args) {
return C3.Stream.$objProto.rsub.call(this, ...args);
}
rmul(...args) {
return C3.Stream.$objProto.rmul.call(this, ...args);
}
rdiv(...args) {
return C3.Stream.$objProto.rdiv.call(this, ...args);
}
rtruediv(...args) {
return C3.Stream.$objProto.rtruediv.call(this, ...args);
}
rfloordiv(...args) {
return C3.Stream.$objProto.rfloordiv.call(this, ...args);
}
rmod(...args) {
return C3.Stream.$objProto.rmod.call(this, ...args);
}
rpow(...args) {
return C3.Stream.$objProto.rpow.call(this, ...args);
}
eq(...args) {
return C3.Stream.$objProto.eq.call(this, ...args);
}
gt(...args) {
return C3.Stream.$objProto.gt.call(this, ...args);
}
ge(...args) {
return C3.Stream.$objProto.ge.call(this, ...args);
}
lt(...args) {
return C3.Stream.$objProto.lt.call(this, ...args);
}
le(...args) {
return C3.Stream.$objProto.le.call(this, ...args);
}
ne(...args) {
return C3.Stream.$objProto.ne.call(this, ...args);
}
approxUniqueCount() {
return C3.Stream.$objProto.approxUniqueCount.call(this);
}
approxMedian(...args) {
return C3.Stream.$objProto.approxMedian.call(this, ...args);
}
approxHistogram(...args) {
return C3.Stream.$objProto.approxHistogram.call(this, ...args);
}
truePercent() {
return C3.Stream.$objProto.truePercent.call(this);
}
nullCount() {
return C3.Stream.$objProto.nullCount.call(this);
}
toTypedJson(...args) {
return C3.Stream.$objProto.toTypedJson.call(this, ...args);
}
toJsonString() {
return C3.Stream.$objProto.toJsonString.call(this);
}
toTypedJsonString() {
return C3.Stream.$objProto.toTypedJsonString.call(this);
}
toJsString() {
return C3.Stream.$objProto.toJsString.call(this);
}
toXmlString() {
return C3.Stream.$objProto.toXmlString.call(this);
}
serialize(...args) {
return C3.Stream.$objProto.serialize.call(this, ...args);
}
fingerprint(...args) {
return C3.Stream.$objProto.fingerprint.call(this, ...args);
}
retainedMemory(...args) {
return C3.Stream.$objProto.retainedMemory.call(this, ...args);
}
replaceType(...args) {
return C3.Stream.$objProto.replaceType.call(this, ...args);
}
super(...args) {
return C3.Stream.$objProto.super.call(this, ...args);
}
zip(...args) {
return C3.Stream.$objProto.zip.call(this, ...args);
}
valueType() {
return C3.Stream.$objProto.valueType.call(this);
}
toNative(...args) {
return C3.Stream.$objProto.toNative.call(this, ...args);
}
validated() {
return C3.Stream.$objProto.validated.call(this);
}
inferType() {
return C3.Stream.$objProto.inferType.call(this);
}
hasNullElements() {
return C3.Stream.$objProto.hasNullElements.call(this);
}
isSame(...args) {
return C3.Stream.$objProto.isSame.call(this, ...args);
}
hasSameElements(...args) {
return C3.Stream.$objProto.hasSameElements.call(this, ...args);
}
isUnique() {
return C3.Stream.$objProto.isUnique.call(this);
}
isSorted() {
return C3.Stream.$objProto.isSorted.call(this);
}
isIndexed() {
return C3.Stream.$objProto.isIndexed.call(this);
}
indices() {
return C3.Stream.$objProto.indices.call(this);
}
indexOf(...args) {
return C3.Stream.$objProto.indexOf.call(this, ...args);
}
indexOfAny(...args) {
return C3.Stream.$objProto.indexOfAny.call(this, ...args);
}
lastIndexOf(...args) {
return C3.Stream.$objProto.lastIndexOf.call(this, ...args);
}
lastIndexOfAny(...args) {
return C3.Stream.$objProto.lastIndexOfAny.call(this, ...args);
}
min(...args) {
return C3.Stream.$objProto.min.call(this, ...args);
}
max(...args) {
return C3.Stream.$objProto.max.call(this, ...args);
}
sum(...args) {
return C3.Stream.$objProto.sum.call(this, ...args);
}
all(...args) {
return C3.Stream.$objProto.all.call(this, ...args);
}
agg(...args) {
return C3.Stream.$objProto.agg.call(this, ...args);
}
toArray(...args) {
return C3.Stream.$objProto.toArray.call(this, ...args);
}
toSet(...args) {
return C3.Stream.$objProto.toSet.call(this, ...args);
}
toStream(...args) {
return C3.Stream.$objProto.toStream.call(this, ...args);
}
toMap(...args) {
return C3.Stream.$objProto.toMap.call(this, ...args);
}
toMapOf(...args) {
return C3.Stream.$objProto.toMapOf.call(this, ...args);
}
toMapOfAny(...args) {
return C3.Stream.$objProto.toMapOfAny.call(this, ...args);
}
toMapOfType(...args) {
return C3.Stream.$objProto.toMapOfType.call(this, ...args);
}
toCollection(...args) {
return C3.Stream.$objProto.toCollection.call(this, ...args);
}
toMixingCollection(...args) {
return C3.Stream.$objProto.toMixingCollection.call(this, ...args);
}
toCollectionOfType(...args) {
return C3.Stream.$objProto.toCollectionOfType.call(this, ...args);
}
toInMemory() {
return C3.Stream.$objProto.toInMemory.call(this);
}
box() {
return C3.Stream.$objProto.box.call(this);
}
boxElements() {
return C3.Stream.$objProto.boxElements.call(this);
}
anonymize(...args) {
return C3.Stream.$objProto.anonymize.call(this, ...args);
}
descriptiveStatistics() {
return C3.Stream.$objProto.descriptiveStatistics.call(this);
}
withoutOutliers(...args) {
return C3.Stream.$objProto.withoutOutliers.call(this, ...args);
}
extractOutliers(...args) {
return C3.Stream.$objProto.extractOutliers.call(this, ...args);
}
isOutlier(...args) {
return C3.Stream.$objProto.isOutlier.call(this, ...args);
}
with(...args) {
return C3.Stream.$objProto.with.call(this, ...args);
}
withSome(...args) {
return C3.Stream.$objProto.withSome.call(this, ...args);
}
withAll(...args) {
return C3.Stream.$objProto.withAll.call(this, ...args);
}
without(...args) {
return C3.Stream.$objProto.without.call(this, ...args);
}
withoutSome(...args) {
return C3.Stream.$objProto.withoutSome.call(this, ...args);
}
withoutAny(...args) {
return C3.Stream.$objProto.withoutAny.call(this, ...args);
}
withoutAll(...args) {
return C3.Stream.$objProto.withoutAll.call(this, ...args);
}
difference(...args) {
return C3.Stream.$objProto.difference.call(this, ...args);
}
unzip() {
return C3.Stream.$objProto.unzip.call(this);
}
mergeSimilar(...args) {
return C3.Stream.$objProto.mergeSimilar.call(this, ...args);
}
mergeChildren(...args) {
return C3.Stream.$objProto.mergeChildren.call(this, ...args);
}
visit(...args) {
return C3.Stream.$objProto.visit.call(this, ...args);
}
withDefaults(...args) {
return C3.Stream.$objProto.withDefaults.call(this, ...args);
}
evalTimeseries(...args) {
return C3.Stream.$objProto.evalTimeseries.call(this, ...args);
}
groupBy(...args) {
return C3.Stream.$objProto.groupBy.call(this, ...args);
}
resample(...args) {
return C3.Stream.$objProto.resample.call(this, ...args);
}
rolling(...args) {
return C3.Stream.$objProto.rolling.call(this, ...args);
}
_item_(...args) {
return C3.Stream.$objProto._item_.call(this, ...args);
}
toData() {
return C3.Stream.$objProto.toData.call(this);
}
replace(...args) {
return C3.Stream.$objProto.replace.call(this, ...args);
}
initial(...args) {
return C3.Stream.$objProto.initial.call(this, ...args);
}
pairs() {
return C3.Stream.$objProto.pairs.call(this);
}
closed() {
return C3.Stream.$objProto.closed.call(this);
}
limit(...args) {
return C3.Stream.$objProto.limit.call(this, ...args);
}
offset(...args) {
return C3.Stream.$objProto.offset.call(this, ...args);
}
concat(...args) {
return C3.Stream.$objProto.concat.call(this, ...args);
}
split(...args) {
return C3.Stream.$objProto.split.call(this, ...args);
}
shuffle(...args) {
return C3.Stream.$objProto.shuffle.call(this, ...args);
}
buffer(...args) {
return C3.Stream.$objProto.buffer.call(this, ...args);
}
peek(...args) {
return C3.Stream.$objProto.peek.call(this, ...args);
}
}
$protos.StreamBase = StreamBase;
class AsyncStreamBase {
constructor(vt) {
let box = { type: vt, done: false, seen: 0 };
Object.defineProperty(this, '$private', { value: box });
}
async at(index) {
let v;
if (await this.skip(index) === index && await this.hasNext())
v = await this.next();
this.close();
return v;
}
async close() {
await this.doClose();
if (typeof this.$private.onClose === 'function') {
await this.$private.onClose.call(this);
}
}
async collect() {
let at = ArrayType.of(this.elementType());
let b = at.makeBuilder();
for await (let e of this) {
b.add(e);
}
return b.build();
}
collectionType() {
let vt = this.$private.type;
if (typeof vt.type === 'string') {
vt = StreamType.make(vt);
this.$private.type = vt;
}
return vt;
}
async doClose() {
this.$private.done = true;
if (typeof this.$private.close === 'function') {
return this.$private.close.call(this);
}
}
elementType() {
return this.collectionType().elementType;
}
async hasNext() {
if (!this.$private.done && typeof this.$private.hasNext === 'function') {
let h = await this.$private.hasNext.call(this);
if (!h) {
await this.doClose();
}
return h;
}
return false;
}
async isEmpty() {
return !await this.hasNext();
}
async next() {
if (!this.$private.done && typeof this.$private.next === 'function') {
let v = await this.$private.next.call(this);
this.$private.seen++;
return v;
}
}
seen() {
return this.$private.seen;
}
async skip(n) {
let count;
for (count = 0; count < n && await this.hasNext(); count++)
await this.next();
return count;
}
get size() {
return new Promise((resolve, reject) => this.count().then(count => resolve(this.seen() + count), reject));
}
async toJson() {
let et = this.elementType();
let a = [];
for await (let e of this) {
a.push(et.valueToJson(e));
}
return a;
}
async toJSON() {
return await this.toJson();
}
toString() {
return `[object ${this.constructor.name}(seen ${this.$private.seen}, done ${this.$private.done})]`;
}
type() {
return this.$cache.get('type', true, () => C3.Stream.bindVar(this.elementType()));
}
async wasEmpty() {
return await this.size == 0;
}
[Symbol.iterator]() {
const stream = this;
return { next: async function() {
if (await stream.hasNext()) {
return { value: await stream.next(), done: false };
} else {
return { value: undefined, done: true };
}
}
, stream };
}
async* _iter() {
for await (let e of this) {
yield e;
}
}
_build(...args) {
if (args.length == 1) {
return this.collectionType().buildStream(args[0]);
} else {
return StreamType.of(args[0]).buildStream(args[1]);
}
}
_singleton(e) {
return this.collectionType().buildStream(b => b.add(e));
}
_repr_() {
return C3.Stream.$objProto._repr_.call(this);
}
elementAgg(...args) {
return C3.Stream.$objProto.elementAgg.call(this, ...args);
}
elementAll(...args) {
return C3.Stream.$objProto.elementAll.call(this, ...args);
}
elementAvg(...args) {
return C3.Stream.$objProto.elementAvg.call(this, ...args);
}
elementCartesianProduct() {
return C3.Stream.$objProto.elementCartesianProduct.call(this);
}
elementMin(...args) {
return C3.Stream.$objProto.elementMin.call(this, ...args);
}
elementMax(...args) {
return C3.Stream.$objProto.elementMax.call(this, ...args);
}
elementSum(...args) {
return C3.Stream.$objProto.elementSum.call(this, ...args);
}
elementStddev(...args) {
return C3.Stream.$objProto.elementStddev.call(this, ...args);
}
elementVariance(...args) {
return C3.Stream.$objProto.elementVariance.call(this, ...args);
}
iter() {
return C3.Stream.$objProto.iter.call(this);
}
_iter_() {
return C3.Stream.$objProto._iter_.call(this);
}
_length_() {
return C3.Stream.$objProto._length_.call(this);
}
collectArrays(...args) {
return C3.Stream.$objProto.collectArrays.call(this, ...args);
}
abs() {
return C3.Stream.$objProto.abs.call(this);
}
aggImplementation(...args) {
return C3.Stream.$objProto.aggImplementation.call(this, ...args);
}
sumDbl() {
return C3.Stream.$objProto.sumDbl.call(this);
}
sumDiff(...args) {
return C3.Stream.$objProto.sumDiff.call(this, ...args);
}
cusum(...args) {
return C3.Stream.$objProto.cusum.call(this, ...args);
}
normalize() {
return C3.Stream.$objProto.normalize.call(this);
}
pluck(...args) {
return C3.Stream.$objProto.pluck.call(this, ...args);
}
first(...args) {
return C3.Stream.$objProto.first.call(this, ...args);
}
firstNotNull(...args) {
return C3.Stream.$objProto.firstNotNull.call(this, ...args);
}
firstNotEmpty(...args) {
return C3.Stream.$objProto.firstNotEmpty.call(this, ...args);
}
last(...args) {
return C3.Stream.$objProto.last.call(this, ...args);
}
lastNotNull(...args) {
return C3.Stream.$objProto.lastNotNull.call(this, ...args);
}
lastNotEmpty(...args) {
return C3.Stream.$objProto.lastNotEmpty.call(this, ...args);
}
minImplementation(...args) {
return C3.Stream.$objProto.minImplementation.call(this, ...args);
}
minBy(...args) {
return C3.Stream.$objProto.minBy.call(this, ...args);
}
maxImplementation(...args) {
return C3.Stream.$objProto.maxImplementation.call(this, ...args);
}
maxBy(...args) {
return C3.Stream.$objProto.maxBy.call(this, ...args);
}
count(...args) {
return C3.Stream.$objProto.count.call(this, ...args);
}
sumImplementation(...args) {
return C3.Stream.$objProto.sumImplementation.call(this, ...args);
}
allImplementation(...args) {
return C3.Stream.$objProto.allImplementation.call(this, ...args);
}
prod(...args) {
return C3.Stream.$objProto.prod.call(this, ...args);
}
avg() {
return C3.Stream.$objProto.avg.call(this);
}
avgDbl() {
return C3.Stream.$objProto.avgDbl.call(this);
}
median() {
return C3.Stream.$objProto.median.call(this);
}
medianDbl() {
return C3.Stream.$objProto.medianDbl.call(this);
}
percentile(...args) {
return C3.Stream.$objProto.percentile.call(this, ...args);
}
percentileDbl(...args) {
return C3.Stream.$objProto.percentileDbl.call(this, ...args);
}
stddev() {
return C3.Stream.$objProto.stddev.call(this);
}
stddevDbl() {
return C3.Stream.$objProto.stddevDbl.call(this);
}
variance() {
return C3.Stream.$objProto.variance.call(this);
}
varianceDbl() {
return C3.Stream.$objProto.varianceDbl.call(this);
}
aggDbl(...args) {
return C3.Stream.$objProto.aggDbl.call(this, ...args);
}
round(...args) {
return C3.Stream.$objProto.round.call(this, ...args);
}
invert() {
return C3.Stream.$objProto.invert.call(this);
}
isMissing() {
return C3.Stream.$objProto.isMissing.call(this);
}
only(...args) {
return C3.Stream.$objProto.only.call(this, ...args);
}
contains(...args) {
return C3.Stream.$objProto.contains.call(this, ...args);
}
containsAll(...args) {
return C3.Stream.$objProto.containsAll.call(this, ...args);
}
containsAny(...args) {
return C3.Stream.$objProto.containsAny.call(this, ...args);
}
findAny(...args) {
return C3.Stream.$objProto.findAny.call(this, ...args);
}
anyNotNull(...args) {
return C3.Stream.$objProto.anyNotNull.call(this, ...args);
}
anyNotEmpty(...args) {
return C3.Stream.$objProto.anyNotEmpty.call(this, ...args);
}
each(...args) {
C3.Stream.$objProto.each.call(this, ...args);
}
eachWhile(...args) {
return C3.Stream.$objProto.eachWhile.call(this, ...args);
}
mapToSame(...args) {
return C3.Stream.$objProto.mapToSame.call(this, ...args);
}
map(...args) {
return C3.Stream.$objProto.map.call(this, ...args);
}
mapToStr(...args) {
return C3.Stream.$objProto.mapToStr.call(this, ...args);
}
mapTo(...args) {
return C3.Stream.$objProto.mapTo.call(this, ...args);
}
flatMapToSame(...args) {
return C3.Stream.$objProto.flatMapToSame.call(this, ...args);
}
flatMap(...args) {
return C3.Stream.$objProto.flatMap.call(this, ...args);
}
flatMapTo(...args) {
return C3.Stream.$objProto.flatMapTo.call(this, ...args);
}
flatMapRecursive(...args) {
return C3.Stream.$objProto.flatMapRecursive.call(this, ...args);
}
fold(...args) {
return C3.Stream.$objProto.fold.call(this, ...args);
}
compact() {
return C3.Stream.$objProto.compact.call(this);
}
unique() {
return C3.Stream.$objProto.unique.call(this);
}
uniqueBy(...args) {
return C3.Stream.$objProto.uniqueBy.call(this, ...args);
}
filter(...args) {
return C3.Stream.$objProto.filter.call(this, ...args);
}
fillMissingBy(...args) {
return C3.Stream.$objProto.fillMissingBy.call(this, ...args);
}
fillMissing(...args) {
return C3.Stream.$objProto.fillMissing.call(this, ...args);
}
fieldNames() {
return C3.Stream.$objProto.fieldNames.call(this);
}
fieldValueType(...args) {
return C3.Stream.$objProto.fieldValueType.call(this, ...args);
}
reject(...args) {
return C3.Stream.$objProto.reject.call(this, ...args);
}
include(...args) {
return C3.Stream.$objProto.include.call(this, ...args);
}
fieldSlice(...args) {
return C3.Stream.$objProto.fieldSlice.call(this, ...args);
}
fieldSelect(...args) {
return C3.Stream.$objProto.fieldSelect.call(this, ...args);
}
exclude(...args) {
return C3.Stream.$objProto.exclude.call(this, ...args);
}
replaceByPredicate(...args) {
return C3.Stream.$objProto.replaceByPredicate.call(this, ...args);
}
sorted(...args) {
return C3.Stream.$objProto.sorted.call(this, ...args);
}
sortedBy(...args) {
return C3.Stream.$objProto.sortedBy.call(this, ...args);
}
sortedIndex(...args) {
return C3.Stream.$objProto.sortedIndex.call(this, ...args);
}
batch(...args) {
return C3.Stream.$objProto.batch.call(this, ...args);
}
partition(...args) {
return C3.Stream.$objProto.partition.call(this, ...args);
}
countBy(...args) {
return C3.Stream.$objProto.countBy.call(this, ...args);
}
every(...args) {
return C3.Stream.$objProto.every.call(this, ...args);
}
flatten(...args) {
return C3.Stream.$objProto.flatten.call(this, ...args);
}
sample(...args) {
return C3.Stream.$objProto.sample.call(this, ...args);
}
slice(...args) {
return C3.Stream.$objProto.slice.call(this, ...args);
}
sliceByKey(...args) {
return C3.Stream.$objProto.sliceByKey.call(this, ...args);
}
summarize(...args) {
return C3.Stream.$objProto.summarize.call(this, ...args);
}
downsample(...args) {
return C3.Stream.$objProto.downsample.call(this, ...args);
}
leastSquares() {
return C3.Stream.$objProto.leastSquares.call(this);
}
rollingDiff(...args) {
return C3.Stream.$objProto.rollingDiff.call(this, ...args);
}
pctChange(...args) {
return C3.Stream.$objProto.pctChange.call(this, ...args);
}
binaryOp(...args) {
return C3.Stream.$objProto.binaryOp.call(this, ...args);
}
unaryOp(...args) {
return C3.Stream.$objProto.unaryOp.call(this, ...args);
}
shape() {
return C3.Stream.$objProto.shape.call(this);
}
dimensionality() {
return C3.Stream.$objProto.dimensionality.call(this);
}
toObj() {
return C3.Stream.$objProto.toObj.call(this);
}
fetch(...args) {
return C3.Stream.$objProto.fetch.call(this, ...args);
}
largest(...args) {
return C3.Stream.$objProto.largest.call(this, ...args);
}
histogram(...args) {
return C3.Stream.$objProto.histogram.call(this, ...args);
}
neg() {
return C3.Stream.$objProto.neg.call(this);
}
describeImplementation(...args) {
return C3.Stream.$objProto.describeImplementation.call(this, ...args);
}
and(...args) {
return C3.Stream.$objProto.and.call(this, ...args);
}
approxMostFrequent(...args) {
return C3.Stream.$objProto.approxMostFrequent.call(this, ...args);
}
or(...args) {
return C3.Stream.$objProto.or.call(this, ...args);
}
timeseries(...args) {
return C3.Stream.$objProto.timeseries.call(this, ...args);
}
stream() {
return C3.Stream.$objProto.stream.call(this);
}
sub(...args) {
return C3.Stream.$objProto.sub.call(this, ...args);
}
mul(...args) {
return C3.Stream.$objProto.mul.call(this, ...args);
}
div(...args) {
return C3.Stream.$objProto.div.call(this, ...args);
}
truediv(...args) {
return C3.Stream.$objProto.truediv.call(this, ...args);
}
floordiv(...args) {
return C3.Stream.$objProto.floordiv.call(this, ...args);
}
mod(...args) {
return C3.Stream.$objProto.mod.call(this, ...args);
}
pow(...args) {
return C3.Stream.$objProto.pow.call(this, ...args);
}
radd(...args) {
return C3.Stream.$objProto.radd.call(this, ...args);
}
rsub(...args) {
return C3.Stream.$objProto.rsub.call(this, ...args);
}
rmul(...args) {
return C3.Stream.$objProto.rmul.call(this, ...args);
}
rdiv(...args) {
return C3.Stream.$objProto.rdiv.call(this, ...args);
}
rtruediv(...args) {
return C3.Stream.$objProto.rtruediv.call(this, ...args);
}
rfloordiv(...args) {
return C3.Stream.$objProto.rfloordiv.call(this, ...args);
}
rmod(...args) {
return C3.Stream.$objProto.rmod.call(this, ...args);
}
rpow(...args) {
return C3.Stream.$objProto.rpow.call(this, ...args);
}
eq(...args) {
return C3.Stream.$objProto.eq.call(this, ...args);
}
gt(...args) {
return C3.Stream.$objProto.gt.call(this, ...args);
}
ge(...args) {
return C3.Stream.$objProto.ge.call(this, ...args);
}
lt(...args) {
return C3.Stream.$objProto.lt.call(this, ...args);
}
le(...args) {
return C3.Stream.$objProto.le.call(this, ...args);
}
ne(...args) {
return C3.Stream.$objProto.ne.call(this, ...args);
}
approxUniqueCount() {
return C3.Stream.$objProto.approxUniqueCount.call(this);
}
approxMedian(...args) {
return C3.Stream.$objProto.approxMedian.call(this, ...args);
}
approxHistogram(...args) {
return C3.Stream.$objProto.approxHistogram.call(this, ...args);
}
truePercent() {
return C3.Stream.$objProto.truePercent.call(this);
}
nullCount() {
return C3.Stream.$objProto.nullCount.call(this);
}
toTypedJson(...args) {
return C3.Stream.$objProto.toTypedJson.call(this, ...args);
}
toJsonString() {
return C3.Stream.$objProto.toJsonString.call(this);
}
toTypedJsonString() {
return C3.Stream.$objProto.toTypedJsonString.call(this);
}
toJsString() {
return C3.Stream.$objProto.toJsString.call(this);
}
toXmlString() {
return C3.Stream.$objProto.toXmlString.call(this);
}
serialize(...args) {
return C3.Stream.$objProto.serialize.call(this, ...args);
}
fingerprint(...args) {
return C3.Stream.$objProto.fingerprint.call(this, ...args);
}
retainedMemory(...args) {
return C3.Stream.$objProto.retainedMemory.call(this, ...args);
}
replaceType(...args) {
return C3.Stream.$objProto.replaceType.call(this, ...args);
}
super(...args) {
return C3.Stream.$objProto.super.call(this, ...args);
}
zip(...args) {
return C3.Stream.$objProto.zip.call(this, ...args);
}
valueType() {
return C3.Stream.$objProto.valueType.call(this);
}
toNative(...args) {
return C3.Stream.$objProto.toNative.call(this, ...args);
}
validated() {
return C3.Stream.$objProto.validated.call(this);
}
inferType() {
return C3.Stream.$objProto.inferType.call(this);
}
hasNullElements() {
return C3.Stream.$objProto.hasNullElements.call(this);
}
isSame(...args) {
return C3.Stream.$objProto.isSame.call(this, ...args);
}
hasSameElements(...args) {
return C3.Stream.$objProto.hasSameElements.call(this, ...args);
}
isUnique() {
return C3.Stream.$objProto.isUnique.call(this);
}
isSorted() {
return C3.Stream.$objProto.isSorted.call(this);
}
isIndexed() {
return C3.Stream.$objProto.isIndexed.call(this);
}
indices() {
return C3.Stream.$objProto.indices.call(this);
}
indexOf(...args) {
return C3.Stream.$objProto.indexOf.call(this, ...args);
}
indexOfAny(...args) {
return C3.Stream.$objProto.indexOfAny.call(this, ...args);
}
lastIndexOf(...args) {
return C3.Stream.$objProto.lastIndexOf.call(this, ...args);
}
lastIndexOfAny(...args) {
return C3.Stream.$objProto.lastIndexOfAny.call(this, ...args);
}
min(...args) {
return C3.Stream.$objProto.min.call(this, ...args);
}
max(...args) {
return C3.Stream.$objProto.max.call(this, ...args);
}
sum(...args) {
return C3.Stream.$objProto.sum.call(this, ...args);
}
all(...args) {
return C3.Stream.$objProto.all.call(this, ...args);
}
agg(...args) {
return C3.Stream.$objProto.agg.call(this, ...args);
}
toArray(...args) {
return C3.Stream.$objProto.toArray.call(this, ...args);
}
toSet(...args) {
return C3.Stream.$objProto.toSet.call(this, ...args);
}
toStream(...args) {
return C3.Stream.$objProto.toStream.call(this, ...args);
}
toMap(...args) {
return C3.Stream.$objProto.toMap.call(this, ...args);
}
toMapOf(...args) {
return C3.Stream.$objProto.toMapOf.call(this, ...args);
}
toMapOfAny(...args) {
return C3.Stream.$objProto.toMapOfAny.call(this, ...args);
}
toMapOfType(...args) {
return C3.Stream.$objProto.toMapOfType.call(this, ...args);
}
toCollection(...args) {
return C3.Stream.$objProto.toCollection.call(this, ...args);
}
toMixingCollection(...args) {
return C3.Stream.$objProto.toMixingCollection.call(this, ...args);
}
toCollectionOfType(...args) {
return C3.Stream.$objProto.toCollectionOfType.call(this, ...args);
}
toInMemory() {
return C3.Stream.$objProto.toInMemory.call(this);
}
box() {
return C3.Stream.$objProto.box.call(this);
}
boxElements() {
return C3.Stream.$objProto.boxElements.call(this);
}
anonymize(...args) {
return C3.Stream.$objProto.anonymize.call(this, ...args);
}
descriptiveStatistics() {
return C3.Stream.$objProto.descriptiveStatistics.call(this);
}
withoutOutliers(...args) {
return C3.Stream.$objProto.withoutOutliers.call(this, ...args);
}
extractOutliers(...args) {
return C3.Stream.$objProto.extractOutliers.call(this, ...args);
}
isOutlier(...args) {
return C3.Stream.$objProto.isOutlier.call(this, ...args);
}
with(...args) {
return C3.Stream.$objProto.with.call(this, ...args);
}
withSome(...args) {
return C3.Stream.$objProto.withSome.call(this, ...args);
}
withAll(...args) {
return C3.Stream.$objProto.withAll.call(this, ...args);
}
without(...args) {
return C3.Stream.$objProto.without.call(this, ...args);
}
withoutSome(...args) {
return C3.Stream.$objProto.withoutSome.call(this, ...args);
}
withoutAny(...args) {
return C3.Stream.$objProto.withoutAny.call(this, ...args);
}
withoutAll(...args) {
return C3.Stream.$objProto.withoutAll.call(this, ...args);
}
difference(...args) {
return C3.Stream.$objProto.difference.call(this, ...args);
}
unzip() {
return C3.Stream.$objProto.unzip.call(this);
}
mergeSimilar(...args) {
return C3.Stream.$objProto.mergeSimilar.call(this, ...args);
}
mergeChildren(...args) {
return C3.Stream.$objProto.mergeChildren.call(this, ...args);
}
visit(...args) {
return C3.Stream.$objProto.visit.call(this, ...args);
}
withDefaults(...args) {
return C3.Stream.$objProto.withDefaults.call(this, ...args);
}
evalTimeseries(...args) {
return C3.Stream.$objProto.evalTimeseries.call(this, ...args);
}
groupBy(...args) {
return C3.Stream.$objProto.groupBy.call(this, ...args);
}
resample(...args) {
return C3.Stream.$objProto.resample.call(this, ...args);
}
rolling(...args) {
return C3.Stream.$objProto.rolling.call(this, ...args);
}
_item_(...args) {
return C3.Stream.$objProto._item_.call(this, ...args);
}
toData() {
return C3.Stream.$objProto.toData.call(this);
}
replace(...args) {
return C3.Stream.$objProto.replace.call(this, ...args);
}
initial(...args) {
return C3.Stream.$objProto.initial.call(this, ...args);
}
pairs() {
return C3.Stream.$objProto.pairs.call(this);
}
closed() {
return C3.Stream.$objProto.closed.call(this);
}
limit(...args) {
return C3.Stream.$objProto.limit.call(this, ...args);
}
offset(...args) {
return C3.Stream.$objProto.offset.call(this, ...args);
}
concat(...args) {
return C3.Stream.$objProto.concat.call(this, ...args);
}
split(...args) {
return C3.Stream.$objProto.split.call(this, ...args);
}
shuffle(...args) {
return C3.Stream.$objProto.shuffle.call(this, ...args);
}
buffer(...args) {
return C3.Stream.$objProto.buffer.call(this, ...args);
}
peek(...args) {
return C3.Stream.$objProto.peek.call(this, ...args);
}
}
$protos.AsyncStreamBase = AsyncStreamBase;
var $protos = $protos ?? {};
function sync() {
return this.connection().typeSystem();
}
function async() {
return this.connection().asyncTypeSystem();
}
function c3() {
return C3;
}
function clearCache(typeName, reimport) {
if (Val.isEmpty(typeName)) {
delete this.$names;
Object.defineProperty(this, '$cache', { value: {}, configurable: true });
this.connection().clearTypeCache();
} else {
let loaded = this.$conn.$typeCache[typeName] ? this.type(typeName) : undefined;
if (loaded != null) {
let subTypes = loaded.meta().subTypeNames();
subTypes.forEach(subTypeName => _clearCacheForSingleType(subTypeName, this, reimport));
_clearCacheForSingleType(typeName, this, reimport);
} else {
delete this.$cache[typeName];
}
if (reimport && _shouldImport(this, typeName)) {
this.$imported[typeName] = this.type(typeName);
}
}
}
function _shouldImport(ts, typeName) {
return typeName.indexOf('.') < 0 && typeName.indexOf('<') < 0 && ts.$imported != null;
}
function _clearCacheForSingleType(typeName, ths, reimport) {
delete ths.$cache[typeName];
ths.connection().clearTypeCache(typeName);
if (ths.$imported != null && ths.$imported[typeName] && ths.$imported[typeName].$c3type) {
delete ths.$imported[typeName];
}
if (reimport && _shouldImport(ths, typeName)) {
ths.$imported[typeName] = ths.type(typeName);
}
}
function cacheContainsType(typeName) {
return !!this.$cache[typeName];
}
function connection() {
return this.$conn;
}
function trackTypeChanges(notify) {
if (this.$trackTypeChanges == null) {
const listenRes = Pkg.listen();
Object.defineProperty(this, '$trackTypeChanges', { value: {
listenRes,
notify: [],
}});
listenRes.eventStream.onNext(e => {
if (this.$trackTypeChanges == null || e.kind == Pkg.Event.Kind.INFO) return;
const typeName = e.typeName();
if (typeName != null) {
let part = e.typePart();
let added = false;
let removed = false;
if (part === Pkg.File.TypePart.DEFINITION) {
added = e.kind === Pkg.Event.Kind.ADD;
removed = e.kind === Pkg.Event.Kind.REMOVE;
}
if (added) {
if (this.$names && this.$names.indexOf(typeName) < 0) {
Object.defineProperty(this, '$names', { value: this.$names.concat(typeName), configurable: true });
}
}
this.clearCache(typeName, !removed);
this.$trackTypeChanges.notify.forEach(cb => cb(e));
}
});
}
if (typeof notify === 'function' && this.$trackTypeChanges.notify.indexOf(notify) < 0) {
this.$trackTypeChanges.notify.push(notify);
}
}
function callRequest(typeName, methodName, ...args) {
return this.$conn.callRequest(typeName, methodName, ...args);
}
function inheritanceInvoker(mixin, funk) {
let f = function (...args) {
if (!this.$chain) {
return funk.apply(this, args);
}
this.$chain.push(mixin);
let rtn;
try {
rtn = funk.apply(this, args);
} finally {
this.$chain.pop();
}
return rtn;
};
Object.defineProperties(f, {
$impl: { value: funk.$impl || funk },
$wrapped: { value: funk },
});
return f;
}
class PropertyStub {
get [Symbol.toStringTag]() {
return 'PropertyStub';
}
toString() {
return '(proxy stub)';
}
}
const STUB = new PropertyStub();
function _instProxy(ts, name, type, preloaded) {
let wrapper = {};
let initialized = false;
function initialize(target) {
initialized = true;
if (ts.$conn.$interactive) {
if (type.$loaded.isWithType && !_hasOwnProperty(target, 'type')) {
target.type = STUB;
}
if (type.$init.fieldTypes) {
type.$init.fieldTypes.forEach(ft => {
if (!_hasOwnProperty(target, ft.name)) {
target[ft.name] = STUB;
}
});
}
if (type.$init.methods) {
type.$init.methods.forEach(m => {
if (m.hasAnyMember && !_hasOwnProperty(target, m.name)) {
target[m.name] = STUB;
}
});
}
}
}
Object.defineProperty(wrapper, '$initialize', { value: () => initialize(wrapper) });
if (preloaded) {
initialize(wrapper);
}
var objProxy;
let methods = {
get: (target, property, receiver) => {
if (_hasOwnProperty(target, property) &&
target[property] !== target.__proto__[property] &&
target[property] !== STUB) {
return target[property];
}
if (type.$loaded.$objProto && property in type.$loaded.$objProto &&
type.$loaded.$objProto[property] !== type.$loaded.$objProto.__proto__[property]) {
if (property === 'type' && type.$loaded.$withType) {
return target.type = function() { return type; };
}
if (/^\$/.test(property)) {
return type.$loaded.$objProto[property];
}
}
if (property == 'super') {
let currType = receiver.$chain[receiver.$chain.length - 1];
return _objSuper(ts, currType, receiver);
} else if (property == '$c3inst') {
return type;
} else if (property == '$c3obj') {
return type.$loaded.$init.isObj;
} else {
let ft = type.$fieldMap.get(property);
if (ft && ft.constant) {
return ft.defaultValue;
}
let f;
let method = type.$memberMap.get(property);
if (method != null) {
let chainedType = type;
if (_hasOwnProperty(type.$loaded.$objProto, property) &&
typeof type.$loaded.$objProto[property] == 'function' &&
type.$loaded.$objProto[property] !== type.$loaded.$objProto.__proto__[property]) {
f = type.$loaded.$objProto[property];
}
if (method.$nearestImplementedOn != null && method.$nearestImplementedOn != name && !type.$forceRemote) {
let mixin = ts.sync().type(method.$nearestImplementedOn, true);
let mf = mixin.$objProto[property];
if (typeof mf === 'function') {
chainedType = mixin;
if (!mf.$delegate) {
f = mf;
}
}
}
let delegate = false;
if (f == null) {
f = function (...args) {
return ts.call.apply(ts, [name, property, this].concat(args));
};
delegate = true;
}
if (method.isCached) {
const impl = f;
f = _cached(name, method, impl);
}
if (method.isProperty && receiver != type.$objProto) {
return f.call(receiver);
}
if (type.$loaded.$init.isWithType) {
f = inheritanceInvoker(chainedType, f);
}
if (delegate) {
Object.defineProperty(f, '$delegate', { value: true });
}
} else if (property == 'toString') {
f = new Function(`return "[object ${name}]";`);
}
if (f != null)
return target[property] = f;
}
if (type.$loaded.$objProto && property in type.$loaded.$objProto)
return type.$loaded.$objProto[property];
},
has: (target, property) => {
return (property in target && target[property] !== STUB) || type.$memberMap.has(property);
},
ownKeys: (target) => {
let keys = [];
Reflect.ownKeys(target).forEach(name => {
if (target[name] !== STUB) {
keys.push(name);
}
});
for (let [name, _m] of type.$memberMap) {
if (keys.indexOf(name) < 0) {
keys.push(name);
}
}
return keys;
},
getOwnPropertyDescriptor: (target, property) => {
if (property in target && target[property] !== STUB) {
return Object.getOwnPropertyDescriptor(target, property);
}
if (type.$memberMap.has(property))
return { configurable: true, enumerable: true };
}
};
objProxy = new Proxy(wrapper, methods);
return objProxy;
}
function _objSuper(ts, type, ths) {
return function (mixin) {
let mixinName;
if (mixin == null)
mixinName = undefined;
else if (mixin.$c3type)
mixinName = mixin.name();
else
mixinName = String(mixin);
const obj = ths; // the called on Obj instance
return new Proxy({}, {
get: (target, property, receiver) => {
if (property in target)
return target[property];
if (property === 'type' && type.$withType)
return target.type = _typeSuper(ts, type);
let method = type.$methods.find(m => m.name == property && m.hasAnyMember);
if (method != null) {
if (mixinName === type.meta().prototypeName()) {
return function (...args) {
return ts.call.apply(ts, [type.name(), property, obj].concat(args));
};
} else {
let mx = _findSuperMixin(ts, type, mixinName, method);
return inheritanceInvoker(mx, mx.$objProto[property]).bind(obj);
}
} else {
return obj[property];
}
}
});
};
}
function _typeProxy(ts, name, preloaded) {
let wrapper = Object.create({}, {
name: { value: function () { return name; }, enumerable: true },
typeSystem: { value: function () { return ts; }, enumerable: true },
$c3type: { value: true },
});
var typeProxy;
const propsKey = 'type-' + name + '-properties';
function setup(loaded, proxied) {
Object.defineProperty(proxied, '$loaded', { value: loaded });
let methods = loaded.$init.methods || [];
Object.defineProperty(proxied, '$methods', { value: methods });
let cache = new SimpleCache(name);
Object.defineProperty(proxied, '$cache', { value: cache });
methods.forEach(m => {
if (typeof loaded[m.name] == 'function' && m.isCached && m.hasAnyStatic) {
let property = m.name;
let impl = loaded[property];
Object.defineProperty(proxied, property, {
value: function (...args) {
return this.$cache.get(property, false, () => impl.apply(this, args));
}
});
}
});
if (loaded.$init.innerTypeNames) {
loaded.$init.innerTypeNames.forEach(innerName => {
let fullName = name + '.' + innerName;
proxied[innerName] = ts.type(fullName);
});
}
const fieldMap = new Map();
if (loaded.$init.fieldTypes) {
loaded.$init.fieldTypes.forEach(ft => fieldMap.set(ft.name, ft));
}
Object.defineProperty(proxied, '$fieldMap', { value: fieldMap });
const memberMap = new Map();
methods.forEach(m => {
if (m.hasAnyMember) {
memberMap.set(m.name, m);
}
});
Object.defineProperty(proxied, '$memberMap', { value: memberMap });
let bf = loaded.builder;
if (typeof bf == 'function' && bf.$std) {
proxied.builder = function (inst) {
let b = bf.call(typeProxy, inst);
b.$setup = function (inst) {
_setupInst(inst, typeProxy);
};
b.$findType = function(type, fields) {
let typeSerName = type.$init.typeSerName || 'type';
if (typeof fields[typeSerName] === 'string' && fields[typeSerName] !== name) {
type = ts.type(fields[typeSerName], true);
}
return type;
};
b.$makeField = function (ft, value) {
let vt = typeof ft.valueType === 'function' ? ft.valueType() : ft.valueType;
return _make(ts.$conn, value, vt, loaded.$init.isStateful);
};
return b;
};
} else {
proxied.$setupInst = function (inst) {
_setupInst(inst, typeProxy);
};
}
if (ts.$conn.$interactive) {
let properties = ['type', 'meta'];
if (!_hasOwnProperty(proxied, 'type')) {
proxied.type = STUB;
}
if (!_hasOwnProperty(proxied, 'meta')) {
proxied.meta = STUB;
}
if (loaded.$init.methods) {
loaded.$init.methods.forEach(m => {
if (m.hasAnyStatic || loaded.$defaultInst) {
properties.push(m.name);
if (!_hasOwnProperty(proxied, m.name)) proxied[m.name] = STUB;
}
});
}
if (loaded.$init.fieldTypes) {
loaded.$init.fieldTypes.forEach(ft => {
if (ft.constant) {
properties.push(ft.name);
if (!_hasOwnProperty(proxied, ft.name)) proxied[ft.name] = STUB;
}
});
}
if (ts.$conn.$localStorage) {
ts.$conn.$localStorage.setItem(propsKey, JSON.stringify(properties));
}
}
if (typeof proxied?.$objProto?.$initialize === 'function') {
proxied.$objProto.$initialize();
}
}
if (preloaded != null) {
setup(preloaded, wrapper);
} else if (ts.$conn.$interactive && ts.$conn.$localStorage) {
try {
const value = ts.$conn.$localStorage.getItem(propsKey);
const properties = value != null ? JSON.parse(value) : null;
if (Array.isArray(properties)) {
properties.forEach(p => {
if (!_hasOwnProperty(wrapper, p)) wrapper[p] = STUB;
});
}
} catch (e) {}
}
function loadedType(target) {
if (target.$loaded == null) {
setup(ts.$conn._loadType(name, true), target);
}
return target.$loaded;
}
function isSingletonField(target, property) {
return loadedType(target).$singleton && loadedType(target).$init.fieldTypes &&
loadedType(target).$init.fieldTypes.find(ft => ft.name == property && !ft.constant) &&
!Type.$init.methods.find(m => m.name === property);
}
typeProxy = new Proxy(wrapper, {
get: (target, property, receiver) => {
if (property == 'toString' || property == Symbol.toPrimitive ||
property == 'toJson' || property == 'toJSON' || property == 'toTypedJson') {
return new Function('return ' + _quote(name) + ';');
}
if (property in target && target[property] !== STUB) {
return target[property];
}
if (target.$loaded == null) {
if (property == 'then') return; // promise resolution calls this when returned from AsyncTypeSystem.type()
loadedType(target);
if (property in target && target[property] !== STUB) {
return target[property];
}
}
let f;
if (property in loadedType(target)) {
let p = loadedType(target)[property];
if (typeof p == 'function') {
f = inheritanceInvoker(receiver, p);
} else {
return target[property] = p;
}
}
if (isSingletonField(target, property)) {
let inst = typeProxy.inst();
return inst[property];
}
if (f == null) {
if (property == 'type') {
f = function () {
return ts.type('Type', true);
};
} else if (property == 'meta') {
f = function () {
return target.$cache.get('meta', false,
() => _make(ts.connection(), { ...wrapper.$loaded.$init, toType: typeProxy },
{ type: "ReferenceType", name: "TypeMeta" }));
};
} else if (property == 'myReferenceType') {
f = function () {
return target.$cache.get('myReferenceType', false,
() => _make(ts.connection(), { name, dereference: typeProxy },
{ type: "ReferenceType", name: "ReferenceType" }));
};
} else if (property == 'bindVar') {
f = function (...args) {
let bindings = args.length == 1 && Array.isArray(args[0]) ? args[0] : args;
let boundName = name + '<' + bindings.map(vt => vt.toString()).join(", ") + '>';
return C3.type(boundName);
};
} else if (property == 'super') {
const currType = receiver.$chain[receiver.$chain.length - 1];
return _typeSuper(ts, currType, receiver);
} else if (property == '_construct') {
f = function _construct() {
let inst = Object.create(this.$objProto);
_setupInst(inst, typeProxy);
return inst;
}
} else {
let method = target.$methods.find(m => m.name == property);
if (method != null && (method.hasAnyStatic || loadedType(target).$defaultInst)) {
let chainedType = receiver;
if (method.$nearestImplementedOn != null && method.$nearestImplementedOn != name) {
let mixin = ts.sync().type(method.$nearestImplementedOn, true);
let mf = mixin[property];
if (typeof mf === 'function') {
chainedType = mixin;
if (!mf.$delegate) {
f = mf;
}
}
}
let delegate = false;
if (f == null) {
if (loadedType(target).$defaultInst && method.hasAnyMember) {
f = function (...args) {
let inst = typeProxy.inst();
return inst[property].apply(inst, args);
};
} else if (method.isCached) {
f = _cached(name, method, (...args) => ts.call.apply(ts, [name, property, typeProxy].concat(args)));
} else {
f = function (...args) {
return ts.call.apply(ts, [name, property, typeProxy].concat(args));
};
}
delegate = true;
}
f = inheritanceInvoker(chainedType, f);
if (delegate) {
Object.defineProperty(f, '$delegate', { value: true });
}
} else {
let typeType = name === 'Type' ? target : ts.$conn.typeSystem().type('Type');
method = typeType.$methods.find(m => m.name == property);
if (method != null && method.hasAnyMember) {
f = typeType.$objProto[method.name];
}
}
}
}
if (f != null)
return target[property] = f;
},
has: (target, property) => {
if (property in target && target[property] !== STUB) {
return true;
}
const loaded = loadedType(target);
if (loaded.$init.fieldTypes.find(ft => ft.name == property && ft.constant)) {
return true;
}
if (target.$methods.find(m => m.name == property && (m.hasAnyStatic || loaded.$defaultInst)) != null) {
return true;
}
return false;
},
ownKeys: (target) => {
const loaded = loadedType(target);
let keys = [];
Reflect.ownKeys(target).forEach(name => {
if (target[name] !== STUB) keys.push(name);
});
loaded.$init.fieldTypes.forEach(ft => {
if (ft.constant && keys.indexOf(ft.name) < 0) keys.push(ft.name);
});
target.$methods.forEach(m => {
if ((m.hasAnyStatic || loaded.$defaultInst) && keys.indexOf(m.name) < 0)
keys.push(m.name);
});
return keys;
},
getOwnPropertyDescriptor: (target, property) => {
if (property in target && target[property] !== STUB) {
return Object.getOwnPropertyDescriptor(target, property);
}
const loaded = loadedType(target);
if (target.$methods.find(m => m.name == property && (m.hasAnyStatic || loaded.$defaultInst)) != null ||
loaded.$init.fieldTypes.find(ft => ft.name === property && ft.constant) != null) {
return { configurable: true, enumerable: true };
}
},
set: (target, property, value) => {
if (isSingletonField(target, property) && loadedType(target).$singleton) {
let inst = typeProxy.inst();
inst[property] = value;
return true;
}
return false;
},
deleteProperty: (target, property) => {
if (isSingletonField(target, property) && loadedType(target).$singleton) {
let inst = typeProxy.inst();
delete inst[property];
return true;
}
return false;
},
});
Object.defineProperty(wrapper, '$objProto', { value: _instProxy(ts, name, typeProxy, preloaded) });
Object.defineProperty(wrapper, '$chain', { value: [typeProxy] });
return typeProxy;
}
function _typeSuper(ts, type, ths) {
var proxy;
if (!ths) {
ths = type;
}
return function () {
if (proxy == null) {
let name = type.name() + '.super()';
proxy = new Proxy({}, {
get: (target, property, receiver) => {
if (property in target)
return target[property];
if (property == 'name')
return target[property] = new Function('return "' + name + '";');
if (property == 'meta' || property == 'super')
return target[property] = new Function(`throw Error('No ${property} for "${name}".');`);
let method = type.$methods.find(m => m.name == property);
if (method != null) {
var mx = _findSuperMixin(ts, type, null, method);
return target[property] = inheritanceInvoker(mx, mx[property]).bind(ths);
} else {
return ths[property];
}
}
});
}
return proxy;
};
}
function _findSuperMixin(ts, type, startName, method) {
let mixinType;
if (startName == null) {
type.meta().mixins().forEach(mx => {
if (mixinType != null)
return;
if (mx.meta().method(method.name) != null)
mixinType = mx;
});
if (mixinType == null)
throw new Error(`No mixin of ${type.name()} implements ${method.name} for super().`);
} else
mixinType = type.meta().mixin(startName, true);
if (!mixinType.$c3type)
mixinType = ts.type(mixinType.name, true);
return mixinType;
}
function _deser(conn, data, vt, mutableParent) {
if (data != null && typeof data === 'object') {
let keys = Object.keys(data).join();
if ((keys === 'type' || keys === 'type,value') && typeof data.type === 'string') {
vt = ValueType.fromString(data.type);
if (vt.isReference() && vt.prototypeName() === 'Boxed') {
vt = vt.dereference(true).meta().varBinding('V', true);
}
if (vt.name === 'Type' && typeof data.value === 'string') {
return conn.typeSystem().type(data.value, true);
}
if (!vt.isReference()) {
data = data.value;
if (keys === 'type') {
data = vt.defaultEmptyValue();
}
}
}
let type;
if (_valueType(vt) === 'ReferenceType') {
if (typeof data.type === 'string' && data.type !== vt.name) {
type = conn.typeSystem().type(data.type, true);
} else {
type = conn.typeSystem().type(vt.name, true);
}
} else if ((_valueType(vt) === 'AnyType' || _valueType(vt) === 'AnyOfType') && typeof data.type === 'string') {
type = conn.typeSystem().type(data.type, false);
}
if (type && type.$fromJson) {
return type.fromJson(data);
}
if (type && conn.$syncFull?.$imported) {
vt = type.meta().referenceType();
}
}
return _make(conn, data, vt, mutableParent, true);
}
function _make(conn, data, vt, mutableParent, deser) {
if (data == null) {
if (_isBoolean(vt) && vt.modifier === 'NON_EMPTY')
return false;
else if (!_isSpecificCollection(vt))
return null;
}
if (typeof data === 'object' && !!data && !!data.type && typeof data.type === 'string' && /^Boxed</.test(data.type)) {
return _deser(conn, data, vt, mutableParent);
}
let made;
let mutable = false;
let vtType = _valueType(vt);
if (vtType == 'VarReferenceType') {
if (vt.restriction != null) {
vt = vt.restriction;
vtType = _valueType(vt);
} else {
vt = AnyType.inst();
vtType = 'AnyType';
}
}
if (_isAnyCollection(vt)) {
if (_hasOwnProperty(data, 'type') && typeof data.type === 'string') {
vt = ValueType.fromString(data.type);
vtType = vt.type().name();
} else if (vtType === 'ReferenceType' && data != null && data.$c3coll) {
return data;
}
}
if (vtType == 'ArrayType') {
made = _array(conn, vt, mutableParent, data);
mutable = mutableParent;
} else if (vtType == 'SetType') {
made = _set(conn, vt, mutableParent, data);
mutable = mutableParent;
} else if (vtType == 'MapType') {
made = _map(conn, vt, mutableParent, data);
mutable = mutableParent;
} else if (_isTuple(vt)) {
if (Val.isTuple(data)) return data;
if (Object.keys(data).join() === 'type,values') {
let tt = ValueType.fromString(data.type);
made = tt.makeValue(data.values);
} else if (data.constructor.name === 'Object' && /^[!?]*\{/.test(data.type)) {
let tt = ValueType.fromString(data.type);
made = tt.makeValue(data);
} else {
if (vt.constructor.name === 'Object' && vt.type === 'TupleType') vt = TupleType.make(vt);
made = vt.makeValue(data);
}
mutable = false;
} else if (vtType == 'StreamType') {
made = _stream(conn, vt, mutableParent, data);
mutable = false;
} else if (vtType == 'ReferenceType') {
if (vt.name == 'Type') {
if (typeof data === 'string') {
return conn.typeSystem().type(data, true);
}
if (data.$c3type) {
return data;
}
}
if (data.$c3inst != null) {
const type = data.$c3inst;
if (!!type.meta && type.meta().isA(vt.name)) {
return data;
} else if (typeof type.then === 'function') {
return type.then(res => {
if (res.meta().isA(vt.name)) {
return data;
}
throw new Error(`Instance of type ${res.type().name()} does not match ${vt.name}`);
});
} else {
throw new Error(`Instance of type ${data.type().name()} does not match ${vt.name}`);
}
} else {
let typeName = vt.name;
let type = conn.typeSystem().type(typeName, true);
let typeSerName = type.$init.typeSerName || 'type';
if (typeof data[typeSerName] === 'string' && data[typeSerName] != typeName) {
typeName = data[typeSerName];
type = conn.typeSystem().type(typeName, true);
}
mutable = type.$init.isStateful;
if (/^Array</.test(typeName)) {
return _make(conn, data, ArrayType.of(type.meta().varBinding('E', true)), mutableParent, deser);
} else if (/^Set</.test(typeName)) {
return _make(conn, data, SetType.of(type.meta().varBinding('E', true)), mutableParent, deser);
} else if (/^Map</.test(typeName)) {
return _make(conn, data,
MapType.of(type.meta().varBinding('K', true)),
MapType.of(type.meta().varBinding('E', true)),
mutableParent, deser);
} else if (/^Stream</.test(typeName)) {
return _make(conn, data, StreamType.of(type.meta().varBinding('E', true)), mutableParent, deser);
}
if (/^Data.Lazy/.test(typeName) && data["lazies"]!=null || typeName == 'Action') {
return _deser(conn, data, vt, mutableParent)
}
let memoized = [];
if (type.$objProto) {
type.$methods.forEach(m => {
let serName = _annValue(m.overloads[0], 'ser', 'name') ?? m.name;
if (serName != 'type' && _hasOwnProperty(data, serName)) {
if (Object.isFrozen(data))
data = Object.assign({}, data);
memoized.push({ method: m, value: data[serName] });
delete data[serName];
}
});
}
if (deser && type.$init.hasSerNameFields) {
type.meta().fieldTypes().forEach(ft => {
if (ft.serName() !== ft.name && _hasOwnProperty(data, ft.serName()) && !_hasOwnProperty(data, ft.name)) {
if (Object.isFrozen(data)) {
data = Object.assign({}, data);
}
data[ft.name] = data[ft.serName()];
delete data[ft.serName()];
}
});
}
made = type._instantiate(data);
if (made) {
_setupInst(made, type);
memoized.forEach(info => {
let { method, value } = info, property = method.name;
if (method.cachedKey == 'arg') {
let cache = new SimpleCache(type.name(), property, method.mergeOverloads.params[0].default);
if (value != null) {
if (method.mergeOverloads.params[0].default) {
let wrapped = {};
let key = String(method.mergeOverloads.params[0].default);
wrapped[key] = value;
value = wrapped;
}
let vt = _returnType(typeName, method.name, method.mergedReturnType);
Object.keys(value).forEach(k => {
cache.putLambda(k, () => _make(conn, value[k], vt, mutable, deser));
});
}
made.$cache.put(property, cache);
} else {
made.$cache.putLambda(property, () => _make(conn, value,
_returnType(typeName, method.name, method.mergedReturnType),
mutable, deser));
}
});
}
}
} else if (_isNumber(vt)) {
if (vtType == 'BigIntType' || vtType === 'IntType' && _annValue(vt, 'js', 'bigInt') === true) {
try {
made = BigInt(data);
} catch (e) {
made = null;
}
} else if (typeof data == 'number') {
made = data;
} else if (typeof data == 'string') {
made = parseFloat(data);
} else
made = NaN;
if (typeof made === 'number' && vtType != 'FloatType' && vtType != 'DoubleType' && isNaN(made)) {
made = null;
}
} else if (vtType == 'BooleanType') {
if (typeof data == 'boolean')
made = data;
else if (data.type == 'number')
made = data !== 0;
else if (data.type == 'string')
made = data !== 'false' && data !== '';
else
made = true;
} else if (vtType == 'StringType') {
made = String(data);
if (made.trim() === '' && vt.modifier !== 'PRESERVES_EMPTY') {
made = null;
}
} else if (vtType == 'DateTimeType') {
made = data instanceof DateTime ? data : DateTime.fromString(String(data));
} else if (vtType == 'BinaryType') {
if (data instanceof ArrayBuffer)
made = data;
else if (ArrayBuffer.isView(data))
made = data.buffer;
else
made = Base64.decode(data);
} else if (vtType == 'JsonType') {
made = data;
} else if (vtType == 'LambdaType') {
if (typeof data === 'function') {
made = data;
} else if (typeof data === 'object') {
made = LambdaType.make().makeValue(data);
}
} else if (vtType == 'EventStreamType') {
vt = ValueType.fromString(data.type);
return _make(conn, data.id, vt, mutableParent, deser);
} else if (vtType == 'NativeType') {
made = data;
mutable = true;
} else if (vtType == 'AnyOfType') {
let guess = ValueType.guessConvertibleType(data);
let r = vt.restrictions.find(r => !r.exclude && _isA(conn, guess, r.valueType));
if (r == null && guess != null && guess.isDouble() && Math.round(data) === data) {
r = vt.restrictions.find(r => !r.exclude && _isInt(r.valueType));
}
if (r == null && typeof data === 'object' && data.constructor.name === 'Object') {
r = vt.restrictions.find(r => !r.exclude && _isMap(r.valueType));
}
if (r == null) {
throw new Error(`Invalid value "${data}" for anyof.`);
}
return _make(conn, data, r.valueType, mutableParent, deser);
} else if (vtType == 'AnyType') {
let guess = ValueType.guessConvertibleType(data);
if (guess != null) {
return _make(conn, data, guess, mutableParent, deser);
} else {
made = data;
}
} else {
throw new Error(`Unsupported value type ${vtType} to make.`);
}
return mutable ? made : Object.freeze(made);
}
function _isBoolean(vt) {
return _valueType(vt) === 'BooleanType';
}
function _isAnyCollection(vt) {
let vtType = _valueType(vt);
if (vtType === 'ReferenceType' && /^Collection(<.*)?$/.test(vt.name)) return true;
return _isSpecificCollection(vt);
}
function _isSpecificCollection(vt) {
let vtType = _valueType(vt);
return vtType === 'ArrayType' || vtType === 'SetType' || vtType === 'MapType' || vtType === 'StreamType';
}
function _isMap(vt) {
return _valueType(vt) === 'MapType';
}
function _isTuple(vt) {
let vtType = _valueType(vt);
if (vtType === 'ReferenceType' && vt.name === 'Tuple') return true;
return vtType === 'TupleType';
}
function _isInt(vt) {
return _valueType(vt) === 'IntType';
}
function _isNumber(vt) {
let vtType = _valueType(vt);
return vtType == 'ByteType' ||
vtType == 'DecimalType' ||
vtType == 'DoubleType' ||
vtType == 'FloatType' ||
vtType == 'IntType' ||
vtType == 'Int16Type' ||
vtType == 'Int32Type' ||
vtType == 'BigIntType' ||
vtType == 'NumberType';
}
function _isDateTime(vt) {
return _valueType(vt) == 'DateTimeType';
}
function _valueType(vt) {
return typeof vt.type === 'function' ? vt.type().name() : vt.type;
}
function _isA(conn, ths, other) {
if (_isDateTime(ths) && _isA(conn, other, DateTime.myReferenceType())) {
return true;
}
if (typeof ths.type === 'function' && typeof other.type === 'function') {
return ths.isA(other);
}
let otherType = typeof other.type === 'function' ? other.type().name() : other.type;
if (otherType == 'AnyType') {
return true;
}
if (_isNumber(ths) && otherType == 'NumberType') {
return true;
}
if (ths.isBoxed()) {
let unBoxed = ths.unboxType();
if (unBoxed.isPrimitive()) {
return ths.unboxPrimitiveType().$cache.type === otherType;
} else {
ths = unBoxed;
}
}
if (typeof ths.type === 'function') {
let vt = _make(conn, other, ValueType.myReferenceType(), false);
return ths.isA(vt);
} else {
return ths.type === otherType;
}
}
function _annValue(vt, ann, field) {
if (typeof vt.annotationValue === 'function')
return vt.annotationValue(ann, field);
if (vt.annotationsJson != null) {
return vt.annotationsJson.reduce((found, a) => {
if (found == null && a[ann] instanceof Array) {
found = a[ann].reduce((prev, f) => f.name == field ? f.value : prev, undefined);
}
if (typeof found === 'string' && typeof Str !== 'undefined') found = Str.unquote(found);
return found;
}, undefined);
}
}
function _makeCallResponse(conn, typeName, action, rsp, method) {
if (rsp.statusCode != 200 && rsp.statusCode != 204) {
return _handleUnsuccessfulCallResponse(conn, typeName, action, rsp);
}
if (method.mergedReturnType != null) {
let data;
if (rsp.statusCode == 204) {
data = null;
} else {
try {
data = rsp.json();
} catch (e) {
throw new Error('Action ' + typeName + '.' + action + ' returned invalid data.\n' + e);
}
}
return _deser(conn, data,
_returnType(typeName, action, method.mergedReturnType),
conn.typeSystem().type(typeName, true).$init.isStateful);
}
}
function _handleUnsuccessfulCallResponse(conn, typeName, action, rsp) {
if (rsp.statusCode === 302 && typeof conn.$tokenExpirationHandler === 'function' && typeof conn.$redirectLoginHandler === 'function') {
if (conn.$handlingTokenExpiration === true ) {
return;
} else {
Object.defineProperty(conn, '$handlingTokenExpiration', { value: true, configurable: true, writable: true });
}
return conn.$tokenExpirationHandler(rsp, conn.$redirectLoginHandler).then(function (token) {
if (!token) {
throw new Error('Failed to get the valid token from Idp login');
}
conn.$authz = token;
let ts = conn.typeSystem();
let args = rsp.request.entity && JSON.parse(rsp.request.entity).slice(1);
return ts.call.apply(ts, [typeName.name(), action, typeName].concat(args));
}).catch((e) => {
throw new Error(e);
}).finally(() => {
conn.$handlingTokenExpiration = false;
});
} else {
let m;
if (rsp.headers == null || rsp.headers['content-type'] == null || rsp.headers['content-type'] == 'text/plain') {
m = rsp.string();
} else if (rsp.headers['content-type'] == 'application/json') {
try {
m = rsp.json().message;
} catch (e) {
if (rsp.statusCode == 500) {
if (/^\s*[A-Z]/.test(rsp.string())) {
m = rsp.string();
}
}
}
}
if (m == null || m === '') {
m = 'Action ' + typeName + '.' + action + ' failed with status ' + rsp.statusCode + '.';
}
throw new Error(m);
}
}
function _returnType(typeName, action, vt) {
if (vt == null)
throw new Error('Missing return type for method ' + typeName + '.' + action);
return vt;
}
function _filterTypeNames(allNames, includeInnerTypes) {
return includeInnerTypes ? allNames : allNames.filter(n => n.indexOf('.') < 0);
}
class ImmutableArray extends ArrayBase {
constructor(vt) {
super(vt);
}
}
$protos.ImmutableArray = ImmutableArray;
class MutableArray extends ArrayBase {
constructor(vt) {
super(vt);
Object.defineProperty(this, '$mutable', { value: true });
}
}
$protos.MutableArray = MutableArray;
function _array(conn, vt, mutable, data) {
const MUTATORS = ['fill', 'pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'];
let array = mutable ? new MutableArray(vt) : new ImmutableArray(vt);
if (data != null) {
if (Array.isArray(data)) {
data.forEach(e => Array.prototype.push.call(array, _make(conn, e, vt.elementType, mutable)));
} else {
throw new Error(`Invalid value "${data}" to make an Array.`);
}
}
if (mutable) {
let proxy;
let $onChange, $parentObj = null, $noReparent = false;
function callOnChange(changed) {
if ($onChange) {
$onChange.call(proxy, changed);
}
}
var recurse = false;
function notify(property, prior) {
if (recurse)
return;
recurse = true;
try {
if (prior != null) {
prior.forEach(e => {
if (_isMutable(e) && array.indexOf(e) < 0) {
if (e.$parentObj == $parentObj && !$noReparent) {
e.$parentObj = null;
}
if (e.$onChange && e.$onChange.$owner === proxy) {
e.$onChange = null;
}
}
});
}
array.forEach(e => {
if (_isMutable(e)) {
if (!$noReparent) {
e.$parentObj = $parentObj;
}
if (e.$onChange == null || e.$onChange.$owner !== proxy) {
let f = function (childChanged) {
let index = array.indexOf(e);
if (index >= 0) {
callOnChange(childChanged.map(childPath => {
let path = '[' + index + ']';
if (childPath != null && childPath !== '') {
if (childPath[0] != '[') {
path += '.';
}
path += childPath;
}
return path;
}));
}
};
Object.defineProperty(f, '$owner', { value: proxy });
e.$onChange = f;
}
}
});
if ($onChange && prior) {
let changed = [];
let max = Math.max(array.length, prior.length);
for (let i = 0; i < max; i++) {
if ((prior[i] != null || array[i] != null) && prior[i] !== array[i]) {
changed.push('[' + i + ']');
}
}
if (changed.length > 0) {
callOnChange(changed);
}
}
} finally {
recurse = false;
}
}
const cache = {
$mutable: true,
add: function (v) {
this.push(_make(conn, v, vt.elementType, false));
return this;
},
remove: function (predicate) {
let prior;
let count = 0;
let i = 0;
while (i < array.length) {
if (predicate(array[i])) {
if (prior == null) {
prior = array.slice();
}
array.splice(i, 1);
count++;
} else {
i++;
}
}
if (prior) {
notify('remove', prior);
}
return count;
},
take: function (predicate) {
let prior;
let count = 0;
let i = 0;
let taken = [];
while (i < array.length) {
let e = array[i];
if (predicate(e)) {
if (prior == null) {
prior = array.slice();
}
array.splice(i, 1);
taken.push(e);
count++;
} else {
i++;
}
}
if (prior) {
notify('take', prior);
}
return _array(conn, vt, false, taken);
},
};
proxy = new Proxy(array, {
get: function (target, property) {
if (_hasOwnProperty(cache, property))
return cache[property];
if (property == '$onChange') {
return $onChange;
}
if (property == '$parentObj') {
return $parentObj;
} else if (MUTATORS.indexOf(property) >= 0) {
let f = function (...args) {
let prior = Array.from(array);
let retval = array[property].apply(array, args);
notify(property, prior);
return retval;
};
cache[property] = f;
return f;
} else {
return array[property];
}
},
set: function (target, property, value) {
if (property == '$onChange') {
$onChange = value;
return true;
} else if (property == '$parentObj') {
if ($parentObj !== value) {
$parentObj = value;
if (!$noReparent) {
array.forEach(e => {
if (_isMutable(e)) {
e.$parentObj = value;
}
});
}
}
return true;
} else if (property == '$noReparent') {
$noReparent = value;
return true;
} else if (property.charAt(0) == '$') {
target[property] = value;
return true;
} else if (property == 'length') {
if (array.length !== value) {
let prior = Array.from(array);
array.length = value;
notify(property, prior);
}
return true;
} else if (/^[0-9]+$/.test(property)) {
let i = parseInt(property);
if (array[i] !== value) {
let prior = Array.from(array);
array[i] = value;
notify(property, prior);
}
return true;
} else {
throw new TypeError('Cannot add property ' + property + ', Array is not extensible.');
}
},
deleteProperty: function (target, property) {
if (/^[0-9]+$/.test(property)) {
let i = parseInt(property);
if (i >= 0 && i < array[i] !== undefined) {
let prior = Array.from(array);
delete array[i];
notify(property, prior);
}
return true;
} else {
return false;
}
},
});
notify();
_setupColl(proxy, 'Array', vt);
return proxy;
}
_setupColl(array, 'Array', vt);
return array;
}
class ImmutableSet extends SetBase {
constructor(vt) {
super(vt);
}
add(value) {
throw new Error(`Cannot add "${value}", Set is not extensible.`);
}
delete(value) {
throw new Error(`Cannot delete "${value}", Set is not extensible.`);
}
clear() {
throw new Error(`Cannot clear, Set is not extensible.`);
}
}
$protos.ImmutableSet = ImmutableSet;
class MutableSet extends SetBase {
constructor(vt) {
super(vt);
Object.defineProperty(this, '$mutable', { value: true });
}
add(value) {
let vt = this.collectionType().elementType;
let made = _make(vt.type().$conn, value, vt, true);
if (this.has(made)) {
return this;
}
let index = this.size;
super.add(made);
this.$register(made);
this.$notify([index]);
return this;
}
delete(value) {
let index = this.indexOf(value);
if (index < 1) {
return false;
}
super.delete(value);
this.$unregister(value);
this.$notify([index]);
return true;
}
remove(predicate) {
const iter = this.values();
let indexes = [];
let next;
for (let i = 0; (next = iter.next()) && !next.done; i++) {
if (predicate.call(undefined, next.value)) {
super.delete(next.value);
this.$unregister(next.value);
indexes.push(i);
}
}
this.$notify(indexes);
return indexes.length;
}
take(predicate) {
const iter = this.values();
let indexes = [];
let values = [];
let next;
for (let i = 0; (next = iter.next()) && !next.done; i++) {
if (predicate.call(undefined, next.value)) {
super.delete(next.value);
this.$unregister(next.value);
indexes.push(i);
values.push(next.value);
}
}
this.$notify(indexes);
let vt = this.collectionType();
return _make(vt.type().$conn, values, ArrayType.of(vt.elementType), false);
}
clear() {
if (this.size > 0) {
let indexes = [];
let i = 0;
for (const e of this) {
this.$unregister(e);
indexes.push(i);
i++;
}
super.clear();
this.$notify(indexes);
}
}
$notify(indexes) {
if (this.$onChange && indexes.length > 0) {
this.$callOnChange(indexes.map(index => '[' + index + ']'));
}
}
get $onChange() {
return this.$private.onChange;
}
set $onChange(cb) {
if (typeof cb === 'function') {
this.$private.onChange = cb;
} else {
delete this.$private.onChange;
}
}
$callOnChange(changed) {
if (this.$onChange && !this.$private.recurse) {
this.$private.recurse = true;
try {
this.$onChange.call(this, changed);
} finally {
delete this.$private.recurse;
}
}
}
get $parentObj() {
return this.$private.parentObj;
}
set $parentObj(value) {
if (value === null) {
value = undefined;
}
if (this.$private.parentObj !== value) {
this.$private.parentObj = value;
if (!this.$noReparent) {
for (const e of this) {
if (_isMutable(e)) {
e.$parentObj = value;
}
}
}
}
}
$register(e) {
if (_isMutable(e)) {
if (!this.$noReparent) {
e.$parentObj = this.$parentObj;
}
if (e.$onChange == null || e.$onChange.$owner !== this) {
const set = this;
let f = function (childChanged) {
let index = set.indexOf(e);
if (index >= 0) {
set.$callOnChange(childChanged.map(childPath => {
let path = '[' + index + ']';
if (childPath != null && childPath !== '') {
if (childPath[0] != '[') {
path += '.';
}
path += childPath;
}
return path;
}));
}
};
Object.defineProperty(f, '$owner', { value: this });
e.$onChange = f;
}
}
}
$unregister(e) {
if (_isMutable(e)) {
if (e.$parentObj === this.$parentObj && this.$noReparent) {
e.$parentObj = null;
}
if (e.$onChange && e.$onChange.$owner === this) {
e.$onChange = null;
}
}
}
}
$protos.MutableSet = MutableSet;
function _set(conn, vt, mutable, data) {
if (!mutable && data instanceof ImmutableSet) {
if (!_isA(conn, data.collectionType(), vt)) {
let vtType = typeof vt.elementType.type === 'function' ? vt.elementType.type().name() : vt.elementType.type;
throw new Error(`Set of ${data.type().elementType.type().name()} does not match ${vtType}.`);
}
return data;
}
let fromSet;
if (data instanceof Set) {
fromSet = data;
} else {
fromSet = new Set();
if (Array.isArray(data)) {
data.forEach(v => fromSet.add(v));
} else if (data != null) {
throw new Error(`Invalid value "${data}" to make a Set.`);
}
}
let made;
if (mutable) {
made = new MutableSet(vt);
} else {
made = new ImmutableSet(vt);
}
_setupColl(made, 'Set', vt);
for (let v of fromSet) {
Set.prototype.add.call(made, v = _make(conn, v, vt.elementType, mutable));
if (mutable) {
made.$register(v);
}
}
return made;
}
class ImmutableMap extends MapBase {
constructor(vt) {
super(vt);
}
set(key, _value) {
throw new Error(`Cannot set key ${key}, Map is not extensible.`);
}
delete(key) {
throw new Error(`Cannot delete key ${key}, Map is not extensible.`);
}
clear() {
throw new Error(`Cannot clear, Map is not extensible.`);
}
}
$protos.ImmutableMap = ImmutableMap;
class MutableMap extends MapBase {
constructor(vt) {
super(vt);
Object.defineProperty(this, '$mutable', { value: true });
}
set(key, value) {
let kt = this.collectionType().keyType;
let vt = this.collectionType().elementType;
key = _make(vt.type().$conn, key, kt);
value = _make(vt.type().$conn, value, vt, true);
if (this.get(key) === value) {
return this;
}
super.set(key, value);
this.$register(key, value);
this.$notify([String(key)]);
return this;
}
delete(key) {
if (this.has(key)) {
const value = this.get(key);
super.delete(key);
this.$unregister(value);
this.$notify([String(key)]);
}
return true;
}
clear() {
if (this.size > 0) {
let keys = [];
for (const [k, v] of this) {
this.$unregister(v);
keys.push(String(k));
}
super.clear();
this.$notify(keys);
}
}
put(key, value) {
return this.set(key, value);
}
remove(predicate) {
let keys = [];
for (const [k, v] of this) {
if (predicate.call(undefined, v, k)) {
this.$unregister(v);
keys.push(String(k));
super.delete(k);
}
}
this.$notify(keys);
return keys.length;
}
take(predicate) {
let keys = [];
let values = [];
for (const [k, v] of this) {
if (predicate.call(undefined, v, k)) {
this.$unregister(v);
keys.push(String(k));
values.push(v);
super.delete(k);
}
}
this.$notify(keys);
let vt = this.collectionType();
return _make(vt.type().$conn, values, ArrayType.of(vt.elementType), false);
}
$notify(keys) {
if (this.$onChange && keys.length > 0) {
this.$callOnChange(keys.map(k => '[' + _quote(k) + ']'));
}
}
get $onChange() {
return this.$private.onChange;
}
set $onChange(cb) {
if (typeof cb === 'function') {
this.$private.onChange = cb;
} else {
delete this.$private.onChange;
}
}
$callOnChange(changed) {
if (this.$onChange && !this.$private.recurse) {
this.$private.recurse = true;
try {
this.$onChange.call(this, changed);
} finally {
delete this.$private.recurse;
}
}
}
get $parentObj() {
return this.$private.parentObj;
}
set $parentObj(value) {
if (value === null) {
value = undefined;
}
if (this.$private.parentObj !== value) {
this.$private.parentObj = value;
if (!this.$noReparent) {
for (const e of this) {
if (_isMutable(e)) {
e.$parentObj = value;
}
}
}
}
}
$register(key, e) {
if (_isMutable(e)) {
if (!this.$noReparent) {
e.$parentObj = this.$parentObj;
}
if (e.$onChange == null || e.$onChange.$owner !== this) {
const map = this;
let f = function (childChanged) {
if (map.get(key) === e) {
map.$callOnChange(childChanged.map(childPath => {
let path = '[' + _quote(String(key), '"') + ']';
if (childPath != null && childPath !== '') {
if (childPath[0] != '[') {
path += '.';
}
path += childPath;
}
return path;
}));
}
};
Object.defineProperty(f, '$owner', { value: this });
e.$onChange = f;
}
}
}
$unregister(e) {
if (_isMutable(e)) {
if (e.$parentObj === this.$parentObj && !this.$noReparent) {
e.$parentObj = null;
}
if (e.$onChange && e.$onChange.$owner === this) {
e.$onChange = null;
}
}
}
}
$protos.MutableMap = MutableMap;
function _map(conn, vt, mutable, data) {
let fromMap;
if (data instanceof Map) {
fromMap = data;
} else {
fromMap = new Map();
if (Array.isArray(data)) {
for (let i = 0; i < data.length; i++) {
fromMap.set(i, data[i]);
}
} else if (data != null && typeof data === 'object') {
Object.keys(data).forEach(p => {
fromMap.set(p, data[p]);
});
}
}
let made;
if (mutable) {
made = new MutableMap(vt);
} else {
made = new ImmutableMap(vt);
}
_setupColl(made, 'Map', vt);
for (let [k, v] of fromMap) {
Map.prototype.set.call(made,
k = _make(conn, k, vt.keyType, false),
v = _make(conn, v, vt.elementType, mutable));
if (mutable) {
made.$register(k, v);
}
}
return made;
}
class MakingStream extends StreamBase {
constructor(vt, values) {
super(vt);
this.$private.values = values || [];
this.$private.index = 0;
this.$private.hasNext = () => this.$private.index < this.$private.values.length;
this.$private.next = () => {
const vt = this.collectionType().elementType;
const made = _make(vt.type().$conn, this.$private.values[this.$private.index], vt);
this.$private.index++;
return made;
};
}
get size() {
this.doClose();
return this.$private.values.length;
}
}
class IteratorStream extends StreamBase {
constructor(vt, hasNext, next, close) {
super(vt);
this.$private.hasNext = hasNext;
this.$private.next = next;
this.$private.close = close;
}
}
function _stream(conn, vt, mutable, data) {
let made;
if (data instanceof Array) {
made = new MakingStream(vt, data);
} else if (data instanceof Object && typeof data.hasNext === 'function' && typeof data.next === 'function') {
made = new IteratorStream(vt,
data.hasNext.bind(data), data.next.bind(data),
typeof data.close === 'function' ? data.close.bind(data) : undefined);
} else {
made = new IteratorStream(vt, () => false, () => undefined);
}
_setupColl(made, 'Stream', vt);
return made;
}
function _cached(typeName, method, impl) {
const dfltVal = method.cachedKey == 'arg' ? method.mergeOverloads.params[0].default : null;
let f;
if (method.cachedKey == 'arg' && method.cachedFailIfMissing) {
f = function (key, failIfMissing) {
let secondary = this.$cache.get(method.name, false, () => new SimpleCache(typeName, method.name, dfltVal));
return secondary.get(key, failIfMissing, () => impl.call(this, key, false));
};
} else if (method.cachedKey == 'arg' && method.cachedReturnNullIfNotCached) {
f = function (key, returnNullIfNotCached) {
let secondary = this.$cache.get(method.name, false, () => new SimpleCache(typeName, method.name, dfltVal));
return secondary.get(key, false, () => returnNullIfNotCached ? null : impl.call(this, key, false), true);
};
} else if (method.cachedKey == 'arg') {
f = function (key) {
let secondary = this.$cache.get(method.name, false, () => new SimpleCache(typeName, method.name, dfltVal));
return secondary.get(key, false, () => impl.call(this, key));
};
} else if (method.cacheFailIfMissing) {
f = function (failIfMissing) {
return this.$cache.get(method.name, failIfMissing, () => impl.call(this, false));
};
} else if (method.cachedReturnNullIfNotCached) {
f = function (returnNullIfNotCached) {
return this.$cache.get(method.name, false, () => returnNullIfNotCached ? null : impl.call(this, false), true);
};
} else {
f = function () {
return this.$cache.get(method.name, false, () => impl.call(this));
};
}
Object.defineProperties(f, {
$impl: { value: impl.$impl || impl },
$wrapped: { value: impl },
});
return f;
}
function _setupInst(inst, type) {
if (!_hasOwnProperty(inst, '$cache')) {
Object.defineProperty(inst, '$cache', { value: new SimpleCache(type.name(), 'this') });
Object.defineProperty(inst, '$chain', { value: [type] });
if (type.$loaded.$mutable) {
Object.defineProperty(inst, '$mutable', { value: true });
}
}
if (!_hasOwnProperty(inst, '$parent') &&
(type.name() === 'FieldType' || type.name() === 'Method' ||
type.name() === 'MethodType' || type.name() === 'TypeDefaultUiField')) {
var parent;
Object.defineProperty(inst, '$parent', { get: () => parent, set: v => { parent = v; } });
}
}
function _setupColl(inst, typeName, vt) {
if (!_hasOwnProperty(inst, '$cache')) {
Object.defineProperty(inst, '$cache', { value: new SimpleCache(typeName, 'this') });
}
Object.defineProperty(inst, '$c3coll', { value: true });
}
function _hasOwnProperty(object, property) {
if (object == null) {
return false;
}
return Object.prototype.hasOwnProperty.call(object, property);
}
function _isMutable(e) {
return e != null && !e.$c3type && e.$mutable;
}
function _connReqWithJsonAuthzAndActionEngineHeaders(conn, method, path) {
return conn.request(method, path).withJsonHeaders().withActionEngineHeader().withAuthHeader(conn.$authz);
}
function _quote(s) {
if (s == null) return s;
return '"' + s.replace(/\\/g, '\\\\').replace(/"/g, '\\"') + '"';
}
function _serializeArg(arg) {
if (typeof arg === 'function') {
return Lambda.fromJsFunc(arg);
} else if (typeof arg === 'number' && !isFinite(arg)) {
return { type: 'Boxed<double>', value: String(arg) };
} else if (arg instanceof ArrayBuffer || ArrayBuffer.isView(arg)) {
return { type: 'Boxed<binary>', value: Base64.encode(arg) };
}
if (typeof arg === 'object' && arg !== null && typeof arg.toTypedJson === 'function') {
return arg.toTypedJson();
}
return arg;
}
function _boxThis(type, inst) {
if (inst == null)
return null;
if ((type.$init.isGeneric || type.$init.hasVarBindings) && !type.$init.isObj && inst.$c3coll) {
return inst.collectionType().valueToTypedJson(inst);
}
if (type.$init.mixins && type.$init.mixins.indexOf('WithRef') >= 0 &&
typeof inst.toRef === 'function' && !inst.toRef.$delegate) {
return inst.toRef();
}
return inst;
}
const http = require('http');
const https = require('https');
const { Readable } = require('stream');
var EventSource = require('eventsource');
function _readableStream(req, onData, onErr) {
return new Promise(async function (resolve, reject) {
class ReadableStream extends Readable {
constructor(options) {
super(options);
let self = this;
const req_ = (req.url.startsWith('https') ? https : http).request(
req.url,
{
method: 'POST',
headers: Object.fromEntries(req.allHeadersMerged()),
body: req.encodedBody,
},
function (res) {
res.on('data', chunk => {
onData(chunk).forEach(value => {
self.push({
value: value
});
})
});
res.on('end', () => {
self.push(null)
});
}
);
req_.on('error', e => {
self.push(null);
onErr(e);
});
req.entity && req_.write(req.entity);
req_.end();
}
_read() {
}
}
resolve(new ReadableStream({ objectMode: true }));
})
}
let $logger;
function log() {
if ($logger == null) {
$logger = C3.Logger.for($type.name());
}
return $logger;
};
const $type = new Type$Proto($conn, $init);
const $proto = new (function TypeSystemBase() {});
Object.defineProperty($proto, '$conn', { value: $conn });
Object.defineProperties($type, {
$objProto: { value: $proto }
});
Object.defineProperty($type, Symbol.hasInstance, { value: function(inst) { return inst != null && inst.$c3inst && inst.$c3inst.meta().isA(this); } });
$proto.sync = sync;
$proto.callRequest = callRequest;
$proto.cacheContainsType = cacheContainsType;
$proto.clearCache = clearCache;
$proto.c3 = c3;
$proto.trackTypeChanges = trackTypeChanges;
$proto.connection = connection;
$proto.async = async;
$type._instantiate = function _instantiate(value) {
let inst = Object.create(this.$objProto);
if (value != null) {
Object.defineProperty(inst, '$value', { value: Object.freeze(value) });
}
if (typeof this.$setupInst === 'function') {
this.$setupInst(inst);
}
return inst;
};
$proto.log = log;
$proto.toJSON = function toJSON() { return '$value' in this ? this.$value : null; };
Object.freeze($type);
Object.freeze($proto);
return $type;
})());
$conn._registerType((function() {
const $init = _deepFreeze({
"type" : "TypeMeta",
"metadataPath" : "platform/src/typesys/type/Type.c3typ",
"package" : "platform",
"packageSubPath" : "typesys.type",
"name" : "Type",
"doc" : "Type objects contain information about defined types.  I.e., metadata is used to describe the declared types provided\nby the platform or defined for an application.\n\nTypes are declared in C3 DSL files (`*.c3typ`) in much the same way classes are declared in object-oriented\nlanguages. A type is a single logical structure that defines a specific part of a \"model.\" For example, a vehicle\nmodel might have types corresponding to the chassis, the engine, the wheels, etc.\n\nTypes can \"mix in\" other types, including multiple other types. Composition is a key aspect of types and we prefer\ntypes to be relatively small with natural groupings separated into logical features that are more naturally\nreused. For example, the state of having a name is declared by {@link WithType} so any type that wants that same\nfeature can `mixin WithType`. It's also easier for implementations because they don't have to know about every\ntype that happens to have a name, they just need to know about **WithType**.\n\nFor introspecting the structure of a type, one uses the type's {@link TypeMeta}. This provides information about\nall aspects of the type declaration. For example, the type's name is accessed with `type.meta().name()`.\n\nType files may also reference and declare inner types:\n```type\ntype Bird {\n  beak: !Bird.Beak\n}\n```\n\n```type\ntype Bird.Beak {\n  specialization: !string enum Bird.Beak.Specialization\n}\n```\n\n```type\nenum type Bird.Beak.Specialization { INSECTS, SEEDS, MEAT, GENERAL }\n```\n\nThese three files create three types, globally accessible through their full paths:\n - Bird\n - Bird.Beak\n - Bird.Beak.Specialization\n\nWhat's more important is that this organization helps keep the global namespace uncluttered.\n\nTypes can be modified in various ways:\n - {@link TypeMeta#declaredAbstract abstract} - this type itself cannot be instantiated\n - {@link TypeMeta#declaredPrivate private} - type should not be used outside its declaring package\n - {@link TypeMeta#declaredFinal final} - none of the fields or methods on this type may be changed by mixins\n - {@link TypeMeta#declaredNotMixable not mixable} - type may not be used as a mixin\n - {@link TypeMeta#declaredNotRemixable not remixable} - type may not be remixed\n - {@link TypeMeta#declaredEntity entity} - type may be persisted using standard mechanisms\n - {@link TypeMeta#declaredExtendable extendable} - types that `extend` this one are stored in same DB tables\n - {@link TypeMeta#declaredNotExtendable not extendable} - type may not be further extended\n - {@link TypeMeta#declaredRemix remix} - type adds to a type declared in a dependent package\n - {@link TypeMeta#declaredEnum enum} - type defines a set of constant values (an enumeration)\n - {@link TypeMeta#declaredDuck duck} - type defines additional behavior when its mixins are used together\n - {@link TypeMeta#declaredUnionAlts union} - type is an alias for two or more other value types\n\n@see TypeMeta",
"declaredMixinRefTypes" : [ {
"name" : "StringSerializable"
}, {
"name" : "Serializable"
}, {
"name" : "WithCacheKey"
}, {
"name" : "HtmlRenderable"
}, {
"name" : "Fingerprintable"
}, {
"name" : "Value"
} ],
"declaredFieldTypes" : [ {
"doc" : "The name of this type. If a generic type was resolved using bindings specified in the name, the name may include\nthose bindings.\n\n@see TypeMeta#qname\n@see TypeMeta#prototypeName",
"name" : "name",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"annotationsJson" : [ {
"call" : [ {
"name" : "stayInEngine",
"value" : {
"py-server" : "true"
}
} ]
} ],
"doc" : "@return metadata for this type",
"name" : "meta",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"cached" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py-server" ]
}
}, {
"doc" : "Produce a calling proxy that represents the content of all this type's mixins, but not the type itself. This is\nuseful for redispatching **static** methods reimplemented on this type to a parent implementation:\n```js\nfunction sum(a, b) {\n  return Math.max(0, this.super().sum(a, b));\n}\n```\nTo redispatch **member** methods, see {@link WithType#super}. For static methods, `this` is the type instance.\n\nNote that this not the same as the language-specific `super` keyword because it works through the type system and\nsupports multiple mixins. It behaves like the Python `super()` function, except called on the type rather than\nglobally.\n\n@param mixin if specified, this mixin is used instead or an error is thrown\n@return \"super\" calling proxy for this type\n\n@see WithType.super",
"name" : "super",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'c3.platform.typesys.type.SuperStatic'"
} ]
} ],
"modifier" : "NON_EMPTY"
},
"final" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"name" : "toString",
"valueType" : {
"type" : "InheritedValueType",
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"name" : "fromString",
"valueType" : {
"type" : "InheritedValueType",
"actionRequirementNames" : [ "java", "py" ]
}
}, {
"name" : "toJson",
"valueType" : {
"type" : "InheritedValueType",
"actionRequirementNames" : [ "java", "py", "js" ]
}
}, {
"name" : "toTypedJson",
"valueType" : {
"type" : "InheritedValueType",
"actionRequirementNames" : [ "java", "py", "js" ]
}
}, {
"name" : "fromJson",
"valueType" : {
"type" : "InheritedValueType",
"actionRequirementNames" : [ "java", "py" ]
}
}, {
"doc" : "Deserialize a Type within a given {@link Pkg}.\n\n@param json\n   Can either be a JsonObject with field \"meta\" containing serialized {@link TypeMeta} which represents an\n   anonymous type or JsonText referring to an existing type in provided pkg by name.\n@param pkg\n   {@link Pkg} where all ReferenceTypes will be resolved.\n@return constructed Type",
"name" : "fromJson",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
}, {
"name" : "pkg",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "Pkg"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Type"
},
"actionRequirementNames" : [ "java", "py" ]
}
}, {
"doc" : "@return Logger for this type",
"name" : "log",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Logger"
},
"cached" : true,
"member" : true,
"property" : true
}
}, {
"name" : "renderer",
"valueType" : {
"type" : "InheritedValueType",
"actionRequirementNames" : [ "java", "js-client" ]
}
}, {
"name" : "cacheKey",
"valueType" : {
"type" : "InheritedValueType",
"actionRequirementNames" : [ "java", "py" ]
}
}, {
"name" : "fingerprint",
"valueType" : {
"type" : "InheritedValueType"
}
} ],
"isWithType" : false,
"isObj" : false,
"isMutable" : false,
"isStateful" : false,
"isSingleton" : false,
"isDefaultInstance" : false,
"isAbstract" : false,
"hasEventStream" : false,
"isGeneric" : false,
"isNativeRemix" : false,
"hasVarBindings" : false,
"prototypeName" : "Type",
"hasSerNameFields" : false,
"annotations" : {
"type" : "Annotations"
},
"mixins" : [ "StringSerializable", "WithToString", "Value", "Serializable", "WithCacheKey", "HtmlRenderable", "Fingerprintable" ],
"referenceType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"mixinsWithSourceCode" : {
"js-ide-vscode-client-node" : [ "StringSerializable" ]
},
"methods" : [ {
"type" : "Method",
"name" : "toString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Type" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Type"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Build the canonical string representation of this instance. This must be implemented to provide serialization.\n\nIf the object has no content, and fromString would properly reproduce it from a null value, toString may return\nnull or empty string. Note that toString is primarily for serialization and only secondarily for inspection.\n\n@see #fromString",
"name" : "toString",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toString",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
},
"$nearestImplementedOn" : "Type"
}, {
"type" : "Method",
"name" : "fromString",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Type",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Parse the string-based representation and reconstruct the corresponding instance. This must be implemented to\nprovide deserialization.\n\nfromString is called on the type be deserialized and must reconstruct an Obj of the appropriate type (which may be\na type that mixes in the type on which it is called). This means that the resulting object's type will be isA the\ncalled-on type, but perhaps not identical.\n\n@see #toString",
"name" : "fromString",
"params" : [ {
"name" : "s",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type",
"mixing" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromString",
"params" : [ {
"name" : "s",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type",
"mixing" : true
},
"paramNames" : [ "s" ]
}
}, {
"type" : "Method",
"name" : "make",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Type",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "StringSerializable" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "StringSerializable"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type from the string. This is an alias for #fromString, as a specific overload\nwhen the argument is a known string.\n\n@see #fromString",
"name" : "make",
"params" : [ {
"name" : "s",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "make",
"params" : [ {
"name" : "s",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type",
"mixing" : true
},
"paramNames" : [ "s" ]
},
"$nearestImplementedOn" : "StringSerializable"
}, {
"type" : "Method",
"name" : "toJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Type" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Type"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a JSON object. By default (i.e. with no arguments) the result will\ncontain no type information.\n\n@see #toTypedJson\n@see serdeser.c3doc\n@see JsonType",
"name" : "toJson",
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJson",
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
},
"$nearestImplementedOn" : "Type"
}, {
"type" : "Method",
"name" : "toTypedJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Type" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Type"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a _typed_ JSON object.\n@param omitTopLevelType\n       Whether to leave out `type: {{ type of this serializable instance }}` as the **first** key-value pair in\n       the outer level of the produced json.\n@param runtime\n       If provided, then any special serialization logic required for the {@link ImplLanguage.Runtime} will be\n       performed. **NOTE** This argument is ignored if `typed` is not `true`. @see Ann.Ser\n\n\n@return JSON object representation\n\n@see #fromJson\n@see #toJson\n@see serdeser.c3doc\n@see JsonType",
"name" : "toTypedJson",
"params" : [ {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toTypedJson",
"params" : [ {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"paramNames" : [ "omitTopLevelType", "actionRequirement" ]
},
"$nearestImplementedOn" : "Type"
}, {
"type" : "Method",
"name" : "toJsonString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to an _untyped_ serialized JSON string. This is the equivalent of\n`toJson().serialize()`.\n\n@return JSON object as string",
"name" : "toJsonString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJsonString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "toTypedJsonString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a _typed_ serialized JSON string. This is the equivalent of\n`toTypedJson().serialize()`.\n\n@return JSON object as string",
"name" : "toTypedJsonString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toTypedJsonString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "toJsString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized JavaScript object literal.\n\n@return JavaScript object literal string",
"name" : "toJsString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJsString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "toXmlString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized XML string.\n\n@return XML element as string\n\n@see #fromXmlString",
"name" : "toXmlString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toXmlString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "serialize",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a string serialized representation of the object.\n\n@return string serialized object representation",
"name" : "serialize",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "serialize",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "contentType" ]
}
}, {
"type" : "Method",
"name" : "fromJson",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Type",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the JSON-based representation and reconstruct the corresponding object.\n\nfromJson is be called on the type be deserialized and must reconstruct an object of the appropriate type (which may\nbe  a type that mixes in the type on which it is called). This means that the resulting object's type will be isA\nthe called-on type, but perhaps not identical. In particular, `fromJson` works for any actual type and will return\nan instance of the correct type.\n\n@see #toJson",
"name" : "fromJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type",
"mixing" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Deserialize a Type within a given {@link Pkg}.\n\n@param json\n   Can either be a JsonObject with field \"meta\" containing serialized {@link TypeMeta} which represents an\n   anonymous type or JsonText referring to an existing type in provided pkg by name.\n@param pkg\n   {@link Pkg} where all ReferenceTypes will be resolved.\n@return constructed Type",
"name" : "fromJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
}, {
"name" : "pkg",
"valueType" : {
"type" : "ReferenceType",
"name" : "Pkg"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"inline" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
}, {
"name" : "pkg",
"valueType" : {
"type" : "ReferenceType",
"name" : "Pkg"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type",
"mixing" : true
},
"paramNames" : [ "json", "pkg" ]
}
}, {
"type" : "Method",
"name" : "fromJsonString",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Type",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the JSON-based representation and reconstruct the corresponding object.\n\nfromJsonString is be called on the type be deserialized and must reconstruct an object of the appropriate type\n(which may be a type that mixes in the type on which it is called). This means that the resulting object's type\nwill be isA the called-on type, but perhaps not identical. In particular, `fromJsonString` works for any actual\ntype and will return an instance of the correct type.\n\n@see #toJsonString",
"name" : "fromJsonString",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type",
"mixing" : true
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromJsonString",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type",
"mixing" : true
},
"paramNames" : [ "json" ]
}
}, {
"type" : "Method",
"name" : "fromXmlString",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Type",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the XML-based representation and reconstruct the corresponding object.\n\nfromXmlString is be called on the type be deserialized and must reconstruct an object of the appropriate type\n(which may be a type that mixes in the type on which it is called). This means that the resulting object's type\nwill be isA the called type, but perhaps not identical. In particular, `Obj.fromXmlString` works for any actual\ntype and will return an instance of the correct type.\n\n@see #toXmlString",
"name" : "fromXmlString",
"params" : [ {
"name" : "xml",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type",
"mixing" : true
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromXmlString",
"params" : [ {
"name" : "xml",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type",
"mixing" : true
},
"paramNames" : [ "xml" ]
}
}, {
"type" : "Method",
"name" : "deserialize",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Type",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load from contentType representation and reconstruct the corresponding object.\n\nfromString is be called on the type be deserialized and must reconstruct an object of the appropriate type\n(which may be a type that mixes in the type on which it is called). This means that the resulting object's type\nwill be isA the called-on type, but perhaps not identical. In particular, `fromString` works for any actual\ntype and will return an instance of the correct type.",
"name" : "deserialize",
"params" : [ {
"name" : "contentStr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type",
"mixing" : true
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "deserialize",
"params" : [ {
"name" : "contentStr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type",
"mixing" : true
},
"paramNames" : [ "contentStr", "contentType" ]
}
}, {
"type" : "Method",
"name" : "cacheKey",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "The name of this instance.",
"name" : "cacheKey",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "cacheKey",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "renderer",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "HtmlRenderer"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Type" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Type"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return an instance of an {@link HtmlRenderer} set up to render this instance. If there is no capable renderer,\nnull may be returned. The implementation must be available within the browser (typically `js-client`).",
"name" : "renderer",
"returnType" : {
"type" : "ReferenceType",
"name" : "HtmlRenderer"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js-client" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "renderer",
"returnType" : {
"type" : "ReferenceType",
"name" : "HtmlRenderer"
}
},
"$nearestImplementedOn" : "Type"
}, {
"type" : "Method",
"name" : "fingerprint",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Produce a checksum that can easily be compared to determine if two objects are definitely different. Note that\nthere is a slight possibility that two objects with the same fingerprint will actually differ.\n\nThe fingerprint recurses into field values, including collections and referenced Objs. The handling of nested\n{@link Identified identified} references (typically entities) differ in that _only_ the `id` field is included\nunless the allIdentifiedRefFields option is specified.\n\nIf the object graph may contain recursive embedded object references, the trackRecursiveRefs option may be used.\nHowever, maintaining the list of visited objects is costly so this should not be done unnecessarily.\n\n@param allIdentifiedRefFields\n          if `true`, fingerprint individual fields of persistable references, not just the `id`\n@param trackRecursiveRefs\n          if `true`, a set of referenced objects is maintained to avoid infinite recursion\n@param traversedRefs\n          only considered together with trackRecursiveRefs and if provided then all traversed references are\n          checked against and added to it\n@return integer fingerprint\n\n@see https://en.wikipedia.org/wiki/Fingerprint_(computing)",
"name" : "fingerprint",
"params" : [ {
"name" : "allIdentifiedRefFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "trackRecursiveRefs",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "traversedRefs",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<Obj>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fingerprint",
"params" : [ {
"name" : "allIdentifiedRefFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "trackRecursiveRefs",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "traversedRefs",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<Obj>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"paramNames" : [ "allIdentifiedRefFields", "trackRecursiveRefs", "traversedRefs" ]
}
}, {
"type" : "Method",
"name" : "name",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Type" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Type"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "The name of this type. If a generic type was resolved using bindings specified in the name, the name may include\nthose bindings.\n\n@see TypeMeta#qname\n@see TypeMeta#prototypeName",
"name" : "name",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "name",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
},
"$nearestImplementedOn" : "Type"
}, {
"type" : "Method",
"name" : "meta",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Type" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Type"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"call" : [ {
"name" : "stayInEngine",
"value" : {
"py-server" : "true"
}
} ]
} ],
"doc" : "@return metadata for this type",
"name" : "meta",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"cached" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py-server" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"call" : [ {
"name" : "stayInEngine",
"value" : {
"py-server" : "true"
}
} ]
} ],
"name" : "meta",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
}
},
"$nearestImplementedOn" : "Type"
}, {
"type" : "Method",
"name" : "super",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'c3.platform.typesys.type.SuperStatic'"
} ]
} ],
"modifier" : "NON_EMPTY"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Type" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Type"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Produce a calling proxy that represents the content of all this type's mixins, but not the type itself. This is\nuseful for redispatching **static** methods reimplemented on this type to a parent implementation:\n```js\nfunction sum(a, b) {\n  return Math.max(0, this.super().sum(a, b));\n}\n```\nTo redispatch **member** methods, see {@link WithType#super}. For static methods, `this` is the type instance.\n\nNote that this not the same as the language-specific `super` keyword because it works through the type system and\nsupports multiple mixins. It behaves like the Python `super()` function, except called on the type rather than\nglobally.\n\n@param mixin if specified, this mixin is used instead or an error is thrown\n@return \"super\" calling proxy for this type\n\n@see WithType.super",
"name" : "super",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "ReferenceType",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'c3.platform.typesys.type.SuperStatic'"
} ]
} ],
"modifier" : "NON_EMPTY"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "super",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "ReferenceType",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'c3.platform.typesys.type.SuperStatic'"
} ]
} ],
"modifier" : "NON_EMPTY"
},
"paramNames" : [ "mixin" ]
},
"$nearestImplementedOn" : "Type"
}, {
"type" : "Method",
"name" : "log",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : true,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Logger"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return Logger for this type",
"name" : "log",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Logger"
},
"cached" : true,
"inline" : true,
"member" : true,
"property" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "log",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Logger"
}
}
} ],
"hasSourceCode" : {
"js-ide-vscode-client-node" : true
},
"fieldTypes" : [ ]
});
function fromString(s) {
return Str.isEmpty(s) ? null : C3.pkg().type(s, true);
}
function renderer() {
return TypeRenderer.forType(this);
}
function toString() {
return this.name();
}
function toTypedJson() {
return this.toString();
}
function toJson() {
return this.toTypedJson();
}
let $logger;
function log() {
if ($logger == null) {
$logger = C3.Logger.for($type.name());
}
return $logger;
};
const $type = new Type$Proto($conn, $init);
const $proto = new (function Type() {});
Object.defineProperty($proto, '$conn', { value: $conn });
Object.defineProperties($type, {
$objProto: { value: $proto }
});
Object.defineProperty($type, Symbol.hasInstance, { value: function(inst) { return inst != null && inst.$c3inst && inst.$c3inst.meta().isA(this); } });
$proto.toTypedJson = toTypedJson;
$proto.renderer = renderer;
$proto.toString = toString;
$proto.toJson = toJson;
$type._instantiate = function _instantiate(value) {
let inst = Object.create(this.$objProto);
if (value != null) {
Object.defineProperty(inst, '$value', { value: Object.freeze(value) });
}
if (typeof this.$setupInst === 'function') {
this.$setupInst(inst);
}
return inst;
};
$proto.log = log;
$proto.toJSON = function toJSON() { return this.toTypedJson(); };
Object.freeze($type);
Object.freeze($proto);
return $type;
})());
$conn._registerType((function() {
const $init = _deepFreeze({
"type" : "TypeMeta",
"metadataPath" : "platform/src/typesys/value/StringSerializable.c3typ",
"package" : "platform",
"packageSubPath" : "typesys.value",
"name" : "StringSerializable",
"doc" : "Base type for types that implement custom string serialization. This is naturally used with the `serialized`\nsyntax when values are to be stored as strings, but have inner structure that can be represented by a type.\nFor example: `string serialized Url` indicates that a value is passed as a string, but represents a {@link Url}.\n\nNote that values declared as `string serialized` aren't necessary canonicalized:\n - a serialized value must work with fromString\n - it may not be the form produced by toString\n - it should not be compared/found _as_ a string\n\n@see serdeser.c3doc",
"declaredAbstract" : true,
"declaredMixinRefTypes" : [ {
"name" : "WithToString"
}, {
"name" : "Value"
} ],
"declaredFieldTypes" : [ {
"doc" : "Build the canonical string representation of this instance. This must be implemented to provide serialization.\n\nIf the object has no content, and fromString would properly reproduce it from a null value, toString may return\nnull or empty string. Note that toString is primarily for serialization and only secondarily for inspection.\n\n@see #fromString",
"name" : "toString",
"valueType" : {
"type" : "InheritedValueType",
"abstract" : true,
"inline" : true
}
}, {
"doc" : "Parse the string-based representation and reconstruct the corresponding instance. This must be implemented to\nprovide deserialization.\n\nfromString is called on the type be deserialized and must reconstruct an Obj of the appropriate type (which may be\na type that mixes in the type on which it is called). This means that the resulting object's type will be isA the\ncalled-on type, but perhaps not identical.\n\n@see #toString",
"name" : "fromString",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "s",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "StringSerializable",
"mixing" : true
},
"abstract" : true,
"inline" : true
}
}, {
"doc" : "Construct an instance of this type from the string. This is an alias for #fromString, as a specific overload\nwhen the argument is a known string.\n\n@see #fromString",
"name" : "make",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "s",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "StringSerializable",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ]
}
} ],
"isWithType" : false,
"isObj" : false,
"isMutable" : false,
"isStateful" : false,
"isSingleton" : false,
"isDefaultInstance" : false,
"isAbstract" : true,
"hasEventStream" : false,
"isGeneric" : false,
"isNativeRemix" : false,
"hasVarBindings" : false,
"prototypeName" : "StringSerializable",
"hasSerNameFields" : false,
"annotations" : {
"type" : "Annotations"
},
"mixins" : [ "WithToString", "Value" ],
"referenceType" : {
"type" : "ReferenceType",
"name" : "StringSerializable"
},
"mixinsWithSourceCode" : {
"js-ide-vscode-client-node" : [ ]
},
"methods" : [ {
"type" : "Method",
"name" : "toString",
"hasAnyStatic" : false,
"hasAnyAbstract" : true,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : false,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Build the canonical string representation of this instance. This must be implemented to provide serialization.\n\nIf the object has no content, and fromString would properly reproduce it from a null value, toString may return\nnull or empty string. Note that toString is primarily for serialization and only secondarily for inspection.\n\n@see #fromString",
"name" : "toString",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"abstract" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toString",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "fromString",
"hasAnyStatic" : true,
"hasAnyAbstract" : true,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "StringSerializable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : false,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Parse the string-based representation and reconstruct the corresponding instance. This must be implemented to\nprovide deserialization.\n\nfromString is called on the type be deserialized and must reconstruct an Obj of the appropriate type (which may be\na type that mixes in the type on which it is called). This means that the resulting object's type will be isA the\ncalled-on type, but perhaps not identical.\n\n@see #toString",
"name" : "fromString",
"params" : [ {
"name" : "s",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "StringSerializable",
"mixing" : true
},
"abstract" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromString",
"params" : [ {
"name" : "s",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "StringSerializable",
"mixing" : true
},
"paramNames" : [ "s" ]
}
}, {
"type" : "Method",
"name" : "make",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "StringSerializable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "StringSerializable" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "StringSerializable"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type from the string. This is an alias for #fromString, as a specific overload\nwhen the argument is a known string.\n\n@see #fromString",
"name" : "make",
"params" : [ {
"name" : "s",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "StringSerializable",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "make",
"params" : [ {
"name" : "s",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "StringSerializable",
"mixing" : true
},
"paramNames" : [ "s" ]
},
"$nearestImplementedOn" : "StringSerializable"
} ],
"hasSourceCode" : {
"js-ide-vscode-client-node" : true
},
"fieldTypes" : [ ]
});
function make(...args) {
if (typeof args[0] === 'string') {
return this.fromString(args[0]);
}
return this._instantiate(...args);
}
let $logger;
function log() {
if ($logger == null) {
$logger = C3.Logger.for($type.name());
}
return $logger;
};
const $type = new Type$Proto($conn, $init);
const $proto = new (function StringSerializable() {});
Object.defineProperty($proto, '$conn', { value: $conn });
Object.defineProperties($type, {
$objProto: { value: $proto }
});
Object.defineProperty($type, Symbol.hasInstance, { value: function(inst) { return inst != null && inst.$c3inst && inst.$c3inst.meta().isA(this); } });
$type.make = make;
$type._instantiate = function _instantiate(value) {
let inst = Object.create(this.$objProto);
if (value != null) {
Object.defineProperty(inst, '$value', { value: Object.freeze(value) });
}
if (typeof this.$setupInst === 'function') {
this.$setupInst(inst);
}
return inst;
};
$proto.log = log;
$proto.toJSON = function toJSON() { return '$value' in this ? this.$value : null; };
Object.freeze($type);
Object.freeze($proto);
return $type;
})());
$conn._registerType((function() {
const $init = _deepFreeze({
"type" : "TypeMeta",
"metadataPath" : "platform/src/typesys/type/TypeMeta.c3typ",
"package" : "platform",
"packageSubPath" : "typesys.type",
"name" : "TypeMeta",
"doc" : "Type objects contain information about defined types. I.e., metadata is used to describe the declared types provided\nby the platform or defined for an application.\n\nTypes support both inheritance and composition. Inheritance is declared with the `extends` keyword. Only single\ninheritance is possible. This approach is typically used for entity types as typically instances of all types from a\nsingle inheritance tree are persisted in the same table.\n\nComposition is declared with the `mixes` keyword and multiple mixins may be used. However, only non-entity types may\nbe mixed in. As mentioned above entity types typically participate in inheritance.\n\nAny type may declare fields, but only {@link Obj} has built-in support for them. Most types are sub-types of Obj,\nbut types that explicitly mixin {@link Value} are opting out of Obj support.\n\nFor general type system information, see {@link typesys.c3doc Type System}.\n\n@see Type\n@see Obj",
"declaredMixinRefTypes" : [ {
"name" : "Generic"
}, {
"name" : "NameableType"
}, {
"name" : "StringSerializable"
}, {
"name" : "WithCacheKey"
} ],
"declaredFieldTypes" : [ {
"doc" : "The name of this type, which will be unique within its package. For most types, there will be simply the declared\nname (`User`). For nested inner types, this will include the parent type name (`Parent.Child`). For bound types,\nthe bindings will be incorporated into the name (`NormTimeseries<float>`).\n\nNote that #name could be null for dynamic types that are not part of any package.\n\n@see #prototypeName\n@see #innerTypeName\n@see #qname",
"name" : "name",
"valueType" : {
"type" : "InheritedValueType"
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"native\""
} ]
} ],
"doc" : "True if this type is declared `native`. This means that its implementation is particular to a certain language\nand perhaps even {@Link Action.Requirement}, and is not available in others.\n\n```type\nnative type BrowserUtil\nnative py remix type DataFrame\n```\n\n@see #isNativeRemix",
"name" : "declaredNative",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"entity\""
} ]
} ],
"doc" : "True if this type is declared as entity type. This means it may not be persisted in the database. Entity types\nimplicitly mixin {@link Persistable}.\n\n@see Persistable",
"name" : "declaredEntity",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"enum\""
} ]
} ],
"doc" : "If true, this type is a declared as enum type:\n```type\nenum type Colors { RED YELLOW GREEN BLUE }\n```\n\n@see Enum",
"name" : "declaredEnum",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "flag",
"value" : true
}, {
"name" : "syntax",
"value" : "\"union\""
} ]
} ],
"doc" : "If set, this type is declared as a union type:\n```type\nunion type Stringish = string | [string]\n```\n\n@see Union",
"name" : "declaredUnionAlts",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "AnyOfType"
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"duck\""
} ]
} ],
"doc" : "If true, this type is a \"duck type\". I.e. mixin pattern in any other type that is matching to this duck type will\nbe replaced by this type.\n\nE.g. type-system among others defines following duck types:\n* `abstract entity duck type CachedPersistable mixes Cached`\n* `duck type StrStream mixes Stream<string>`\n\nThis means any entity type that is also `Cached` will actually mixin `CachedPersistable` and any method that is\nreturning `stream<string>` will actually return instance of `StrStream`\n\n@see #isDuckType",
"name" : "declaredDuck",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"abstract\""
} ]
} ],
"doc" : "True if this type is declared abstract. This means it may not be instantiated separately, but can be a mixin of\nanother type.\n\nAbstract methods declared in mixin types of an abstract type continue to be abstract. Normally abstract methods are\nclaimed by a sup-type unless those methods are explicitly re-declared as abstract using `<myMethod>: abstract ~`\nsyntax.\n\nNote that mixin of abstract type does not make sub-type automatically be abstract.  If such a type is also\nabstract, it must be explicitly marked.\n\n@see FieldType#abstract",
"name" : "declaredAbstract",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"inline\""
} ]
} ],
"doc" : "True if this type's methods are automatically inline. This is a **shortcut** for marking every \"declared\" method\nas *inline* and these methods will be inline in all of the subtypes of the current type even if the subtype may\nnot be inline. This should only be used for performance critical types whose methods never need authorization and\ndon't expect any support for argument or return value processing.\n\nPlease note that **overridden methods in an inline type DO NOT automatically become inline.** e.g\n```c3typ\ntype Boo {\n  bar: function()\n  baz: member function()\n}\n\ninline type Foo mixes Boo {\n   bar: inline ~\n   baz: ~\n}\n```\nIn the above code, Foo.bar is inline while Foo.baz is not. Boo.bar and Boo.baz both are not inline.\n\n@see #isInline\n@see MethodType#inline\n@see MethodType#isInline",
"name" : "declaredInline",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"final\""
} ]
} ],
"doc" : "True if this type is declared final. This means that none of its data fields or methods may be changed by types\nthat mix it in. Note that a type itself may not be final, but may also declare certain fields final.\n\n@see FieldType#isFinal\n@see Method#isFinal\n@see #notMixable",
"name" : "declaredFinal",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"private\""
} ]
} ],
"doc" : "True if this type is a private type. This means that it may not be used outside of its declaring package.\n\n@see FieldType#private",
"name" : "declaredPrivate",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"extendable\""
} ]
} ],
"doc" : "Indicates that a type is extendable.  Extendable types allow the creation of a type hierarchy where more specific\ntypes extend less specific type (e.g. Hospital extends Facility extends FixedAsset).\n\nExtendable types are typically entity types and shares the same database table / storage and base type can be\nqueried to retrieve all instances of all sub-types.\n\nSetting this type modifier implicitly mixes @{link Extendable}.\n\n@see #declaredNotExtendable",
"name" : "declaredExtendable",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"non extendable\""
} ]
} ],
"doc" : "True if this type may not be further extended. Note that this only makes sense for types which themselves extend\na type (marked as `extendable`), but don't allow further extension.\n\n```type\nextendable entity type Fruit\ntype StoneFruit extends Fruit\nnot extendable type Cherry extends StoneFruit\n```\nIn the example, above Cherry may not further be extended.\n\n@see #declaredExtendable",
"name" : "declaredNotExtendable",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"extends\""
} ]
} ],
"doc" : "Reference to a base type this type extends.\n\n@see #baseType\n@see #isExtendable\n@see #isNotExtendable",
"name" : "declaredExtendsRefType",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "DeclaredReferenceType"
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"not mixable\""
} ]
} ],
"doc" : "True if this type may not be mixed into any other types outside the declaring package. This is used by certain\ntypes that the system needs to know cannot have new sub-types declared.",
"name" : "declaredNotMixable",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"mixes\""
} ]
} ],
"doc" : "References to other types that this type directly mixes in.\n\n@see #mixins\n@see #inNotMixable",
"name" : "declaredMixinRefTypes",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "DeclaredReferenceType"
}
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"remix\""
} ]
} ],
"doc" : "If true, this type is a remix of one with the same name in one of the packages this package depends on.\n\nA remix means the definitions augment the base definitions when provisioned. Otherwise, it is an error to have the\nsame type defined multiple times within the same tag (aka deployment unit). I.e. given package can not simply\ndeclare an new type with the same name as in one of it's depending packages.\n\n@see #isNotRemixable",
"name" : "declaredRemix",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"not remixable\""
} ]
} ],
"doc" : "True if this type may not be remixed. This is used by certain types that the system needs to know cannot be\nchanged from outside the package.",
"name" : "declaredNotRemixable",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"as\""
}, {
"name" : "ident",
"value" : true
} ]
} ],
"doc" : "If this type was remixed by one or more remixes and type is specifying an alias, then all the aliases.\n```type\nremix type Foo as OtherFoo\n```\nIn the above example, the remixed type is \"Foo\" with an alias \"OtherFoo\".",
"name" : "declaredRemixAlias",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"type key\""
} ]
} ],
"doc" : "For extendable types, the key used to identify the type's position in the hierarchy.  The value contributes to\nthe {@link Extendable.typeIdent} field so that an instance's leaf type can be determined without having\n{@link Obj.type} field value.",
"name" : "declaredTypeKey",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"fields\""
} ]
} ],
"doc" : "Declared and overridden fields and methods on this type.\n\n@see declaredFieldTypesByName\n@see declaredFieldType\n@see overriddenFieldTypes",
"name" : "declaredFieldTypes",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "DeclaredFieldType"
}
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"doc" : "Types defined directly within this type. For example {@link Ann} has inner types for all possible annotations.",
"name" : "declaredInnerTypes",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"doc" : "Types that are implementation language native remixes of this type.",
"name" : "declaredNativeRemixes",
"valueType" : {
"type" : "MapType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"keyType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Action.Requirement"
}
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"doc" : "Types that are remixes of this type along with pkg they were declared in.\nFor example, if package \"app\", depends on \"industry\", which depends on \"foundation\", and `Facility` was defined in\n\"foundation\" and remixed in \"app\", then\n```js\nC3.type(\"Facility\").declaredRemixes.size() == 1\nC3.type(\"Facility\").declaredRemix == false\nC3.type(\"Facility\").package == 'foundation'\nC3.type(\"Facility\").declaredRemixes.keys().collect() == ['app']\nC3.type(\"Facility\").declaredRemixes.get(\"app\").declaredRemix == true\nC3.type(\"Facility\").declaredRemixes.get(\"app\").package == 'app'\n```\n\n@see #declaredRemix",
"name" : "declaredRemixes",
"valueType" : {
"type" : "MapType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"keyType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"doc" : "@return whether this TypeMeta has any #declaredRemixes",
"name" : "isRemix",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"doc" : "Method(s) implementation source code. The key is the language name and the value is the source code for all\nfunctions implemented in that language on this type.",
"name" : "declaredSourceCode",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"doc" : "The list of unbound variable declarations and any restrictions on them.",
"name" : "declaredVars",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "VarReferenceType"
}
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"doc" : "If this is a native remix type, the {@Link Action.Requirement} for which the native implementation is defined.\n\n```type\npy native remix type DataFrame\n```\n\nThe native remix type PyDataFrame is native to the \"py\" {@Link Action.Requirement}",
"name" : "declaredNativeRequirement",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Action.Requirement"
}
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"schema name\""
} ]
} ],
"doc" : "Name of the underlying schema (e.g. database table name)",
"name" : "declaredSchemaName",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"doc" : "A type may globally specify a default implementation language and {@Link Action.Requirement}:\n\n```type\njs-browser type ConsoleGrid\n```\n\nThis means that all methods without explicit claims, both declared and inherited abstract, are claimed for\nthe type's default {@Link Action.Requirement}, \"js-browser\" in this case. This is very convenient for types with lots of methods\nall of which are implemented in the same language.\n\n@see MethodType#actionRequirementNames",
"name" : "defaultActionRequirement",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Action.Requirement"
}
}
}, {
"doc" : "Get the type metadata for an instantiated type by name.",
"name" : "forName",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeMeta"
}
}
}, {
"doc" : "Return the name of this type, qualified by its package. For example, the Facility type will have a name of\n`Facility` and a qname of `foundation.Facility`, which is the package that defines it.\n\n@see #name",
"name" : "qname",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeQName"
}
},
"member" : true
}
}, {
"doc" : "The path of folder where this type's declaration file is located:\nFormat: [gen|test]/src/<packageSubPath>/<name>\nE.g. for the given package folder structure\n myPkg\n  |\n  -  src\n      |\n      - folder1\n          |\n          - folder2\n              |\n              - SomeType1.c3typ\n      - SomeType3.c3typ\n  -  test\n      |\n       - src\n          |\n          - SomeType2.c3typ\n  -  gen\n      |\n       - src\n          |\n          - SomeType4.c3typ\n\nFor SomeType1.c3typ will return -> src/folder1/folder2/SomeType1\nFor SomeType3.c3typ will return -> src/SomeType3\nFor SomeType2.c3typ will return -> test/src/SomeType2\nFor SomeType4.c3typ will return -> gen/src/SomeType4\n\n@see metadataPath",
"name" : "relativeMetadataPath",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true
}
}, {
"doc" : "Helper method for constructing relative type file path from pkg root.\n\n@see #relativeMetadataPath",
"name" : "relativeTypePath",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true
}
}, {
"doc" : "@return the inner type name of this type, if it is indeed inner type otherwise `null`\n\n@see #name",
"name" : "innerTypeName",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "@return true if this is an inner type",
"name" : "isInnerType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "@return name of the native remix type declaration; includes declared action requirement",
"name" : "nativeRemixName",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true
}
}, {
"doc" : "Whether or not this is a native remix type. This means that its implementation is particular to a certain language,\nor even {@Link Action.Requirement}.\n\n```type\nnative py remix type DataFrame\n```\n\nThe native remix type native to the \"py\" {@Link Action.Requirement} and a remix of the \"DateFrame\" type.\n\n@see nativeActionRequirement",
"name" : "isNativeRemix",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "@return true if this type or any of it's mixins has a native remix for a given {@Link Action.Requirement}\n\n@see isNativeRemix",
"name" : "hasNativeRemix",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "actionEngine",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "If this is a native remix type then {@Link Action.Requirement} that this type has specific implementation for.",
"name" : "nativeActionRequirement",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Action.Requirement"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this is an abstract type that cannot be directly instantiated.",
"name" : "isAbstract",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this is an inline type i.e. one who's \"declared\" methods are implicitly inline.\n\n@see #declaredInline\n@see MethodType#isInline",
"name" : "isInline",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type is an entity (aka persistable or stored) type by virtue of mixing {@link Persistable}).\nNote that will return `false` for {@link Persistable} type itself.",
"name" : "isEntity",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this is an unnamed dynamic type created at runtime using #withFieldType or Pkg#dynamicType.",
"name" : "isDynamic",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "@return True if the type is external (e.g. Mixes External).",
"name" : "isExternal",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return True if the type is versionable (e.g. mixes Versionable).",
"name" : "isVersionable",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return True if the type is a Geography (e.g. mixes Geo).",
"name" : "isGeography",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return True if the type is a Geometry (e.g. mixes Geom).",
"name" : "isGeometry",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return True if type mixes NoSystemCols",
"name" : "isNoSystemCols",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type is potentially an entity, or is the {@link Persistable} type itself. This is an alias for\n`isA(Persistable)`.\n\nNote that Persistable itself isPersistable, so often #isEntity is more useful.\n\n@see isEntity",
"name" : "isPersistable",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"name" : "isPersistableUpsertHelper",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"name" : "isInvalidationDisabled",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type is only persists its key (e.g. Persistable, Identified, Named).\n\n@param includePersistable\n       if true, then types mixing {@link Persistable} will return false.  Otherwise they will return true.\n\n@return true if this type only persists its key.",
"name" : "isPersistKey",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "dontIncludePersistable",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return if {@link isPersistKey} returns true, the key field to be persisted (e.g. \"name\" or \"id\").",
"name" : "persistKeyField",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type can *not* be persisted. I.e. it is not an entity type or is abstract.\n\n@see #isEntity\n@see #isPersistable",
"name" : "isNotPersistable",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "@return true if type has {@link Ann.Db} with any key value datastore (i.e. mixes KvStore or default \"kv\" store)",
"name" : "isDatastoreKv",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if the type is in the KV datastore and persistence can be optimized persisting the input raw values\n        (e.g no boxing of primitive values for fields with the \"any\" value type.",
"name" : "canPersistKvRaw",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type is an annotation type, marked with the `@annotation` annotation.",
"name" : "isAnnotation",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type is a declared enum.\n\n@see Enum",
"name" : "isEnum",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type is a declared anyof (union).\n\n@see Union",
"name" : "isUnion",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link Obj}",
"name" : "isObj",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link Partitionable}",
"name" : "isPartitionable",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link DimensionBase}",
"name" : "isDimensionBase",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return the {@link PgPartitionDef} for the type if it is defined and valid.",
"name" : "pgPartition",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "PgPartitionDef"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 type contains fields that have ValueType of {@link Timeseries}",
"name" : "hasTsFields",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link Value} but not {@link Obj}",
"name" : "isValue",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a used to declare C3 Type Systems",
"name" : "isTypesys",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link Mutable}",
"name" : "isMutable",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link Stateful}",
"name" : "isStateful",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link StringSerializable}",
"name" : "isStringSerializable",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link Serializable}",
"name" : "isSerializable",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link WithType}",
"name" : "isWithType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link WithKey}",
"name" : "isWithKey",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link WithId}",
"name" : "isWithId",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link WithName}",
"name" : "isWithName",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link WithUniqueId}",
"name" : "isWithUniqueId",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link WithUniqueName}",
"name" : "isWithUniqueName",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link Identifiable}",
"name" : "isIdentifiable",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link Identified}",
"name" : "isIdentified",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link Nameable}",
"name" : "isNameable",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link Named}",
"name" : "isNamed",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is anonymous i.e it doesn't have a name",
"name" : "isAnonymous",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type represents \"fast data\".\n\n@see DataPoint",
"name" : "isDataPoint",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type is a parameter specification for a function. Note that spec parameters get auto initialized when\npassed as arguments to a function / API call.\n\n@see Spec",
"name" : "isSpec",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type represents result of the function call. Note that result types get automatically validated after\nreturn from a method or API call.\n\n@see Result",
"name" : "isResult",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link Singleton}",
"name" : "isSingleton",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link ReClaim}",
"name" : "isReClaim",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link DefaultInstance}",
"name" : "isDefaultInstance",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link DefaultClaim}",
"name" : "isDefaultClaim",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link Cached}",
"name" : "isCached",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link Config}",
"name" : "isConfig",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type is marked as a private type (not to be used outside its package).",
"name" : "isPrivate",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link Metadata}",
"name" : "isMetadata",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link SeedData}",
"name" : "isSeedData",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link ByteStream}",
"name" : "isByteStream",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link MetadataTransformer}",
"name" : "isMetadataTransformer",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link Source}",
"name" : "isSource",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link TimedDataHeader}",
"name" : "isTimedDataHeader",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link IntervalDataHeader}",
"name" : "isIntervalDataHeader",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if the type supports timed fetch",
"name" : "isTimedValueType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if the type is a timed interval type",
"name" : "isTimedIntervalType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if the type is a Timeseries type",
"name" : "isTimeseries",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if the type is a {@link TimedRelation} or {@link TimedRelationRef} or {@link TimedIntervalRelation}\nor {@link TimedIntervalRelationRef}",
"name" : "isTimedRelationType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if the type is a timed value history type",
"name" : "isTimedValueHistory",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if the type is a {@link TimedRelation} type",
"name" : "isTimedRelation",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if the type is a timed characteristic type",
"name" : "isTimedCharacteristicType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if the type is a timed interval characteristic history type",
"name" : "isTimedIntervalCharacteristicHistory",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if the type supports timed fetch",
"name" : "isTimedFetchType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link IntervalDataPoint}",
"name" : "isIntervalDataPoint",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link TimedDataPoint}",
"name" : "isTimedDataPoint",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link TimeseriesDataPoints}",
"name" : "isTimeseriesDataPoints",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is sub type of either {@link IntervalDataPoint}, {@link TimedDataPoint} or\n{@link TimeseriesDataPoints}",
"name" : "isAnyTimeseriesDataPoint",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link AclEnabled}",
"name" : "isAclEnabled",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link AclEnabledTypes}",
"name" : "isAclEnabledTypes",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 type is a subtype of {@link JdbcStore}",
"name" : "isJdbcStore",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link DataImpl}",
"name" : "isDataImpl",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link Array}",
"name" : "isArray",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link Map}",
"name" : "isMap",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 Type is a subtype of {@link Lambda}",
"name" : "isLambda",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if this C3 type is a subtype of {@link Columnar}",
"name" : "isColumnar",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Determine whether this type mixes in (directly or indirectly) another type\nor is that type itself.\n\n@param other instance of other type\n\n@see #isSame\n@see #isCoercible",
"name" : "isA",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Determine whether this type mixes in (directly or indirectly) another type\nor is that type itself.\n\n@param other instance of other type\n\n@see #isSame\n@see #isCoercible",
"name" : "isA",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "TypeMeta"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Determine whether this type mixes in (directly or indirectly) another type or is that type itself.\n\n@param other name of the other type\n\n@see #isSame\n@see #isCoercible",
"name" : "isA",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Whether the specified type represents exactly the same instance as this type. This is the strictest form of\ncompatibility, representing identical declaration.\n\n@see #isCoercible",
"name" : "isSame",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "Whether the specified type represents exactly the same instance as this type. This is the strictest form of\ncompatibility, representing identical declaration.\n\n@see #isCoercible",
"name" : "isSame",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"name" : "isSame",
"valueType" : {
"type" : "InheritedValueType"
}
}, {
"doc" : "Whether this type is a boxed type.",
"name" : "isBoxedType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type is a boxed primitive type (Integer, String, ...).",
"name" : "isBoxedPrimitiveType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type is a boxed array type.",
"name" : "isBoxedArrayType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type is a boxed map type.",
"name" : "isBoxedMapType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type is a boxed set type.",
"name" : "isBoxedSetType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type is a boxed collection type.",
"name" : "isBoxedCollectionType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Unboxes this boxed primitive type, returning the underlying value type.",
"name" : "unboxType",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "failIfNot",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "ValueType"
},
"member" : true
}
}, {
"doc" : "Unboxes this boxed primitive type, returning the underlying primitive type.",
"name" : "unboxPrimitiveType",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "failIfNot",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "PrimitiveType"
},
"member" : true
}
}, {
"doc" : "Unboxes this boxed array type.",
"name" : "unboxArrayType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "ArrayType"
},
"member" : true
}
}, {
"doc" : "Unboxes this boxed map type.",
"name" : "unboxMapType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "MapType"
},
"member" : true
}
}, {
"doc" : "Returns the number of field names shared between ths and other.",
"name" : "commonFieldNames",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
}
} ],
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"member" : true
}
}, {
"doc" : "Returns a new TypeMeta with all declaredFieldTypes from ths plus any declaredFieldTypes from other that were not\nalready on ths. If both TypeMetas have a field with the same name and different type, the type from ths will be\npreserved.",
"name" : "merge",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"member" : true
}
}, {
"doc" : "Returns ValueType that is to be returned based on BinaryOp between this and given ValueType.\n\n@param opAndValueTypeKey\n         input expected is binaryOp + \":\" + otherValueType.cacheKey()",
"name" : "opBinaryReturnType",
"private" : true,
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "opAndValueTypeKey",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "ValueType"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Returns ValueType that is to be returned based on AggOp on this.\n\n@param op\n         aggregation  operator.",
"name" : "opAggReturnType",
"private" : true,
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "op",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"enumRefType" : {
"type" : "DeclaredReferenceType",
"name" : "AggOp"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "ValueType"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Returns ValueType that is to be returned based on `isMissing` call on this.",
"name" : "opIsMissingReturnType",
"private" : true,
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "ValueType"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Generic Type from which this type was bound / narrowed.\n\nFor example, `NormTimeseries<double>` type #prototype set to unbound `NormTimeseries`.\n\n@see #name\n@see #prototypeName",
"name" : "prototype",
"valueType" : {
"type" : "InheritedValueType",
"cached" : true
}
}, {
"doc" : "Return the name of the type from which this type was bound. This is generally the same as the name, but in the case\nof bound types #prototypeName does not including the bindings.\n\nFor example, `NormTimeseries<double>` would have a prototypeName of `NormTimeseries`.\n\n@see #name\n@see #prototype",
"name" : "prototypeName",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get a single variable binding value for the specified type. The specified type may be the same type or a mixin.\nNote that the specified type is the one that declares the generic variable. The type on which the method is called\nmay be one that mixes in that type or a bound version of that type.\n\nFor example, on `Range<datetime>` both forms will return `datetime`:\n - `type.meta().varBinding(Range, \"V\")`\n - `type.meta().varBinding(\"V\")`\n\nHowever, {@link IntRange} has no generic binding itself, but binds its mixin {@link Range}:\n - `IntRange.meta().varBinding(\"V\")` returns null\n - `IntRange.meta().varBinding(Range, \"V\")` returns `int`\n\nThe combination of type and variable name is unique, even for a type that mixes in multiple generic types that\nuse the same variable name.\n\nType adds this overload to the base method in {@link Generic}.\n\n@param mixin the type to get the binding for\n@param var name of the variable on the specified type\n@param failIfUnbound if true, throw an error if the variable is not found or not fully bound",
"name" : "varBinding",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "var",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfUnbound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "ValueType"
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"name" : "varBinding",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "var",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfUnbound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "ValueType"
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"name" : "varBinding",
"valueType" : {
"type" : "InheritedValueType",
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Get a single unbound variable index in the #vars array based on a var name for a given mixin.",
"name" : "varIndex",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "var",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
},
"member" : true
}
}, {
"name" : "varIndex",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "var",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
},
"member" : true
}
}, {
"name" : "varIndex",
"valueType" : {
"type" : "InheritedValueType"
}
}, {
"doc" : "@return names of all inner types defined by this type or on all of its inner types if `deep` arg is true",
"name" : "innerTypeNames",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "SetType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "@return all inner types defined by this type",
"name" : "innerTypes",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeMeta"
}
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "@return inner type meta defined by this type by name",
"name" : "innerType",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "innerType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeMeta"
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "@return inner type (not meta) defined by this type by name",
"name" : "innerTypeToType",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "innerType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Type"
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "@return name of the immediate outer type if this is an inner type",
"name" : "outerTypeName",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "@return immediate outer type if this is an inner type",
"name" : "outerType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Type"
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "@return name of the root outer type if this is an inner type",
"name" : "outerRootTypeName",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "@return metadata sub path of the root outer type if this is an inner type",
"name" : "outerRootTypePkgSubPath",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return root outer type if this is an inner type",
"name" : "outerRootType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Type"
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Whether this type can be extended by another type.",
"name" : "isExtendable",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type can no longer be extended by another type.",
"name" : "isNotExtendable",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "Whether this type is an extending another type.",
"name" : "isExtension",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "Get the base type if this type is an extended type (e.g. it `extends` another type) or null if it isn't an\nextension type.\n\n@param failIfMissing\n          if true, throw an exception if the type is not an extension type\n\n@see #isExtension\n@see #rootType",
"name" : "baseType",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Type"
},
"member" : true
}
}, {
"name" : "baseTypeMeta",
"private" : true,
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeMeta"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get the root type if this type is an extended type (e.g. it `extends` another type) or the type itself if it isn't\nan extension type.\n\n@see #isExtension\n@see #baseType",
"name" : "rootType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Gets the value of the typeKey appended to the type's base type's extensionIdent + \":\". This value is used to\nmark/identify object instances into one specific type.",
"name" : "typeIdent",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type can no longer be mixed in by another package.",
"name" : "isNotMixable",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "Get the mixins of this type and types they mixin in turn.\n\n@see #declaredMixinReferenceTypes\n@see #declaredMixinReferenceType\n@see #declaredMixinTypes\n@see #declaredMixinType\n@see #implicitAndDeclaredMixinTypes\n@see #implicitAndDeclaredMixinType",
"name" : "mixins",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "order",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeOrder"
},
"default" : {
"type" : "Boxed<string>",
"value" : "'MIXIN'"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "Type"
}
},
"cached" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"name" : "mixinMetas",
"private" : true,
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeMeta"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Returns the {@link #mixinMetas} based on the provided prototypeNames. If multiple metas with the same\nprototypeName are found, then the first encountered meta is selected. e.g For types defined below:\n```c3typ\nFoo<T> mixes Value\n```\n```c3typ\nBar mixes Foo<Bar>, Value\n```\n```c3typ\nBaz mixes Foo<Baz>, Bar, Value\n```\nFollowing would be the expected behavior:\n```js\nvar prototypeNames = SetType.ofStr().makeBuilder().addAll('Foo', 'Value');\n// Note that only the first encountered `Foo` mixin was returned.\nBaz.meta().protoFilteredMixinMetas(prototypeNames).mapToStr(a => a.name) == ['Foo<Baz>`, `Value`]\n\nprototypeNames = SetType.ofStr().makeBuilder().addAll('Bar');\n Baz.meta().protoFilteredMixinMetas(prototypeNames).mapToStr(a => a.name) == ['Bar`]\n```\n@see #uniqueProtoMixinMetas\n@see #mixinMetas",
"name" : "protoFilteredMixinMetas",
"private" : true,
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "prototypeNames",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetBuilder",
"refVarBindings" : [ {
"type" : "StringType",
"name" : "string"
} ]
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeMeta"
}
},
"member" : true
}
}, {
"doc" : "Returns the {@link #mixinMetas} based on the unique prototypeNames of the provided type.\nIf multiple metas with the same protoTypeName are found, then the first encountered meta is selected.\ne.g For types defined below:\n```c3typ\nFoo<T> mixes Value\n```\n```c3typ\nBar mixes Foo<Bar>, Value\n```\n```c3typ\nBaz mixes Foo<Baz>, Bar, Value\n```\nFollowing would be the expected behavior:\n```js\nBaz.meta().uniqueProtoMixinMetas().mapToStr(a => a.name) == ['Foo<Baz>`, `Bar`, `Value`]\n```\n@see #protoFilteredMixinMetas\n@see #mixinMetas",
"name" : "uniqueProtoMixinMetas",
"private" : true,
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeMeta"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get a single mixin by name.\n\n@param name type name to search for",
"name" : "mixin",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Type"
},
"cached" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"name" : "mixinMeta",
"private" : true,
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeMeta"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get the mixin reference types of this type and types they mixin in turn.\n\n@see #declaredMixinRefTypes\n@see #declaredMixinRefType\n@see #declaredMixinTypes\n@see #declaredMixinType\n@see #mixins\n@see #mixin",
"name" : "mixinReferenceTypes",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "MIXIN"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "ReferenceType"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get a single declared mixin reference type by name.\n\n@param name type name to search for",
"name" : "mixinReferenceType",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "ReferenceType"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get the mixins that have source code implemented for the specified {@Link Action.Requirement} and\nall other {@Link Action.Requirement action requirements} whose {@link Action.Requirement#meetsRequirement requirements are met} by the provided action requirement.\n\n@param actionRequirement to check\n\n@see #hasSourceCode",
"name" : "mixinsWithSourceCode",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "Type"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get the declared mixins of this type.\n\n@see #mixins",
"name" : "declaredMixins",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "MIXIN"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "Type"
}
},
"cached" : true,
"member" : true
}
}, {
"name" : "declaredMixinMetas",
"private" : true,
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeMeta"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get a single declared mixin by name.\n\n@param name type name to search for",
"name" : "declaredMixin",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Type"
},
"cached" : true,
"member" : true
}
}, {
"name" : "declaredMixinMeta",
"private" : true,
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeMeta"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get the declared and implicit mixins reference types for this type. Implicit mixin examples are `Persistable`\nfor entity types or `Enum` for enum types.\n\n@see #mixins",
"name" : "implicitAndDeclaredMixinRefTypes",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "ReferenceType"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get the declared and implicit mixins of this type. Implicit mixin examples are `Persistable` for entity types or\n`Enum` for enum types.\n\n@see #mixins",
"name" : "implicitAndDeclaredMixins",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "Type"
}
},
"cached" : true,
"member" : true
}
}, {
"name" : "implicitAndDeclaredMixinMetas",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeMeta"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return all types in the current package mixing this type",
"name" : "subTypes",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "includeSelf",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "Type"
}
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "@return all types in the current package mixing this type",
"name" : "subTypeMetas",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "includeSelf",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeMeta"
}
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "@return all type names in the current package mixing this type",
"name" : "subTypeNames",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "includeSelf",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"member" : true
}
}, {
"doc" : "@return all types in the current package extending this type",
"name" : "extensionTypes",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "includeSelf",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "Type"
}
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "@return all types in the current package extending this type",
"name" : "extensionTypeMetas",
"private" : true,
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "includeSelf",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeMeta"
}
},
"member" : true
}
}, {
"doc" : "@return all type names in the current package extending this type",
"name" : "extensionTypeNames",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "includeSelf",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"member" : true
}
}, {
"doc" : "Alternatives for a Union type.\n\n@see Union",
"name" : "unionAlts",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "AnyOfType"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return `true` if this type is remixed",
"name" : "isRemixed",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "Whether this type can no longer be remixed in by another package.",
"name" : "isNotRemixable",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "@return all remix aliases for this type.",
"name" : "remixAliases",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "SetType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return native remix declaration of this type for a provided {@Link Action.Requirement actionRequirement} and\nall other {@Link Action.Requirement action requirements} whose {@link Action.Requirement#meetsRequirement requirements are met} by the provided action requirement\nor null if this type does not have native remix",
"name" : "declaredNativeRemix",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeMeta"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return native remix of this type for a provided {@Link Action.Requirement actionRequirement} or null if this type does not have native remix nor does\n        any of its mixins",
"name" : "nativeRemix",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeMeta"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return names of all depending packages that contain remix of this type.",
"name" : "allRemixPackages",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "SetType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type can no longer be mixed in or remixed by another package.",
"name" : "isFinal",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "Get a map of declared or overridden field or method types by field / method name for this type. Note since there\ncould be more then one field declaration for a name resulting map element type is actually array of FieldTypes.\n\n@see declaredFieldTypes\n@see overriddenFieldTypes",
"name" : "declaredFieldTypesByName",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "DeclaredFieldType"
}
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get a single declared or overridden field or method by name for this type. Note since there could be more then one\nfield declaration for the same name returns array of FieldTypes.",
"name" : "declaredFieldType",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "DeclaredFieldType"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return `true` if this type declares or overrides provided field.\n\n@see declaresField\n@see overridesField",
"name" : "declaresOrOverridesField",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return `true` if this type declares not just overrides provided field.\n\n@see overridesField",
"name" : "declaresField",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return `true` if this types overrides provided field or method. I.e. one of the mixins declare field or method\n        with the same name.\n\n@see declaresField",
"name" : "overridesField",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get all overridden field or method types by field / method name for this type.",
"name" : "overriddenFieldTypes",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "DeclaredFieldType"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get a map of overridden field or method types by field / method name for this type.",
"name" : "overriddenFieldTypesByName",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "DeclaredFieldType"
}
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get a single overridden field or method by name for this type.",
"name" : "overriddenFieldType",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "DeclaredFieldType"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get the type (this one or the mixin) on which the specified field was originally declared. If no such field is\ndeclared in the hierarchy, return null.\n\n```type\ntype X {\n  doit: optional member function()\n}\n\ntype Y mixes X {\n  doit: ~ js server\n}\n```\n\nIn the example above, calling from type *Y*, `fieldTypeDeclaredOn(\"doit\")` returns Y (since it is re-declared\nthere), but fieldTypeFirstDeclaredOn returns *X* (since that is the original declaration).\n\n@see fieldTypeDeclaredOn\n@see declaresField\n@see overridesField\n@see Method#overloadImplementedOn",
"name" : "fieldTypeFirstDeclaredOn",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "Type"
}
},
"member" : true
}
}, {
"name" : "fieldTypeFirstDeclaredOnMeta",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeMeta"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get the type (this one or the closest mixin) on which the specified field is declared. If no such field is\ndeclared in the hierarchy, return null. Note that this might be the original declaration of the field as a type\nmay override a field with additional information, such as providing a method implementation.\n\n@see fieldTypeFirstDeclaredOn\n@see Method#overloadImplementedOn",
"name" : "fieldTypeDeclaredOn",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "Type"
}
},
"member" : true
}
}, {
"name" : "fieldTypeDeclaredOnMeta",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeMeta"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get all field type names for this type. This includes fields defined on mixins as well as defined (or redefined\n/ overriden) on the type itself.",
"name" : "fieldTypeNames",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "MIXIN"
}
} ],
"returnType" : {
"type" : "SetType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get all method and field type names for this type. This includes methods and fields defined on mixins as well as\ndefined (or redefined / overriden) on the type itself.",
"name" : "fieldTypeAndMethodNames",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "MIXIN"
}
} ],
"returnType" : {
"type" : "SetType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get all field types for this type. This includes fields defined on mixins as well as defined (or redefined) on the\ntype itself.",
"name" : "fieldTypes",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "MIXIN"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get all field types for this type with specified {@link Annotation}. This includes fields defined on mixins as\nwell as defined (or redefined) on the type itself.",
"name" : "fieldTypesWithAnn",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "MIXIN"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
}
},
"member" : true
}
}, {
"doc" : "@return list of all field paths on this type, including fields coming from mixins",
"name" : "fieldPaths",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Generate merge specs for each data field paths on this type",
"name" : "fieldPathMergeSpecs",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"inline" : true,
"member" : true
}
}, {
"doc" : "Get field type with XmlField-txtContent annotation",
"name" : "xmlTxtContentFieldType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get a map of field types by field name for this type. This includes fields defined on mixins as well as defined\n(or redefined) on the type itself.",
"name" : "fieldTypesByName",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
}
},
"cached" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Get a single field type by name.\n\n@param field field name to find\n@param failIfMissing throw an error if the field doesn't exist",
"name" : "fieldType",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
},
"cached" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Looks up a field type by it's ordinal\n@param ordinal\n       of the field type\n@param failIfMissing\n       throw an error if the field doesn't exist",
"name" : "fieldTypeAtOrdinal",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "ordinal",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
},
"cached" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Get a single field type by serialization name. If a field has an `@ser(name)` annotation (as many do on this type\nfor example), look up the field by that name before looking it up by the formal field name.\n\n@param serName serialized field name to find\n@param failIfMissing throw an error if the field doesn't exist",
"name" : "fieldTypeBySerName",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "serName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Get a map of all field types by serialization name. If a field has an `@ser(name)` annotation (as many do on this type\nfor example), look up the field by that name before looking it up by the formal field name.",
"name" : "fieldTypesBySerName",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
}
},
"cached" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Name to be used in serialization for a `WithType#type`.\nBy default it is \"type\" but can be overridden via `@ser(name=\"...\")` on a `type` property\nReturns \"$type\" if another field overrides to the serialized name of `type`.",
"name" : "typeSerName",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"member" : true,
"property" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Traverses the field or field path",
"name" : "fieldPath",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfInvalid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldPath"
},
"member" : true
}
}, {
"doc" : "Traverses the field by provided field type, returning the corresponding FieldPath",
"name" : "fieldPath",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "fieldType",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "A list of data field types for this type; i.e. ones that are not methods, constants or inner types. Note that\nresulting array is ordered based on field type ordinal.",
"name" : "dataFieldTypes",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
}
},
"cached" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Get all data field type ordinals.\n\n@see dataFieldTypes",
"name" : "dataFieldTypeOrdinals",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "Int32Type",
"name" : "int32"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Traverses all data fields including in references.",
"name" : "eachDataFieldPath",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
} ]
}
} ],
"member" : true
}
}, {
"doc" : "Get a map of data field types by field name for this type.",
"name" : "dataFieldTypesByName",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
}
},
"cached" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Get all of data field names for this type.",
"name" : "dataFieldTypeNames",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "A list of data field types for this type that have default values. It also contains a list of field types that are\nrequired primitives",
"name" : "dataFieldTypesWithDefault",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "A list of data field types for this type that require validation\n@see ValueType#hasValidation",
"name" : "dataFieldTypesWithValidation",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get all field types for this type with specified {@link Ann.Config#secret}. This includes fields defined on mixins as\nwell as defined (or redefined) on the type itself.",
"name" : "dataFieldTypesWithSecretAnn",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get a single data field type by name.",
"name" : "dataFieldType",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
},
"cached" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Produce a checksum that can easily be compared to determine if two fieldTypes are similar. We are excluding methods\nand constants",
"name" : "dataFieldTypesFingerprint",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get a single constant by name.",
"name" : "constant",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
},
"cached" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Get all constants.",
"name" : "constants",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
}
},
"cached" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "Get all constant ordinals.",
"name" : "constantOrdinals",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "Int32Type",
"name" : "int32"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get a {@link FieldType} describing an {@link #innerType}. This field {@link #isConstant is constant}, with its\n{@link #defaultValue} being the inner type.",
"name" : "innerTypeConstant",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "innerTypeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
},
"member" : true
}
}, {
"doc" : "Get the value type of a field by name.\n\n@param field field name to find\n@param failIfMissing throw an error if the field doesn't exist",
"name" : "valueType",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "ValueType"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Traverses a reference type field or method return type, returning the Type on the other side of that ReferenceType.\nConvenient equivalent to:\n```fieldType(name).valueType().asReferenceType().dereference()```\nor\n```fieldType(name).valueType().asMethodType().returnType().asReferenceType().dereference()```\nor\n```fieldType(name).valueType().asCollectionType().elementType().asReferenceType().dereference()```\nor\n```fieldType(name).valueType().asMethodType().returnType().asCollectionType().elementType().asReferenceType().dereference()```",
"name" : "traverseType",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Type"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Traverses a reference type field or method return type, returning the Type on the other side of that ReferenceType.\nConvenient equivalent to:\n```fieldType(name).valueType().asReferenceType().dereference()```\nor\n```fieldType(name).valueType().asMethodType().returnType().asReferenceType().dereference()```\nor\n```fieldType(name).valueType().asCollectionType().elementType().asReferenceType().dereference()```\nor\n```fieldType(name).valueType().asMethodType().returnType().asCollectionType().elementType().asReferenceType().dereference()```",
"name" : "traverseTypeMeta",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeMeta"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Traverse the given field path.",
"name" : "traverseFieldPath",
"private" : true,
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldPath"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Traverses the ser field name as provided on the type, returning the corresponding FieldPath\n\n@see Ann.Ser\n@param serName\n       serialization name of the field\n@return the field path",
"name" : "traverseSerField",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "serName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldPath"
},
"cached" : true,
"member" : true
}
}, {
"name" : "serFieldTypes",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return fieldType with the matching serialized name.\n\n@see #serFieldTypes\n@see Ann.Ser",
"name" : "serFieldType",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "serName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether or not there are any fields in this type whose serialization name differs from the normal field name.\n\n@see FieldType#serName",
"name" : "hasSerNameFields",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type has any data fields. Note it skips constants.",
"name" : "hasFields",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type has any data field with defaults. Note it skips constants.",
"name" : "hasFieldDefaults",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type has any required fields.",
"name" : "hasRequiredFields",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type has any constraints such as required fields or @constraint annotation.",
"name" : "hasConstraints",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return True if entity and not generic",
"name" : "canBePersisted",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "@return True if the type has the field `id` and it's persistable.",
"name" : "hasPersistableId",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "@return True if the type has the field `name` and it's persistable.",
"name" : "hasPersistableName",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "@return True if the type has the field `meta` and it's persistable.",
"name" : "hasPersistableMeta",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return True if the type (or one of its base types) has generic bindings",
"name" : "hasPersistableTypeWithBindings",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return True if the type has annotation @config(minOverride=\"USER\")",
"name" : "hasConfigOverrideUser",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return True if instances of this type should persist the specific type bindings.  Note that for types that extend\nthis type and specify the bindings in the type definition will return false.",
"name" : "persistTypeWithBindings",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type has any methods declared.",
"name" : "hasMethods",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "A list of methods for this type.",
"name" : "methods",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "MIXIN"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "Method"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get a map of methods by name for this type.",
"name" : "methodsByName",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "Method"
}
},
"cached" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Get a single method by name.",
"name" : "method",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "method",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Method"
},
"cached" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "A list of method for this type with specified {@link Annotation}.",
"name" : "methodOverloadsWithAnn",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "MIXIN"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "MethodType"
}
},
"member" : true
}
}, {
"doc" : "Whether this type has any implicit methods (i.e. methods that are valid but not declared for the type) such as\n`with<field-name>`, `set<field-name>`, etc.\n\n@see #implicitMethods",
"name" : "hasImplicitMethods",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "Get the implicit methods for this type such as `with<field-name>`, `set<field-name>` etc.\n\n@see #methods\n@see #implicitMethodsByName",
"name" : "implicitMethods",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "Method"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get the implicit methods map by name for this type.\n\n@see #methods\n@see #implicitMethods",
"name" : "implicitMethodsByName",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "Method"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get a single method by name, whether that method is declared or implicit.\n\n@see #methods\n@see #implicitMethods",
"name" : "declaredOrImplicitMethod",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "method",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Method"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get the names of all member methods for this type.",
"name" : "memberMethodNames",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "SetType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type has a member method of the given name",
"name" : "hasMemberMethod",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this type has source code for function implementations, not including types it mixes in. If an {@Link Action.Requirement} is\nspecified, source code for that {@Link Action.Requirement action requirement}  and all other {@Link Action.Requirement action requirements} whose {@link Action.Requirement#meetsRequirement requirements are met} by the provided action requirement.\nis checked. This does not include script files that are specific to an {@Link Action.Requirement}, only ones that provide the base implementation.\n\n@param actionRequirement The {@Link Action.Requirement} to check.",
"name" : "hasSourceCode",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "The combined source code for this type in the specified language. Use {@link #sourceCodeAndFilePaths} for the\nindividual code files.\n\n@param type\n        The Type whose source code will be returned\n@param actionRequirement\n        The {@Link Action.Requirement}  which we want to get source code for. If this action requirement\n        {@link Action.Requirement#meetsRequirementFor meets requirement for} another action requirement, that  source code for that action requirement\n        for the given Type is also included. This method only returns source code for script-based action requirement.\n\n@return Source code for a Type and its remixes. This includes source code from dependent packages. The resulting\n        code is ordered in proper execution order, which is ordered from lowest -> highest precedence. `Pkg`\n        ordering takes highest precedence when determining the order of source code in the resulting string; all\n        source code for the remix of a Type will come after all source code from the package which originally\n        declared the Type. {@link declaredRemixes} enumerates all packages for which the given Type was remixed,\n        in the order of highest -> lowest precedence. {@link package} is the package which originally declared\n        this Type; source code from this package will have the lowest precedence. See\n        {@link Pkg#typeSourceCodePaths} for documentation describing the order of source code files in the scenario\n        that more than one file in a `Pkg` implements methods for the given Type and action requirement.",
"name" : "sourceCode",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true
}
}, {
"doc" : "The individual source code files for this type in the specified language. Use {@link #sourceCode} for the merged\nsource code.\n\n@param type\n        The Type whose source code will be returned\n@param actionRequirement\n        The {@Link Action.Requirement} which we want to get source code for. If this action requirement\n        {@link Action.Requirement#meetsRequirementFor meets requirement for} another action requirement, the  source code for that action requirement\n        for the given Type is also included. This method only returns source code for script-based action requirement.\n\n@return A map from source code {@link Pkg.Path} (key) to source code (value) for all source code files for a\n        Type and its remixes. This includes source code from dependent packages. The resulting map is ordered in\n        proper execution order, which is ordered from lowest -> highest precedence. `Pkg` ordering takes highest\n        precedence when determining the order of source code in the resulting map; all source code for the remix of\n        a Type will come after all source code from the package which originally declared the Type.\n        {@link declaredRemixes} enumerates all packages for which the given Type was remixed, in the order of\n        highest -> lowest precedence. {@link package} is the package which originally declared this Type; source\n        code from this package will have the lowest precedence. See {@link Pkg#typeSourceCodePaths} for\n        documentation describing the order of source code files in the scenario that more than one file in a\n        `Pkg` implements methods for the given Type and actionEngine.",
"name" : "sourceCodeAndFilePaths",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "MapType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"keyType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Pkg.Path"
}
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"member" : true
}
}, {
"doc" : "@return prototype name parsed from file name. E.g. \"Array.py-client.py\" -> \"Array\"",
"name" : "prototypeNameFromFileName",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "fileName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}
}, {
"doc" : "Whether this type has source code for function implementations, not including types it mixes in. If a language is\nspecified, only source code for that language is checked. This does not include script files that are specific to\nan {@Link Action.Requirement}, only ones that provide the base implementation.\n\n@param language The language to check.",
"name" : "actionRequirements",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "language",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "ImplLanguage"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Action.Requirement"
}
}
},
"member" : true
}
}, {
"doc" : "Produce a reference type to this type.",
"name" : "referenceType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Produce an array type of elements of this type.",
"name" : "arrayType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Produce a stream type of elements of this type.",
"name" : "streamType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Produce a set type of elements of this type.",
"name" : "setType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Produce a map type with `string` as key type and this as element type.",
"name" : "mapType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Produce a map type of elements of this type and provided with key type.",
"name" : "mapTypeOf",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"member" : true
}
}, {
"doc" : "Produce a columnar type for this type",
"name" : "columnarType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Runtime java class of the type.\n\n@see Ann.Java#runtimeClassName",
"name" : "runtimeJavaClassName",
"private" : true,
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true
}
}, {
"doc" : "Schema / table name for this type typically used by entity types.",
"name" : "schemaName",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true
}
}, {
"doc" : "@return Table name for non-external types (e.g. includes \"C3_2_\" prefix).",
"name" : "rootC3TableName",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true
}
}, {
"doc" : "Produce a default UI configuration that incorporates the information present in the type itself,\nwhen a default presentation of this type is desired.",
"name" : "defaultUi",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeDefaultUi"
},
"member" : true
}
}, {
"doc" : "@return corresponding and only Type for this TypeMeta",
"name" : "toType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "TypeMeta.fromString will build a type instance from a valid DSL declaration string.\n@see #toString",
"name" : "fromString",
"valueType" : {
"type" : "InheritedValueType"
}
}, {
"doc" : "TypeMeta.toString will build the DSL type declaration string.\n@see #fromString",
"name" : "toString",
"valueType" : {
"type" : "InheritedValueType"
}
}, {
"doc" : "Load the JSON-based representation of TypeMeta.",
"name" : "fromJson",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
}, {
"name" : "pkg",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Typesys",
"mixing" : true
},
"actionRequirementNames" : [ "java", "py" ]
}
}, {
"name" : "fromJson",
"valueType" : {
"type" : "InheritedValueType",
"actionRequirementNames" : [ "java", "py" ]
}
}, {
"doc" : "Load the JSON-based representation of TypeMeta.",
"name" : "fromJsonString",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "pkg",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Typesys",
"mixing" : true
}
}
}, {
"name" : "fromJsonString",
"valueType" : {
"type" : "InheritedValueType"
}
}, {
"doc" : "Convert the internal object representation of this TypeMeta to a JSON object specific to a {@Link Action.Engine}.\nTODO: PLAT-32339 this function should be cached, pending impl of eviction policy. Without the policy, the memory burden has been measured to be too heavy",
"name" : "toSdkJson",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "actionEngine",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Action.Engine"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"member" : true,
"actionRequirementNames" : [ "java", "py" ]
}
}, {
"doc" : "Load the XML-based representation of TypeMeta.",
"name" : "fromXmlString",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "xml",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "pkg",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Typesys",
"mixing" : true
}
}
}, {
"name" : "fromXmlString",
"valueType" : {
"type" : "InheritedValueType"
}
}, {
"doc" : "Creates a new dynamic type with the additional field definition as specified and returns it.\nThis type will be an anonymous type that mixes in the current type, adding the extra field.\n\nThis is a shortcut method for adding a single new field.  See #putFieldTypes\nfor the more general function.\n\n@param field of the new field\n@param valueType type of the new field\n@return new dynamic type",
"name" : "withFieldType",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "valueType",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"member" : true
}
}, {
"doc" : "Creates a new dynamic type with the additional field definitions as specified and returns it.\nThis type will be an anonymous type that mixes in the current type, adding the extra fields.\n\n@param field map of field specifications\n@return new dynamic type",
"name" : "withFieldTypes",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "ValueType"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"member" : true
}
}, {
"doc" : "Creates a new dynamic type with the additional field definitions as specified and returns it.\nThis type will be an anonymous type that mixes in the current type, adding the extra fields.\n\n@param field iterable of field specifications\n@return new dynamic type",
"name" : "withFieldTypesAnns",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"member" : true
}
}, {
"doc" : "Creates a new dynamic type with only the selected fields.\n\n@param names\n       list of field names to select from this TypeMeta",
"name" : "withSelectedFieldTypes",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "names",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Collection",
"refVarBindings" : [ {
"type" : "StringType",
"name" : "string"
} ]
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeMeta"
},
"member" : true
}
}, {
"doc" : "@return new builder of instance of this type",
"name" : "objBuilder",
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "O",
"restriction" : {
"type" : "DeclaredReferenceType",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder",
"refVarBindings" : [ {
"type" : "DeclaredReferenceType",
"name" : "O"
} ]
},
"member" : true
}
}, {
"doc" : "@return new builder of instance of this type with fields populated based on provided Obj",
"name" : "objBuilder",
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "O",
"restriction" : {
"type" : "DeclaredReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "initial",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder",
"refVarBindings" : [ {
"type" : "DeclaredReferenceType",
"name" : "O"
} ]
},
"member" : true
}
}, {
"doc" : "@return builder of instance of this sub type of Typesys",
"name" : "objBuilder",
"private" : true,
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "O",
"restriction" : {
"type" : "DeclaredReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "pkg",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "Pkg"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder",
"refVarBindings" : [ {
"type" : "DeclaredReferenceType",
"name" : "O"
} ]
},
"member" : true
}
}, {
"doc" : "@return empty instance of this type",
"name" : "emptyObj",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "pkg",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "Pkg"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Obj"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return resolved C3 type from a string serialized reference to it. Type resolution happens in the scope if this\n        type e.g. if provided string is a bound generic variable reference then this method will return type that\n        is bound to that generic variable. It will also bind / resolve generic variable in the provided input\n        string. E.g. assuming `K` is a generic variable in this type bound to `string` and `E` is bound to a\n        `Duration` C3 type then `dereference(\"Pair<K,E>\")` will return `Pair<string, Duration>`",
"name" : "dereference",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "DeclaredReferenceType"
}
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Type"
},
"member" : true
}
}, {
"doc" : "True if instances of this type are pooled by fingerprint",
"name" : "hasObjPool",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"final" : true,
"member" : true,
"property" : true
}
}, {
"doc" : "Construct an instance of TypeMeta from provided instance of a subtype or a \"duck type\".",
"name" : "remake",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "failIfExtraOrInvalidFields",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "pkg",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Typesys",
"mixing" : true
},
"final" : true
}
}, {
"name" : "remake",
"valueType" : {
"type" : "InheritedValueType"
}
}, {
"doc" : "Generic dispatch of the C3 Action - i.e. application of function on a C3 Type. It handles both static and member\nfunctions. For static methods #thisArg should be `null`.\n\nNote that args are expected to be of correct value type and no additional conversion will be performed.\n\n@see #callByName\n@see #callJson",
"name" : "call",
"private" : true,
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "methodType",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MethodType"
}
}, {
"name" : "thisArg",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "args",
"valueType" : {
"type" : "NativeType"
},
"varArgs" : true
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
},
"member" : true
}
}, {
"doc" : "Generic dispatch of the C3 Action - i.e. application of function on a C3 Type. It handles both static and member\nfunctions. For static methods thisArg should be `null`. If target method is overloaded, will match overload based\non argument value types.\n\nNote that args are expected to be of correct value type and no additional conversion will be performed.\n\n@see #callByName\n@see #callJson",
"name" : "call",
"private" : true,
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "method",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Method"
}
}, {
"name" : "overloadIndex",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
}, {
"name" : "thisArg",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "args",
"valueType" : {
"type" : "NativeType"
},
"varArgs" : true
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
},
"member" : true
}
}, {
"doc" : "Generic dispatch of the C3 Action - i.e. application of function on a C3 Type. It handles both static and member\nfunctions. For static methods thisArg should be `null`. If target method is overloaded, will match overload based\non argument value types.\n\nNote that while implementation will perform argument conversion it's most efficient to call with correct argument\nvalue types.\n\n@see #callByName\n@see #callJson",
"name" : "call",
"private" : true,
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "thisArg",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "args",
"valueType" : {
"type" : "NativeType"
},
"varArgs" : true
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
},
"member" : true
}
}, {
"doc" : "Generic dispatch of the C3 Action - i.e. application of function on a C3 Type. It handles both static and member\nfunctions. For member methods args should contain `this` key. If target method is overloaded will match overload\nbased on argument value types.\n\nNote that while implementation will perform argument conversion it's most efficient to call with correct argument\nvalue types.\n\n@see #call\n@see #callJson",
"name" : "callByName",
"private" : true,
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "args",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "NativeType"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
},
"member" : true
}
}, {
"doc" : "Generic dispatch of the C3 Action - i.e. application of function on a C3 Type. It handles both static and member\nfunctions. If target method is overloaded will match overload based on argument value types.\n\nNote that while implementation will perform argument conversion it's most efficient to call with correct argument\nvalue types.\n\n@see #call\n@see #callJson",
"name" : "callByArgsAndKwargs",
"private" : true,
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "thisArg",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "args",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "NativeType"
}
}
}, {
"name" : "kwargs",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "NativeType"
}
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
},
"member" : true
}
}, {
"doc" : "Generic dispatch of the C3 Action - i.e. application of function on a C3 Type. It handles both static and member\nfunctions. Expectation is that input is a valid serialization of C3 Action named arguments including `this` in case\nof member actions. Return is a C3 value.\n\n@see #call\n@see #callByName",
"name" : "callJson",
"private" : true,
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "input",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
},
"member" : true
}
}, {
"doc" : "Generic dispatch of the C3 Action - i.e. application of function on a C3 Type. It handles both static and member\nfunctions. Expectation is that args is a valid serialization of C3 Action positional arguments and kwargs\nare a valid serialization of C3 Action named arguments.\nReturn is a C3 value.\n\n@see #call\n@see #callByName",
"name" : "callJson",
"private" : true,
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "thisArg",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
}, {
"name" : "args",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
}, {
"name" : "kwargs",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
},
"member" : true
}
}, {
"doc" : "Dispatch of the C3 Action from a Java Code Generated C3 type instances and implementations\n\n@see #call\n@see #callByName\n@see #callJson",
"name" : "callFromCodeGen",
"private" : true,
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "method",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Method"
}
}, {
"name" : "overloadIndex",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
}, {
"name" : "thisArg",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "args",
"valueType" : {
"type" : "AnyType"
},
"varArgs" : true
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
},
"member" : true
}
}, {
"doc" : "@return result of a call to a method [ aka memoization ]; this is slightly different then #call as actual result\n        type may not match method return type. E.g. if method takes",
"name" : "memoize",
"private" : true,
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "method",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MethodType"
}
}, {
"name" : "thisArg",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "keys",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "include",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "Include"
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "Exclude"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "T"
},
"member" : true
}
}, {
"doc" : "@return empty instance of this type",
"name" : "instantiate",
"private" : true,
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "O"
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "O"
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "@return new instance of this type based on provided string representation\n\n@see StringSerializable#fromString",
"name" : "instantiate",
"private" : true,
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "O"
} ],
"params" : [ {
"name" : "s",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "O"
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "@return new instance of this type with the specified fields",
"name" : "instantiate",
"private" : true,
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "O"
} ],
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "pkg",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "Pkg"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "O"
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "@return new instance of this type using the language-specific construction mechanism\n\n@see Obj#make",
"name" : "instantiate",
"private" : true,
"valueType" : {
"type" : "MethodType",
"genericVars" : [ {
"name" : "O"
} ],
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "\"java.lang.Object[]\""
} ]
} ],
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "pkg",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "Pkg"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "O"
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "@return type system scope for building / binding declared fields and value types.",
"name" : "scope",
"private" : true,
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypesysScope"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return Java class for interface for instances of this type or null",
"name" : "javaInterface",
"private" : true,
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'java.lang.Class'"
} ]
} ]
},
"member" : true
}
}, {
"doc" : "@return The set of all calc fields, (stored and read) in this type",
"name" : "calcFields",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return The set of all read calc fields in this type",
"name" : "readCalcFields",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return a calc field expression rewritten to replace type casting with typeIdent checks.  Note this only returns\n        a rewritten expression if there were replaced type casts.\n\nFOR INTERNAL USE ONLY",
"name" : "rewrittenCalcFieldExpr",
"private" : true,
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "origExpr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "\"c3.platform.expr.ast.ExprNode\""
} ]
} ]
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return The set of all fields that constraints depend on in this type.",
"name" : "constraintDepFields",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return List of all fields that the db engine enforces constraints on.",
"name" : "dbEngineConstraintFields",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "newRecord",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return true if all of the db engine constraint fields are \"simple\" (e.g. don't involve included references).",
"name" : "useSimpleDbEngineConstraintCheck",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "newRecord",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return {@link Db.Domain} if this entity type belongs to a specific Db.Domain\n\n@see Ann.Db#domain",
"name" : "dbDomain",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Db.Domain"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return {@link Expr} for calculating target app id to call for type\n\n@see Ann.Call#serverRole",
"name" : "targetAppExpr",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Expr"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return {@link Expr} for calculating target server role for this type\n\n@see Ann.Call#serverRole",
"name" : "targetNodeRoleExpr",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Expr"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return {@link Expr} for calculating target server node pool for this type\n\n@see Ann.Call#nodePool",
"name" : "targetNodePoolExpr",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Expr"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return {@link Expr} for calculating target server node for this type\n\n@see Ann.Call#node",
"name" : "targetNodeExpr",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Expr"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return {@link Expr} for calculating target thread-pool for this type\n\n@see Ann.Call#threadPool",
"name" : "targetThreadPoolExpr",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Expr"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return True if any constraints have any fields they depend on.",
"name" : "hasConstraintDepFields",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "@return True if the type has any non-fkey child collections. Includes recursive included type fields.",
"name" : "hasChildCollection",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return List of all collection fields (including nested) that are persisted in this type.",
"name" : "persistableCollectionFields",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return a map of all tables used for persisted collections, keyed by the field path for the collection field.",
"name" : "collectionTables",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return list of all fields that have the textSearchField db annotation. For Postgres, a full text search index\n        will be created",
"name" : "textSearchFields",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return A list of field types that will have non-null values on Obj instantiation (e.g. fields with default values on\ntypes that aren't entity types as well as boolean fields)",
"name" : "fieldTypesWithInitialValue",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@returns the conditional constraint, if any, for the type.",
"name" : "conditionalConstraint",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Pair",
"refVarBindings" : [ {
"type" : "DeclaredReferenceType",
"name" : "Expr.Compiled",
"refVarBindings" : [ {
"type" : "DeclaredReferenceType",
"name" : "Obj"
}, {
"type" : "BooleanType",
"name" : "boolean"
} ]
}, {
"type" : "StringType",
"name" : "string"
} ]
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return cached and shared scope / compiled unit of given Action.Engine for this type.",
"name" : "actionEngineScope",
"private" : true,
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "actionEngine",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "Action.Engine"
}
}
} ],
"returnType" : {
"type" : "NativeType"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return The composite key type for the type, if any. The composite key type is the type in the mixin chain that\n        directly mixes CompositeKey. For CompositeKey types themselves, this will return itself.",
"name" : "compositeKeyType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Type"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return the list of fields comprising the composite key, For any type that isA composite key and an empty\n        array otherwise.",
"name" : "compositeKeyFields",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return the list of fields comprising the primary key. If the type has a composite key, it will be the fields\n        defined in the key type. Otherwise the id field will be returned for persistable types. For\n        non-persistable fields, an empty array is returned.",
"name" : "primaryKeyFields",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return the column name for the id field",
"name" : "idColName",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true
}
}, {
"doc" : "@return `true`, if this is an EventStream or has fields of type EventStream.",
"name" : "hasEventStream",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true,
"property" : true
}
}, {
"doc" : "Gets the set of all fields in this type and, optionally, any of it's extension base types that have\nthe @db(timedValueHistoryField) annotation\n\n@param inclExtBaseFields\n       true indicates that fields defined in extension base types for the type should be included. False\n       means that only fields defined in the type itself should be returned.\n@return the set of all fields in this type and, optionally, any of it's extension base types that have the\n@db(timedValueHistoryField) annotation",
"name" : "timedValueFields",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "inclExtBaseFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Gets the set of all fields in this type and, optionally, any of it's extension base types that are the field\nreferenced in a @db(timedValueHistoryField) annotation for a timed value field\n\n@param inclExtBaseFields\n       true indicates that fields defined in extension base types for the type should be included. False\n       means that only fields defined in the type itself should be returned.\n@return the set of all fields in this type and, optionally, any of it's extension base types that are the field\n        referenced in a @db(timedValueHistoryField) annotation for a timed value field",
"name" : "timedValueHistoryFields",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "inclExtBaseFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get the timed value history field for the specified timed value field.\n\n@param field\n       The timed value field.\n\n@return The timed value history field for the specified timed value field.  If the specified field is not a timed\n        value field, or is not associated with a history field, null is returned.",
"name" : "timedValueFieldForHistoryField",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Gets the set of all fields in this type and, optionally, any of it's extension base types that have\nthe @db(timedCharacteristicHistoryField) annotation\n\n@param inclExtBaseFields\n       true indicates that fields defined in extension base types for the type should be included. False\n       means that only fields defined in the type itself should be returned.\n@return the set of all fields in this type and, optionally, any of it's extension base types that have the\n@db(timedCharacteristicHistoryField) annotation",
"name" : "timedCharacteristicFields",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "inclExtBaseFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Gets the set of all fields in this type and, optionally, any of it's extension base types that are the field\nreferenced in a @db(timedCharacteristicHistory) annotation for a timed characteristic field\n\n@param inclExtBaseFields\n       true indicates that fields defined in extension base types for the type should be included. False\n       means that only fields defined in the type itself should be returned.\n@return the set of all fields in this type and, optionally, any of it's extension base types that are the field\n        referenced in a @db(timedCharacteristicHistoryField) annotation for a timed characteristic field",
"name" : "timedCharacteristicHistoryFields",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "inclExtBaseFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get the timed characteristic history field for the specified timed characteristic field.\n\n@param field\n       The timed characteristic field.\n\n@return The timed characteristic history field for the specified timed characteristic field.  If the specified\n        field is not a timed characteristic field, or is not associated with a history field, null is returned.",
"name" : "timedCharacteristicFieldForHistoryField",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return True if the type is configured to retain a history of edits to each obj.",
"name" : "keepVersionHistory",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return list of indexes defined for this type in the @db(index) extension. Each entry will be a list of sort fields\n        for the index.",
"name" : "indexes",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "SortField"
}
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return list of unique indexes defined for this type in the db extension. Each entry will be an array of fields in the\n        unique index.  Index fields can optionally refer to a field of an included reference and that's why FieldPath\n        is used",
"name" : "uniqueConstraints",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldPath"
}
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return a map of timed value parent types/fields grouped by source type.",
"name" : "timedValuesParent",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Returns a map of timed characteristic parent types/fields grouped by source type.",
"name" : "timedCharacteristicsParent",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return calc field backward dependencies for a type",
"name" : "calcBwdDeps",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeBackwardDep"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return acl backward dependencies for a type",
"name" : "aclBwdDeps",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeBackwardDep"
}
},
"member" : true
}
}, {
"doc" : "Determines the set of fields that trigger invalidation for the specified queue.\n\n@param queueType\n       Queue type to check invalidation for.\n@param includeBaseTypes\n       If true, base type fields will also be included.\n@param includeExtensionTypes\n       If true, extension types will also be included.\n@param ignoreSelfDeps\n       If true, self deps (e.g. deps that have no parent) will be ignored.\n@param forBeforeUpdate\n       If true, only looking for deps that should be triggered during the beforeUpdate phase.\n\n@return the set of fields that trigger invalidation for the specified queue",
"name" : "triggeringFields",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "queueType",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "includeBaseTypes",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "includeExtensionTypes",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "ignoreSelfDeps",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "forBeforeUpdate",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "SetType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"member" : true
}
}, {
"doc" : "Determines the set of fields that trigger invalidation for the specified key.\n\n@param key\n       key describing trigger scenario\n\n@return the set of fields that trigger invalidation for the specified key.",
"name" : "_triggeringFields",
"private" : true,
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "key",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "SetType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return the value specified in Ann.Db.datastore (if any) or overridden in the Db.Domain.  This will currently be\n        \"kv\" for data persisted in the KV store, null by default for data persisted in the c3 managed relational\n        datastore, or the name of a specific datastore.",
"name" : "datastore",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true
}
}, {
"doc" : "The datastore to maintain a parallel synchronized copy of the data for the type, typically to a system like\nRedshift for advanced analytic querying capabilities.",
"name" : "secondaryDatastore",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return List of all fields that specify the `Ann.Db.include` annotation.",
"name" : "fieldsWithInclude",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return extension type at any level with provided typeIdent.",
"name" : "subTypeForTypeIdent",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "typeIdent",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfInvalid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Type"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return True if the typeIdent is valid for any subtype of this type.",
"name" : "isValidTypeIdent",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "typeIdent",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"name" : "authz",
"private" : true,
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return value of `@action(authzChildActions=` annotation",
"name" : "authzChildActions",
"private" : true,
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return value of `@action(accessControlGroups=` annotation",
"name" : "accessControlGroups",
"private" : true,
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return remixed type by merging annotations, fields and methods from a provided #remixType into this one",
"name" : "remix",
"private" : true,
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "remixType",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"member" : true
}
}, {
"doc" : "Get repository type belongs to.",
"name" : "repository",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true
}
}, {
"doc" : "Ensures that this TypeMeta contains field names that can be parsed by Type System DSL. For example,\n\"hello:world\" is an invalid field name because it contains the \":\" character which is used as a delimiter between\nfield name and ValueType.\n\n@return new TypeMeta with invalid field names replaced with valid field names",
"name" : "ensureValidFieldNames",
"private" : true,
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Checks if type is facaded for a given app. Facaded types live in a different app.\n\n@return true if type is facaded in an app other than the one specified. I.e. call to this type from app that is\n        different then provided app will resolve into a remote call",
"name" : "isFacade",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "app",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"type" : "DeclaredReferenceType",
"name" : "AppId"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"name" : "isNoOverlapTimedIntervalValueHistoryType",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "parentType",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "@return True if this type mixes in the IntervalDataHeader type but not the NormalizedTimeseries type",
"name" : "isRawTimeseries",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"name" : "isRawTimeseriesDataPoint",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"name" : "isAnyNormalized",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"name" : "isNormalizedTimedDataPoint",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"name" : "isNormalizedTimeseriesDataPoint",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"name" : "isAnyExpr",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return True if this type mixes in the TimedDataHeader type but not the NormalizedTimeseries type",
"name" : "isRawTimedData",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"name" : "isRawTimedDataPoint",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return name of the field for partitioning instances of this type for storage.",
"name" : "partitionKeyField",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return FieldType of the field for partitioning instances of this type for storage.",
"name" : "partitionKeyFieldType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldType"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return compiled partition key field expression (or id) on the given type",
"name" : "compiledPartitionKeyFieldExpr",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Expr.Compiled"
},
"cached" : true,
"member" : true
}
}, {
"name" : "shortIdPrefix",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"member" : true
}
}, {
"name" : "shortIdSuffixType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"member" : true
}
}, {
"name" : "shortIdReservationRange",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "IntType",
"name" : "int"
},
"cached" : true,
"member" : true
}
}, {
"name" : "hasShortId",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return whether this type is parametric",
"name" : "isGeneric",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return a list of all fields that are fkey fields (both array and single ref)",
"name" : "fkeyFields",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Map, keyed by types that have fkey fields with this type as a reference type, where each element is the list of\nthe fkey field names.",
"name" : "fkeyParents",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "DeclaredReferenceType",
"name" : "Type"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Db Extension: @return filter spec to be used for a read only one to many relationship.",
"name" : "fkeyRefFilter",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true
}
}, {
"doc" : "Db Extension: @return field path that is a foreign key in the reference type for a read only one to many\nrelationship.",
"name" : "fkeyRefFkey",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true
}
}, {
"doc" : "Db Extension: @return field path that is a key in the source type for a read only one to many relationship.",
"name" : "fkeyRefKey",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true
}
}, {
"doc" : "Db Extension: @return order spec to be used for a read only one to many relationship.",
"name" : "fkeyRefOrder",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true
}
}, {
"doc" : "@return whether this value type is an fkey reference array field.",
"name" : "isFkeyRefArray",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "@return whether this value type is an fkey reference array field.",
"name" : "isFkeyRefArray",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"name" : "isFkeyRef",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "@return the hierarchy denorm type for this type's hierarchy",
"name" : "hierDenormTarget",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "HierDenormTarget"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Get the path in repository to directory containing type.",
"name" : "parentDirPathInRepo",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"member" : true
}
}, {
"doc" : "@return false if duplicates should be removed when persisting instances of this type",
"name" : "persistDuplicates",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "@return true if the type has a viewFilter or viewInclude specified",
"name" : "hasViewIncludeOrFilter",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Gets the set of all stored calc fields in this type and, optionally, any of its extension base types",
"name" : "storedCalcFields",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "inclExtBaseFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return True if the type has any stored calc fields, timed value fields  or timed characteristic fields.",
"name" : "hasStoredCalcOrTimedValues",
"private" : true,
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "inclExtBaseFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return the list of field that are the \"latest characteristic\" fields linked to `TimedCharacteristicHistory`\n        fields.",
"name" : "latestCharacteristicsFields",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return set of all fields used in any of the unique field sequences",
"name" : "allUniqueConstraintFields",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "SetType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"member" : true
}
}, {
"name" : "setPrototype",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "prototype",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
}
} ],
"member" : true
}
}, {
"name" : "retainedObjs",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "filter",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"name" : "offset",
"valueType" : {
"type" : "IntType",
"name" : "int"
}
}, {
"name" : "limit",
"valueType" : {
"type" : "IntType",
"name" : "int"
}
} ],
"returnType" : {
"type" : "StreamType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "Obj"
}
},
"member" : true
}
}, {
"name" : "allocated",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "IntType",
"name" : "int"
},
"member" : true
}
}, {
"name" : "hasConfiguredAnnotations",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "True if this field is unique. This is expected to be called on an entity type and that the field path\nis a valid field path in this type.",
"name" : "isUnique",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"name" : "isArchiveable",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "tenantConfigNoArchive",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"name" : "isCompositeKeyType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"name" : "isAnnotationType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"name" : "isCompactType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"name" : "isPlatformType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"name" : "isSystemType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"name" : "isVersioned",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"name" : "isEvaluatable",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "Returns true if the type mixes {@link Searchable}",
"name" : "isSearchable",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return True if the given field is a constant, i.e., fixed to its default value.",
"name" : "isConstant",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "fieldName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Reference type for the provided reference field type name.\n\n@param name\n       of the reference typed field\n@return a reference type for the field",
"name" : "fieldReferenceType",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "ReferenceType"
},
"member" : true
}
}, {
"doc" : "Called by platform when a Persistable type is accessed to ensure that its schema is up to date.\n\n@return true if the schema was updated in this JVM/app",
"name" : "validateSchema",
"private" : true,
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "Called by platform when a Kv type is accessed to ensure that its schema is up to date.\n\n@return true if the schema was updated in this JVM/app (result of first call is cached return value).",
"name" : "validateKvSchema",
"private" : true,
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Called by {@link validateSchema} to validate the schema for a type and all its extension types.\n\n@return true if the schema was updated in this JVM for the type and current app code (result of first call is\n        cached return value).",
"name" : "doValidateSchema",
"private" : true,
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true
}
}, {
"doc" : "Calculates all \"forward\" dependencies of this type to other types or metadata elements",
"name" : "dependencies",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMetaDeps"
},
"member" : true
}
}, {
"doc" : "@return fingerprint / checksum of this type including it's dependencies\n\n@see Fingerprintable#fingerprint",
"name" : "fingerprintWithDeps",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Retrieves child metadata element at character position in the declaration of this C3 type\n\n@param line\n       line number starting with 1 in the source file\n@param charInLine\n       character position in a line starting with 1 in the source file\n@return child metadata element at character position in the declaration of this C3 type",
"name" : "metaElementAt",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "line",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
}, {
"name" : "charInLine",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Typesys"
},
"member" : true
}
}, {
"doc" : "@return map of declared child metadata elements where key is source line number starting with 1 in a c3typ and\n        values are elements declared on that line ordered by declaration character position",
"name" : "declaredMetaElements",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "MapType",
"annotationsJson" : [ {
"sorted" : [ {
"name" : "key",
"value" : true
} ]
} ],
"keyType" : {
"type" : "Int32Type",
"name" : "int32"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "Typesys"
}
}
},
"cached" : true,
"member" : true,
"property" : true
}
}, {
"doc" : "@return named TupleType for the given TypeMeta",
"name" : "toTupleType",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "TupleType"
},
"member" : true
}
}, {
"name" : "docParsed",
"valueType" : {
"type" : "InheritedValueType"
}
}, {
"name" : "afterMake",
"valueType" : {
"type" : "InheritedValueType",
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"name" : "toSubtype",
"private" : true,
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'c3.platform.typesys.type.Subtype_Base'"
}, {
"name" : "codeGenExtends",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY"
},
"cached" : true,
"member" : true
}
}, {
"name" : "_javaSubtype",
"private" : true,
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'c3.platform.typesys.type.Subtype_Base'"
} ]
} ]
},
"cached" : true,
"member" : true
}
}, {
"name" : "_myJavaMethods",
"private" : true,
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'c3.platform.Methods_Base'"
} ]
} ]
},
"cached" : true,
"member" : true
}
}, {
"name" : "_javaMethods",
"private" : true,
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'c3.platform.Methods_Base'"
} ]
} ]
},
"cached" : true,
"member" : true
}
}, {
"name" : "_staticsCache",
"private" : true,
"valueType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'java.util.concurrent.ConcurrentHashMap'"
} ]
} ]
}
}, {
"name" : "_sourceCodeCache",
"private" : true,
"valueType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'c3.platform.typesys.util.SimpleCache'"
} ]
} ]
}
}, {
"name" : "cacheKey",
"valueType" : {
"type" : "InheritedValueType",
"actionRequirementNames" : [ "java", "py" ]
}
}, {
"doc" : "Replaces the old {@link TypeMeta} instance with the new one.",
"name" : "replaceTypeMeta",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "old",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
}
}, {
"name" : "new",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
}
} ],
"private" : true,
"inline" : true,
"member" : true
}
}, {
"name" : "avroSchema",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'org.apache.avro.Schema'"
} ]
} ]
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Returns the field names of all of the fields on a {@link Searchable} type with the {@link Ann.Search} annotation",
"name" : "searchableFields",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"member" : true
}
}, {
"doc" : "@return True if the cache is null",
"name" : "cacheNulls",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Returns the {@link TypeMeta} of the types.\n\n@param names\n       Names of the types to filter on. Action will throw an exception if a passed type name is null or invalid.\n       If empty, it returns {@link TypeMeta} for all the types.\n       If not empty, only returns the {@link TypeMeta} for the passed type names.\n@param includeInnerTypes\n       Includes inner {@link TypeMeta}s if set to true",
"name" : "all",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "names",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"name" : "includeInnerTypes",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "DeclaredReferenceType",
"name" : "TypeMeta"
}
}
}
} ],
"isWithType" : true,
"isObj" : true,
"isMutable" : false,
"isStateful" : false,
"isSingleton" : false,
"isDefaultInstance" : false,
"isAbstract" : false,
"hasEventStream" : false,
"isGeneric" : false,
"isNativeRemix" : false,
"hasVarBindings" : false,
"prototypeName" : "TypeMeta",
"typeSerName" : "type",
"hasSerNameFields" : false,
"annotations" : {
"type" : "Annotations"
},
"mixins" : [ "Generic", "Typesys", "WithType", "Value", "Obj", "Serializable", "Fingerprintable", "MemoryMeasurable", "NameableType", "Annotatable", "Documentable", "HtmlRenderable", "Nameable", "WithName", "WithKey", "Fingerprinted", "StringSerializable", "WithToString", "WithCacheKey" ],
"referenceType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"mixinsWithSourceCode" : {
"js-ide-vscode-client-node" : [ "WithType", "Obj", "Annotatable", "Documentable", "StringSerializable" ]
},
"fieldTypes" : [ {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"doc" : "The metadata path where the parent type's declaration file is located:\nFormat: meta://<package>/[gen|test]/src/<packageSubPath>/<name>.c3typ\nE.g. for the given package folder structure:\n```\nmyRepo\n |\n -  myPkg\n     |\n     -  src\n         |\n         - folder1\n             |\n             - folder2\n                 |\n                 - SomeType1.c3typ\n         - SomeType3.c3typ\n     -  test\n         |\n          - src\n             |\n             - SomeType2.c3typ\n     -  gen\n         |\n          - src\n             |\n             - SomeType4.c3typ\n```\nFor SomeType1.c3typ will return -> meta://myPkg/src/folder1/folder2/SomeType1.c3typ\nFor SomeType3.c3typ will return -> meta://myPkg/src/SomeType3.c3typ\nFor SomeType2.c3typ will return -> meta://myPkg/test/src/SomeType2.c3typ\nFor SomeType4.c3typ will return -> meta://myPkg/gen/src/SomeType4.c3typ\n\n@see #package\n@see #packageSubPath",
"name" : "metadataPath",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"suppress" : true
}
},
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"doc" : "The name of the package where this type was declared.\n\nFor example, if package \"app\", depends on \"industry\", which depends on \"foundation\", provisioning app will bring\nin the types in the industry and foundation packages as well. This means that the `package` of the Location\ntype will be foundation, even if it gets remixed by industry (or even app).\n\n@see #metadataPath\n@see #packageSubPath",
"name" : "package",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"suppress" : true
}
},
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"doc" : "Dot (\".\") separated relative path of the folder where this type's declaration file is located in the package\nE.g. for the given structure\n```\nmyRepo\n |\n -  myPkg\n     |\n     -  src\n         |\n         - folder1\n             |\n             - folder2\n                 |\n                 - SomeType1.c3typ\n         - SomeType3.c3typ\n     -  test\n         |\n          - src\n             |\n             - SomeType2.c3typ\n     -  gen\n         |\n          - src\n             |\n             - SomeType4.c3typ\n```\nFor SomeType1.c3typ will return -> folder1.folder2\nFor SomeType3.c3typ will return -> \"\" (empty string)\nFor SomeType3.c3typ will return -> \"\" (empty string)\nFor SomeType4.c3typ will return -> \"\" (empty string)\n\n@see #metadataPath\n@see #package",
"name" : "packageSubPath",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"suppress" : true
}
},
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"ser" : [ {
"name" : "hidden",
"value" : true
} ]
}, {
"constraint" : [ {
"name" : "readOnly",
"value" : true
} ]
} ],
"doc" : "@return C3 application package this Type System element belongs to",
"name" : "pkg",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"ser" : [ {
"name" : "hidden",
"value" : true
} ]
}, {
"constraint" : [ {
"name" : "readOnly",
"value" : true
} ]
} ],
"annotationJsonByName" : {
"ser" : [ {
"name" : "hidden",
"value" : true
} ],
"constraint" : [ {
"name" : "readOnly",
"value" : true
} ]
},
"constraint" : {
"type" : "Ann.Constraint",
"readOnly" : true
},
"ser" : {
"type" : "Ann.Ser",
"hidden" : true
}
},
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg",
"isNumber" : false,
"instanceType" : "Pkg"
}
}, {
"type" : "FieldType",
"doc" : "The name of this type, which will be unique within its package. For most types, there will be simply the declared\nname (`User`). For nested inner types, this will include the parent type name (`Parent.Child`). For bound types,\nthe bindings will be incorporated into the name (`NormTimeseries<float>`).\n\nNote that #name could be null for dynamic types that are not part of any package.\n\n@see #prototypeName\n@see #innerTypeName\n@see #qname",
"name" : "name",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "StringType",
"name" : "string",
"isNumber" : false
}
}, {
"type" : "FieldType",
"doc" : "The map of variable bindings applied.\n\nIt is possible to have bind variable re-named. I.e. to have varBinding that itself is a variable of different name.",
"name" : "varBindings",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "MapType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "ValueType"
},
"isNumber" : false,
"instanceType" : "Map<string, ValueType>"
}
}, {
"type" : "FieldType",
"doc" : "The set of annotations defined on this element of metadata represented as json value.",
"name" : "annotationsJson",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "JsonType",
"name" : "json",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"doc" : "The raw textual documentation associated with this piece of metadata. This will have the original comment\ncharacters removed, but otherwise be a simple block of text with the original formatting retained. Only\ndocumentation comments (starting with `/**`) will be used for this purpose and only when immediately\npreceding the structure they document.",
"name" : "doc",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"suppress" : true
}
},
"valueType" : {
"type" : "StringType",
"name" : "string",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"deprecated" : [ ]
}, {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"name" : "docSingleLine",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"deprecated" : [ ]
}, {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"annotationJsonByName" : {
"deprecated" : [ ],
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"suppress" : true
},
"deprecated" : {
"type" : "Ann.Deprecated"
}
},
"valueType" : {
"type" : "BooleanType",
"name" : "boolean",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"native\""
} ]
} ],
"doc" : "True if this type is declared `native`. This means that its implementation is particular to a certain language\nand perhaps even {@Link Action.Requirement}, and is not available in others.\n\n```type\nnative type BrowserUtil\nnative py remix type DataFrame\n```\n\n@see #isNativeRemix",
"name" : "declaredNative",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"native\""
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "syntax",
"value" : "\"native\""
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"syntax" : "native"
}
},
"valueType" : {
"type" : "BooleanType",
"name" : "boolean",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"entity\""
} ]
} ],
"doc" : "True if this type is declared as entity type. This means it may not be persisted in the database. Entity types\nimplicitly mixin {@link Persistable}.\n\n@see Persistable",
"name" : "declaredEntity",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"entity\""
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "syntax",
"value" : "\"entity\""
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"syntax" : "entity"
}
},
"valueType" : {
"type" : "BooleanType",
"name" : "boolean",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"enum\""
} ]
} ],
"doc" : "If true, this type is a declared as enum type:\n```type\nenum type Colors { RED YELLOW GREEN BLUE }\n```\n\n@see Enum",
"name" : "declaredEnum",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"enum\""
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "syntax",
"value" : "\"enum\""
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"syntax" : "enum"
}
},
"valueType" : {
"type" : "BooleanType",
"name" : "boolean",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "flag",
"value" : true
}, {
"name" : "syntax",
"value" : "\"union\""
} ]
} ],
"doc" : "If set, this type is declared as a union type:\n```type\nunion type Stringish = string | [string]\n```\n\n@see Union",
"name" : "declaredUnionAlts",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "flag",
"value" : true
}, {
"name" : "syntax",
"value" : "\"union\""
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "flag",
"value" : true
}, {
"name" : "syntax",
"value" : "\"union\""
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"syntax" : "union",
"flag" : true
}
},
"valueType" : {
"type" : "ReferenceType",
"name" : "AnyOfType",
"isNumber" : false,
"instanceType" : "AnyOfType"
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"duck\""
} ]
} ],
"doc" : "If true, this type is a \"duck type\". I.e. mixin pattern in any other type that is matching to this duck type will\nbe replaced by this type.\n\nE.g. type-system among others defines following duck types:\n* `abstract entity duck type CachedPersistable mixes Cached`\n* `duck type StrStream mixes Stream<string>`\n\nThis means any entity type that is also `Cached` will actually mixin `CachedPersistable` and any method that is\nreturning `stream<string>` will actually return instance of `StrStream`\n\n@see #isDuckType",
"name" : "declaredDuck",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"duck\""
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "syntax",
"value" : "\"duck\""
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"syntax" : "duck"
}
},
"valueType" : {
"type" : "BooleanType",
"name" : "boolean",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"abstract\""
} ]
} ],
"doc" : "True if this type is declared abstract. This means it may not be instantiated separately, but can be a mixin of\nanother type.\n\nAbstract methods declared in mixin types of an abstract type continue to be abstract. Normally abstract methods are\nclaimed by a sup-type unless those methods are explicitly re-declared as abstract using `<myMethod>: abstract ~`\nsyntax.\n\nNote that mixin of abstract type does not make sub-type automatically be abstract.  If such a type is also\nabstract, it must be explicitly marked.\n\n@see FieldType#abstract",
"name" : "declaredAbstract",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"abstract\""
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "syntax",
"value" : "\"abstract\""
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"syntax" : "abstract"
}
},
"valueType" : {
"type" : "BooleanType",
"name" : "boolean",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"inline\""
} ]
} ],
"doc" : "True if this type's methods are automatically inline. This is a **shortcut** for marking every \"declared\" method\nas *inline* and these methods will be inline in all of the subtypes of the current type even if the subtype may\nnot be inline. This should only be used for performance critical types whose methods never need authorization and\ndon't expect any support for argument or return value processing.\n\nPlease note that **overridden methods in an inline type DO NOT automatically become inline.** e.g\n```c3typ\ntype Boo {\n  bar: function()\n  baz: member function()\n}\n\ninline type Foo mixes Boo {\n   bar: inline ~\n   baz: ~\n}\n```\nIn the above code, Foo.bar is inline while Foo.baz is not. Boo.bar and Boo.baz both are not inline.\n\n@see #isInline\n@see MethodType#inline\n@see MethodType#isInline",
"name" : "declaredInline",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"inline\""
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "syntax",
"value" : "\"inline\""
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"syntax" : "inline"
}
},
"valueType" : {
"type" : "BooleanType",
"name" : "boolean",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"final\""
} ]
} ],
"doc" : "True if this type is declared final. This means that none of its data fields or methods may be changed by types\nthat mix it in. Note that a type itself may not be final, but may also declare certain fields final.\n\n@see FieldType#isFinal\n@see Method#isFinal\n@see #notMixable",
"name" : "declaredFinal",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"final\""
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "syntax",
"value" : "\"final\""
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"syntax" : "final"
}
},
"valueType" : {
"type" : "BooleanType",
"name" : "boolean",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"private\""
} ]
} ],
"doc" : "True if this type is a private type. This means that it may not be used outside of its declaring package.\n\n@see FieldType#private",
"name" : "declaredPrivate",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"private\""
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "syntax",
"value" : "\"private\""
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"syntax" : "private"
}
},
"valueType" : {
"type" : "BooleanType",
"name" : "boolean",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"extendable\""
} ]
} ],
"doc" : "Indicates that a type is extendable.  Extendable types allow the creation of a type hierarchy where more specific\ntypes extend less specific type (e.g. Hospital extends Facility extends FixedAsset).\n\nExtendable types are typically entity types and shares the same database table / storage and base type can be\nqueried to retrieve all instances of all sub-types.\n\nSetting this type modifier implicitly mixes @{link Extendable}.\n\n@see #declaredNotExtendable",
"name" : "declaredExtendable",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"extendable\""
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "syntax",
"value" : "\"extendable\""
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"syntax" : "extendable"
}
},
"valueType" : {
"type" : "BooleanType",
"name" : "boolean",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"non extendable\""
} ]
} ],
"doc" : "True if this type may not be further extended. Note that this only makes sense for types which themselves extend\na type (marked as `extendable`), but don't allow further extension.\n\n```type\nextendable entity type Fruit\ntype StoneFruit extends Fruit\nnot extendable type Cherry extends StoneFruit\n```\nIn the example, above Cherry may not further be extended.\n\n@see #declaredExtendable",
"name" : "declaredNotExtendable",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"non extendable\""
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "syntax",
"value" : "\"non extendable\""
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"syntax" : "non extendable"
}
},
"valueType" : {
"type" : "BooleanType",
"name" : "boolean",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"extends\""
} ]
} ],
"doc" : "Reference to a base type this type extends.\n\n@see #baseType\n@see #isExtendable\n@see #isNotExtendable",
"name" : "declaredExtendsRefType",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"extends\""
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "syntax",
"value" : "\"extends\""
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"syntax" : "extends"
}
},
"valueType" : {
"type" : "ReferenceType",
"name" : "DeclaredReferenceType",
"isNumber" : false,
"instanceType" : "DeclaredReferenceType"
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"not mixable\""
} ]
} ],
"doc" : "True if this type may not be mixed into any other types outside the declaring package. This is used by certain\ntypes that the system needs to know cannot have new sub-types declared.",
"name" : "declaredNotMixable",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"not mixable\""
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "syntax",
"value" : "\"not mixable\""
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"syntax" : "not mixable"
}
},
"valueType" : {
"type" : "BooleanType",
"name" : "boolean",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"mixes\""
} ]
} ],
"doc" : "References to other types that this type directly mixes in.\n\n@see #mixins\n@see #inNotMixable",
"name" : "declaredMixinRefTypes",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"mixes\""
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "syntax",
"value" : "\"mixes\""
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"syntax" : "mixes"
}
},
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "DeclaredReferenceType"
},
"isNumber" : false,
"instanceType" : "Array<DeclaredReferenceType>"
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"remix\""
} ]
} ],
"doc" : "If true, this type is a remix of one with the same name in one of the packages this package depends on.\n\nA remix means the definitions augment the base definitions when provisioned. Otherwise, it is an error to have the\nsame type defined multiple times within the same tag (aka deployment unit). I.e. given package can not simply\ndeclare an new type with the same name as in one of it's depending packages.\n\n@see #isNotRemixable",
"name" : "declaredRemix",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"remix\""
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "syntax",
"value" : "\"remix\""
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"syntax" : "remix"
}
},
"valueType" : {
"type" : "BooleanType",
"name" : "boolean",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"not remixable\""
} ]
} ],
"doc" : "True if this type may not be remixed. This is used by certain types that the system needs to know cannot be\nchanged from outside the package.",
"name" : "declaredNotRemixable",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"not remixable\""
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "syntax",
"value" : "\"not remixable\""
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"syntax" : "not remixable"
}
},
"valueType" : {
"type" : "BooleanType",
"name" : "boolean",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"as\""
}, {
"name" : "ident",
"value" : true
} ]
} ],
"doc" : "If this type was remixed by one or more remixes and type is specifying an alias, then all the aliases.\n```type\nremix type Foo as OtherFoo\n```\nIn the above example, the remixed type is \"Foo\" with an alias \"OtherFoo\".",
"name" : "declaredRemixAlias",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"as\""
}, {
"name" : "ident",
"value" : true
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "syntax",
"value" : "\"as\""
}, {
"name" : "ident",
"value" : true
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"syntax" : "as",
"ident" : true
}
},
"valueType" : {
"type" : "StringType",
"name" : "string",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"type key\""
} ]
} ],
"doc" : "For extendable types, the key used to identify the type's position in the hierarchy.  The value contributes to\nthe {@link Extendable.typeIdent} field so that an instance's leaf type can be determined without having\n{@link Obj.type} field value.",
"name" : "declaredTypeKey",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"type key\""
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "syntax",
"value" : "\"type key\""
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"syntax" : "type key"
}
},
"valueType" : {
"type" : "StringType",
"name" : "string",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"fields\""
} ]
} ],
"doc" : "Declared and overridden fields and methods on this type.\n\n@see declaredFieldTypesByName\n@see declaredFieldType\n@see overriddenFieldTypes",
"name" : "declaredFieldTypes",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"fields\""
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "syntax",
"value" : "\"fields\""
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"syntax" : "fields"
}
},
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "DeclaredFieldType"
},
"isNumber" : false,
"instanceType" : "Array<DeclaredFieldType>"
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"doc" : "Types defined directly within this type. For example {@link Ann} has inner types for all possible annotations.",
"name" : "declaredInnerTypes",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"suppress" : true
}
},
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
},
"isNumber" : false,
"instanceType" : "Array<any>"
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"doc" : "Types that are implementation language native remixes of this type.",
"name" : "declaredNativeRemixes",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"suppress" : true
}
},
"valueType" : {
"type" : "MapType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"keyType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
},
"elementType" : {
"type" : "AnyType"
},
"isNumber" : false,
"instanceType" : "Map<!string serialized Action.Requirement, any>"
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"doc" : "Types that are remixes of this type along with pkg they were declared in.\nFor example, if package \"app\", depends on \"industry\", which depends on \"foundation\", and `Facility` was defined in\n\"foundation\" and remixed in \"app\", then\n```js\nC3.type(\"Facility\").declaredRemixes.size() == 1\nC3.type(\"Facility\").declaredRemix == false\nC3.type(\"Facility\").package == 'foundation'\nC3.type(\"Facility\").declaredRemixes.keys().collect() == ['app']\nC3.type(\"Facility\").declaredRemixes.get(\"app\").declaredRemix == true\nC3.type(\"Facility\").declaredRemixes.get(\"app\").package == 'app'\n```\n\n@see #declaredRemix",
"name" : "declaredRemixes",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"suppress" : true
}
},
"valueType" : {
"type" : "MapType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"keyType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
},
"isNumber" : false,
"instanceType" : "Map<!string, any>"
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"doc" : "Method(s) implementation source code. The key is the language name and the value is the source code for all\nfunctions implemented in that language on this type.",
"name" : "declaredSourceCode",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"suppress" : true
}
},
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
},
"isNumber" : false,
"instanceType" : "Map<string, string>"
}
}, {
"type" : "FieldType",
"doc" : "The list of unbound variable declarations and any restrictions on them.",
"name" : "declaredVars",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "VarReferenceType"
},
"isNumber" : false,
"instanceType" : "Array<VarReferenceType>"
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"doc" : "If this is a native remix type, the {@Link Action.Requirement} for which the native implementation is defined.\n\n```type\npy native remix type DataFrame\n```\n\nThe native remix type PyDataFrame is native to the \"py\" {@Link Action.Requirement}",
"name" : "declaredNativeRequirement",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"suppress" : true
}
},
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
},
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"schema name\""
} ]
} ],
"doc" : "Name of the underlying schema (e.g. database table name)",
"name" : "declaredSchemaName",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "syntax",
"value" : "\"schema name\""
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "syntax",
"value" : "\"schema name\""
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"syntax" : "schema name"
}
},
"valueType" : {
"type" : "StringType",
"name" : "string",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"doc" : "A type may globally specify a default implementation language and {@Link Action.Requirement}:\n\n```type\njs-browser type ConsoleGrid\n```\n\nThis means that all methods without explicit claims, both declared and inherited abstract, are claimed for\nthe type's default {@Link Action.Requirement}, \"js-browser\" in this case. This is very convenient for types with lots of methods\nall of which are implemented in the same language.\n\n@see MethodType#actionRequirementNames",
"name" : "defaultActionRequirement",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"suppress" : true
}
},
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
},
"isNumber" : false
}
}, {
"type" : "FieldType",
"name" : "_staticsCache",
"private" : true,
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'java.util.concurrent.ConcurrentHashMap'"
} ]
} ],
"isNumber" : false
}
}, {
"type" : "FieldType",
"name" : "_sourceCodeCache",
"private" : true,
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'c3.platform.typesys.util.SimpleCache'"
} ]
} ],
"isNumber" : false
}
} ],
"methods" : [ {
"type" : "Method",
"name" : "type",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "C3 Type of this instance.",
"name" : "type",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "type",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "replaceType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns new instance with all references to old type, including result of #type, replaced with new type. If new\ntype does not contain fields from old or field value types are not convertable then drops the field.\n\nThis method is used during live metadata update",
"name" : "replaceType",
"params" : [ {
"name" : "old",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "new",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "replaceType",
"params" : [ {
"name" : "old",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "new",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "old", "new" ]
}
}, {
"type" : "Method",
"name" : "super",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithType" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithType"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : " Produce a calling proxy that represents the content of all Obj type's mixins, but not the type itself. This is\n useful for redispatching **member** methods reimplemented on this type to a parent implementation:\n ```js\n function toString() {\n   return this.super().toString() + ', x=' + this.x;\n }\n ```\n\n ```py\n def toString(this):\n    return this.super().toString() + ', x=' + this.x\n```\n\n To redispatch **static** methods, see {@link Type#super}.\n\n Note that this not the same as the language-specific `super` keyword because it works through the type system and\n supports multiple mixins. It behaves like the Python `super()` function, except called on the instance rather than\n globally.\n\n If `mixin` is the implementing type in a client implementation, this will delegate the call to the server.\n This can be used to create a local implementation \"around\" the server implementation for additional caching or\n other local state management.\n\n @param mixin if specified, this mixin is used instead or an error is thrown\n @return \"super\" calling proxy for this object\n\n @see Type.super",
"name" : "super",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "ReferenceType",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "super",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "ReferenceType",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"paramNames" : [ "mixin" ]
},
"$nearestImplementedOn" : "WithType"
}, {
"type" : "Method",
"name" : "toJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a JSON object.\n\n@return JSON object representation\n\n@see #fromJson",
"name" : "toJson",
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"name" : "toJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"name" : "toJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
} ]
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ]
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"paramNames" : [ "include", "exclude" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "toTypedJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a _typed_ JSON object.\n@param omitTopLevelType\n       Whether to leave out `type: {{ type of this serializable instance }}` as the **first** key-value pair in\n       the outer level of the produced json.\n@param runtime\n       If provided, then any special serialization logic required for the {@link ImplLanguage.Runtime} will be\n       performed. **NOTE** This argument is ignored if `typed` is not `true`. @see Ann.Ser\n\n\n@return JSON object representation\n\n@see #fromJson\n@see #toJson\n@see serdeser.c3doc\n@see JsonType",
"name" : "toTypedJson",
"params" : [ {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"name" : "toTypedJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"name" : "toTypedJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toTypedJson",
"params" : [ {
"name" : "omitTopLevelTypeOrIncludeOrInclude",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
} ]
}
}, {
"name" : "actionRequirementOrExcludeOrExclude",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
}, {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
} ]
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"paramNames" : [ "omitTopLevelTypeOrIncludeOrInclude", "actionRequirementOrExcludeOrExclude" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "toJsonString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toJsonString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized JSON string.\n\n@return JSON object as string",
"name" : "toJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "pretty" ]
}
}, {
"type" : "Method",
"name" : "toTypedJsonString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toTypedJsonString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"name" : "toTypedJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toTypedJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "pretty", "omitTopLevelType" ]
}
}, {
"type" : "Method",
"name" : "toJsString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toJsString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized JavaScript object literal.\n\n@return JavaScript object literal string",
"name" : "toJsString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJsString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "withType" ]
}
}, {
"type" : "Method",
"name" : "toXmlString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toXmlString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized XML string.\n\n@return XML element as string\n\n@see #fromXmlString",
"name" : "toXmlString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toXmlString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "withType" ]
}
}, {
"type" : "Method",
"name" : "serialize",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a string serialized representation of the object.\n\n@return string serialized object representation",
"name" : "serialize",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "serialize",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "contentType" ]
}
}, {
"type" : "Method",
"name" : "fromJson",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the JSON-based representation and reconstruct the corresponding object.\n\nfromJson is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which may be\na type that mixes in the type on which it is called). This means that the resulting object's type will be isA the\ncalled-on type, but perhaps not identical. In particular, `Obj.fromJson` works for any actual type and will return\nan instance of the correct type.\n\n@see #toJson",
"name" : "fromJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Load the JSON-based representation of TypeMeta.",
"name" : "fromJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
}, {
"name" : "pkg",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
}, {
"name" : "pkg",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "json", "pkg" ]
}
}, {
"type" : "Method",
"name" : "fromJsonString",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the JSON-based representation and reconstruct the corresponding object.\n\nfromJsonString is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which may be\na type that mixes in the type on which it is called). This means that the resulting object's type will be isA the\ncalled-on type, but perhaps not identical. In particular, `Obj.fromJsonString` works for any actual type and will return\nan instance of the correct type.\n\n@see #toJsonString",
"name" : "fromJsonString",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Load the JSON-based representation of TypeMeta.",
"name" : "fromJsonString",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "pkg",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
},
"inline" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromJsonString",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "pkg",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "json", "pkg" ]
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "fromXmlString",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the XML-based representation and reconstruct the corresponding object.\n\nfromXmlString is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which\nmay be a type that mixes in the type on which it is called). This means that the resulting object's type will be\nisA the called type, but perhaps not identical. In particular, `Obj.fromXmlString` works for any actual type and\nwill return an instance of the correct type.\n\n@see #toXmlString",
"name" : "fromXmlString",
"params" : [ {
"name" : "xml",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
},
"inline" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Load the XML-based representation of TypeMeta.",
"name" : "fromXmlString",
"params" : [ {
"name" : "xml",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "pkg",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
},
"inline" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromXmlString",
"params" : [ {
"name" : "xml",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "pkg",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "xml", "pkg" ]
}
}, {
"type" : "Method",
"name" : "deserialize",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load from contentType representation and reconstruct the corresponding object.\n\nfromString is be called on the type be deserialized and must reconstruct an object of the appropriate type\n(which may be a type that mixes in the type on which it is called). This means that the resulting object's type\nwill be isA the called-on type, but perhaps not identical. In particular, `fromString` works for any actual\ntype and will return an instance of the correct type.",
"name" : "deserialize",
"params" : [ {
"name" : "contentStr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "deserialize",
"params" : [ {
"name" : "contentStr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "contentStr", "contentType" ]
}
}, {
"type" : "Method",
"name" : "fingerprint",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Produce a checksum that can easily be compared to determine if two objects are definitely different. Note that\nthere is a slight possibility that two objects with the same fingerprint will actually differ.\n\nThe fingerprint recurses into field values, including collections and referenced Objs. The handling of nested\n{@link Identified identified} references (typically entities) differ in that _only_ the `id` field is included\nunless the allIdentifiedRefFields option is specified.\n\nIf the object graph may contain recursive embedded object references, the trackRecursiveRefs option may be used.\nHowever, maintaining the list of visited objects is costly so this should not be done unnecessarily.\n\n@param allIdentifiedRefFields\n          if `true`, fingerprint individual fields of persistable references, not just the `id`\n@param trackRecursiveRefs\n          if `true`, a set of referenced objects is maintained to avoid infinite recursion\n@param traversedRefs\n          only considered together with trackRecursiveRefs and if provided then all traversed references are\n          checked against and added to it\n@return integer fingerprint\n\n@see https://en.wikipedia.org/wiki/Fingerprint_(computing)",
"name" : "fingerprint",
"params" : [ {
"name" : "allIdentifiedRefFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "trackRecursiveRefs",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "traversedRefs",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<Obj>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fingerprint",
"params" : [ {
"name" : "allIdentifiedRefFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "trackRecursiveRefs",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "traversedRefs",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<Obj>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"paramNames" : [ "allIdentifiedRefFields", "trackRecursiveRefs", "traversedRefs" ]
}
}, {
"type" : "Method",
"name" : "retainedMemory",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Measures retained memory by this instance.\n\n@param deep\n       if true and this instance contains references to other objects also measures memory retained by those\n@param allMeasured\n       if set then will skip instances that are in the set and will add instances that where measured by this call\n@return retained memory in bytes for this instances",
"name" : "retainedMemory",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "allMeasured",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<any>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "retainedMemory",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "allMeasured",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<any>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"paramNames" : [ "deep", "allMeasured" ]
}
}, {
"type" : "Method",
"name" : "instanceOf",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Checks whether this Obj is an instance of the specified type by checking both its type and the mixin chain.\nThis is the most convenient way to ask \"is this type usable in a context requiring the other type?\"\n\n@return true if this instance is of this type or any of its mixins",
"name" : "instanceOf",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Checks whether this instance is an instance of the specified type by checking both its type and the mixin chain.\nThis is the most convenient way to ask \"is this type usable in a context requiring the other type?\"\n\n@return true if this instance is of this type or any of its mixins\n\n@see ValueType#isA",
"name" : "instanceOf",
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "instanceOf",
"params" : [ {
"name" : "typeNameOrType",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ]
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "typeNameOrType" ]
}
}, {
"type" : "Method",
"name" : "isEmptyObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether all the fields of this instance are empty.",
"name" : "isEmptyObj",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isEmptyObj",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "isSame",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether the specified instance represents exactly the same object as this instance.",
"name" : "isSame",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Whether the specified type represents exactly the same instance as this type. This is the strictest form of\ncompatibility, representing identical declaration.\n\n@see #isCoercible",
"name" : "isSame",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Whether the specified type represents exactly the same instance as this type. This is the strictest form of\ncompatibility, representing identical declaration.\n\n@see #isCoercible",
"name" : "isSame",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isSame",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Type"
}
} ]
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "other" ]
}
}, {
"type" : "Method",
"name" : "fieldValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns value of the given field.\n\n@param field\n          Field to return the value for\n       defaultToEmpty\n          will return default empty value if field is missing",
"name" : "fieldValue",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Returns value of the given field type. Be sure to use the FieldType instance for the exact same type as the type of\nthe obj.\n\n@param field\n          Field to return the value for\n       defaultToEmpty\n          will return default empty value if field is missing\n@return value for the given field",
"name" : "fieldValue",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValue",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
} ]
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "field", "defaultToEmpty" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fieldValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldValue"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all non empty field values. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValues",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldValue"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValues",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldValue"
}
}
}
}, {
"type" : "Method",
"name" : "fieldValuesByOrdinal",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all field values including empty ones as array where value of a field is at corresponding ordinal position.\nUnless `skipTrailingEmpty` parameter is set and there are trailing empty values resulting array has same size as\n#dataFieldTypes",
"name" : "fieldValuesByOrdinal",
"params" : [ {
"name" : "skipTrailingEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesByOrdinal",
"params" : [ {
"name" : "skipTrailingEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"paramNames" : [ "skipTrailingEmpty" ]
}
}, {
"type" : "Method",
"name" : "fieldValuesByFieldType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all non empty field values by field type. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValuesByFieldType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesByFieldType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
}
}, {
"type" : "Method",
"name" : "fieldValuesByFieldName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all non empty field values by field name. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValuesByFieldName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesByFieldName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}
}, {
"type" : "Method",
"name" : "fieldNames",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all data field names including those whose values are empty. Array is ordered by field ordinal.",
"name" : "fieldNames",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldNames",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}
}, {
"type" : "Method",
"name" : "at",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return value of the field at provided ordinal\n\n@param ordinal\n        Integer ordinal of the field in the parent type\n@return value of field at ordinal",
"name" : "at",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "ordinal",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Return value for the given serialized expression\n\n@param expr\n        Serialized expression to obtain the value in the given Obj\n@param failIfNotValid\n        If set, fails if not a valid expression\n@return value obtained as a result of expression evaluation",
"name" : "at",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "expr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
}, {
"name" : "failIfNotValid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "at",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "ordinalOrExpr",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
}, {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
} ]
}
}, {
"name" : "failIfNotValid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "ordinalOrExpr", "failIfNotValid" ]
}
}, {
"type" : "Method",
"name" : "fieldValueAtPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Looks up a single field value by path from this Obj. Field paths are separated by dots so an expression like\n`fieldValueAtPath(\"location.elevation\")` is equivalent to `traverse(\"location\").fieldValue(\"elevation\")` except\nthat it also handles `null`. If path contains any collections then only first element will be traversed,\nunless the collection index is specified in the path.\n\nIf you need to traverse all elements of collection fields use #fieldValuesAtPath instead.\n\n@param fieldPath\n          field names separated by dots\n@param failIfNotFound\n          if true, an error will be thrown if the any of the field types aren't defined\n@param context\n          if an error is thrown, the context returned by calling the lambda will be incorporated\n@return the field or null",
"name" : "fieldValueAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValueAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "fieldPath", "failIfNotFound", "context" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fieldValuesAtPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "VarReferenceType",
"name" : "T"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Looks up all the fields by path from root Obj. If path contains any collections then result will contain all\ntraversals, unless the collection index is specified in the path.\n\n@param fieldPath\n          field names separated by dots\n@param failIfNotFound\n          if true, an error will be thrown if the any of the field types aren't defined\n@param context\n          if an error is thrown, the context returned by calling the lambda will be incorporated\n@return fields as a flat list\n\n@see #fieldValueAtPath",
"name" : "fieldValuesAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "VarReferenceType",
"name" : "T"
}
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "VarReferenceType",
"name" : "T"
}
},
"paramNames" : [ "fieldPath", "failIfNotFound", "context" ]
}
}, {
"type" : "Method",
"name" : "eachFieldValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Perform an action for each non-empty field of this object.\n\n@param action\n          lambda to apply",
"name" : "eachFieldValue",
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Perform an action for each field of this object. Fields are filtered based on provided `spec`.\n\n@param spec\n          which fields to include\n@param action\n          lambda to apply",
"name" : "eachFieldValue",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachFieldValue",
"params" : [ {
"name" : "actionOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"paramNames" : [ "actionOrSpec", "action" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "eachFieldValueWhile",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Perform an action for each field of this object while processing action returns `true`. Fields are filtered based\non provided `spec`.\n\n@param spec\n          which fields to include\n@param action\n          lambda to apply; stop if this `action` returns `false\n@return `true` if iteration was not aborted by lambda i.e. it saw all field values",
"name" : "eachFieldValueWhile",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachFieldValueWhile",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "spec", "action" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "eachRef",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type. For reference fields, this means\nthe field value if non-null and for collections of Obj, this means each element in the collection.\n\n@param action\n          function to be executed for each pair of field type and Obj instance",
"name" : "eachRef",
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type. For reference fields, this means\nthe field value if non-null and for collections of Obj, this means each element in the collection.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param action\n          function to be executed for each pair of field type and Obj instance",
"name" : "eachRef",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRef",
"params" : [ {
"name" : "actionOrIncludeEmpty",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
}, {
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ]
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"paramNames" : [ "actionOrIncludeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "eachRefWhile",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type while processing action returns\n`true`.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param action\n          function to be executed for each pair of field type and Obj instance; stops processing if return `false`\n@return `true` if iteration was not aborted by lambda i.e. it saw all refs",
"name" : "eachRefWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRefWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "includeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "eachRefRecursive",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type or in any child refs.",
"name" : "eachRefRecursive",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRefRecursive",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"paramNames" : [ "includeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "eachRefRecursiveWhile",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type or in any child refs. Continue while\nprocessing action returns `true`.",
"name" : "eachRefRecursiveWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRefRecursiveWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "includeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "mapFieldValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Result of this function call is a copy of current instance with all non empty fields replaced based on results of\nthe `mapper` invocation.\n\n@param action\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValues",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Result of this function call is a copy of current instance with all fields replaced based on results of the\n`mapper` invocation.\n\n@param spec\n          which fields to include\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValues",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapFieldValues",
"params" : [ {
"name" : "mapperOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "convertValueOrMapper",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ]
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "mapperOrSpec", "convertValueOrMapper", "convertValue" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapFieldValuesAsync",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing TypeMeta>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Result of this function call is a copy of current instance with all non empty fields replaced based on results of\nthe asynchronous `mapper` invocation.\n\n@param action\n          lambda to apply for every field value to produce a new value for that fields\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValuesAsync",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing TypeMeta>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Result of this function call is a copy of current instance with all fields replaced based on results of the\nasynchronous `mapper` invocation.\n\n@param spec\n          which fields to include\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValuesAsync",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing TypeMeta>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"name" : "mapFieldValuesAsync",
"params" : [ {
"name" : "mapperOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "convertValueOrMapper",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
} ]
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing TypeMeta>",
"hadDeclaredVarBindings" : true
},
"paramNames" : [ "mapperOrSpec", "convertValueOrMapper", "convertValue" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapFieldValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Result of this function call is a copy of current instance with specified field value replaced based on result of\nthe `mapper` invocation.\n@param field\n          field being mapped\n@param includeEmpty\n          if set, invokes mapper for fields with empty value\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValue",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapFieldValue",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "field", "includeEmpty", "mapper", "convertValue" ]
}
}, {
"type" : "Method",
"name" : "mapRefs",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Executes the specified lambda against each referenced Obj instance and replaces it's value with result of this\nlambda application.\n\nResult of this function call is a copy of current instance with all references replaced based on results of the\n`mapper` invocation.\n\n@param action\n          function to be executed for each pair of field type and Obj instance\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapRefs",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Executes the specified lambda against each referenced Obj instance and replaces it's value with result of this\nlambda application.\n\nResult of this function call is a copy of current instance with all references replaced based on results of the\n`mapper` invocation.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param mapper\n          function to be executed for each pair of field type and Obj instance for producing new reference value\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapRefs",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapRefs",
"params" : [ {
"name" : "mapperOrIncludeEmpty",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
}, {
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ]
}
}, {
"name" : "convertValueOrMapper",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
} ]
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "mapperOrIncludeEmpty", "convertValueOrMapper", "convertValue" ]
}
}, {
"type" : "Method",
"name" : "foldFieldValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Result of this function is application of `folder` lambda to every non empty field value where `accumulator`\nargument is a result of previous application. Initial value of `accumulator` will be `null`.\n\nThis function is useful for calculating aggregate values based on all current non empty field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Result of this function is application of `folder` lambda to every non empty field value where `accumulator`\nargument is a result of previous application. Initial value of `accumulator` is provided via `initial` parameter.\n\nThis function is useful for calculating aggregate values based on all current non empty field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "initial",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Result of this function is application of `folder` lambda to every field value where `accumulator` argument is a\nresult of previous application. Initial value of `accumulator` is provided via `initial` parameter.\n\nThis function is useful for calculating aggregate values based on all field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "initial",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}, {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "folderOrInitialOrInitial",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
}, {
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ]
}
}, {
"name" : "folderOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "folderOrInitialOrInitial", "folderOrSpec", "folder" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "evalProjection",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "AnyType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Evaluates given projection expression over this instance.",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
}, {
"name" : "resultType",
"valueType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "AnyType"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Evaluates given projection over this instance and returns results as json.",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "JsonType",
"name" : "json"
},
"inline" : true,
"member" : true,
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Evaluates given projection over this instance and returns results as instance of the new Obj.",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
}, {
"name" : "resultType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
},
"inline" : true,
"member" : true,
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
}, {
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
} ]
}
}, {
"name" : "resultTypeOrBindingsOrResultType",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
}, {
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
} ]
}
}, {
"name" : "bindingsOrOptionsOrBindings",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ]
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "AnyType"
},
"paramNames" : [ "projection", "resultTypeOrBindingsOrResultType", "bindingsOrOptionsOrBindings", "options" ]
}
}, {
"type" : "Method",
"name" : "validateObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjResult"
}
} ]
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Populates all missing default values and throws error if any constraint it violated.",
"name" : "validateObj",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Validate that the Obj fields are set according to all the required rules.",
"name" : "validateObj",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjSpec"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjResult"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "validateObj",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjSpec"
}
} ],
"returnType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjResult"
}
} ]
},
"paramNames" : [ "spec" ]
}
}, {
"type" : "Method",
"name" : "withField",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the provided field in it. The name must correspond to an existing field\ndefined on this type or its mixins. The value must be of the correct type if doNotConvert flag is true.\n\n@param field\n          name of the field\n@param value\n          of the field\n@param doNotConvert\n          if true, do not attempt to convert the value to match the field's type\n@return new Obj",
"name" : "withField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the provided field in it. The name must correspond to an existing field\ndefined on this type or its mixins. The value must be of the correct type if doNotConvert flag is true.\n\n@param field\n          the field\n@param value\n          of the field\n@param doNotConvert\n          if true, do not attempt to convert the value to match the field's type\n@return new Obj",
"name" : "withField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
} ]
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "field", "value", "doNotConvert" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "withFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the provided fields in it. The name must correspond to an existing fields\ndefined on this type or its mixins. The values must be of the correct type if doNotConvert flag is true.\n\n@param fields\n          map of fields name/values\n@param doNotConvert\n          if true, attempt to convert the values to match the fields' type\n@return new Obj",
"name" : "withFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "fields", "doNotConvert" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "withFieldAtPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj with the value at the specified path field. If the value is null, the final field is removed.\n\nImmutable objects may return the same instance if the field being set or removed does not actually represent a\nchange to the existing object.\n\n@param path\n          path to set value at\n@param value\n          value to set\n@param doNotConvert\n          if true, attempt to convert the values to match the fields' type\n@param doNotCreateIfMissing\n          true indicates that any empty reference along the path will not set the value\n@return new Obj",
"name" : "withFieldAtPath",
"params" : [ {
"name" : "path",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "doNotCreateIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withFieldAtPath",
"params" : [ {
"name" : "path",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "doNotCreateIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "path", "value", "doNotConvert", "doNotCreateIfMissing" ]
}
}, {
"type" : "Method",
"name" : "withoutField",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the field with the provided name.\n\nImmutable objects may return the same instance if the field being removed is not present in the existing object.\n\n@param name\n          of the field to remove\n@return new Obj with removed field",
"name" : "withoutField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the field with the provided field type.\n\nImmutable objects may return the same instance if the field being removed is not present in the existing object.\n\n@param field\n          of the field to remove\n@return new Obj with removed field",
"name" : "withoutField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
} ]
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "field" ]
}
}, {
"type" : "Method",
"name" : "withoutFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the fields with the provided names.\n\nImmutable objects may return the same instance if the fields being removed are not present in the existing object.\n\n@param names\n          of the fields to remove\n@return new Obj with removed fields",
"name" : "withoutFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "withoutFieldsByType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the fields with the provided field types. Be sure to use the FieldType instance for the\nexact same type as the type of the obj to respect the \"ordinal\" of the field type\n\nImmutable objects may return the same instance if the fields being removed are not present in the existing object.\n\n@param fields\n          of the fields to remove\n@return new Obj with removed fields",
"name" : "withoutFieldsByType",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutFieldsByType",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "withDefaults",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the default values (if defined) for all empty fields. This is implemented by\ncalling {@link FieldType#defaultValue defaultValue} for a field if it is not already set and\n{@link FieldType#hasDefault has a default}. It will also set {@see ValueType#initialValue initial values} for\nfields with required primitive ValueTypes (E.g. x: `!int32` -> will be set to 0). Note that this will not overwrite\nfields that have already been set.\n\n{@link FunctionParam#validateArg} will call {@link #withDefaults} for {@link Spec}s passed as arguments to methods.\nAs a result, methods should be implemented assuming all default values are set on `Spec` arguments.\n\n@param includeEmptyRefsWithDefaults\n          it `true` then missing / empty child references that have fields with defaults will also be instantiated\n@param defaultFields\n          If not empty, a list of default field paths to populate.  Any default fields not specified in the\n          array will be ignored.\n@return new Obj\n\n@see FieldType#defaultValueConst\n@see FieldType#defaultValue",
"name" : "withDefaults",
"params" : [ {
"name" : "includeEmptyRefsWithDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "defaultFields",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withDefaults",
"params" : [ {
"name" : "includeEmptyRefsWithDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "defaultFields",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "includeEmptyRefsWithDefaults", "defaultFields" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mergeObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Merges all the fields of the provided Obj into this instance, producing a new Obj of the same type as this one.\nIn case of conflicts, fields of other instance take precedence unless otherwise specified by the fieldPathMergeSpec\n\n@param other\n          object\n@param fieldPathMergeSpec\n          mapping of fields of the object to the respective merge annotations\n@return the new merged Obj",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "fieldPathMergeSpec",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Merges all the fields of the provided Obj into this instance, producing a new Obj of the same type as this one.\nIn case of conflicts, fields of other instance take precedence.\n\n@param other\n          object\n@param otherFieldsFilter\n          only fields of otherFieldsFilter type from other are merged into this obj.\n@return the new merged Obj",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "otherFieldsFilter",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Merge the fields of this Obj with corresponding fields on other Obj using the provided lambda. This means that\nfields that exist on other Obj and do not exist on this Obj will not be added to final Obj.\n@param deep\n       if set to true then traverse reference and collection fields and merge corresponding fields or elements with\n       the same key or index.",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 2
}, {
"type" : "MethodType",
"doc" : "Merge the fields of this Obj with corresponding fields on other Obj using the provided lambda. This means that\nfields that exist other Obj and do not exist on this Obj will not be added to final Obj or evaluated. Does not\ntraverse child reference and collection fields.",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 3
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "fieldPathMergeSpecOrOtherFieldsFilterOrDeepOrMerger",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ]
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "other", "fieldPathMergeSpecOrOtherFieldsFilterOrDeepOrMerger", "merger" ]
}
}, {
"type" : "Method",
"name" : "mergeAndExpandObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Create new Obj with all non-null fields of this and other. Fields that are non null in both apply merger lambda.\nFields that non null in only one of this and other will be in the resulting Obj without change.",
"name" : "mergeAndExpandObj",
"genericVars" : [ {
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeAndExpandObj",
"genericVars" : [ {
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"paramNames" : [ "other", "merger" ]
}
}, {
"type" : "Method",
"name" : "mergeJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "mergeJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "json" ]
}
}, {
"type" : "Method",
"name" : "mergeChildren",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Merge the obj references within the current obj\n@param deep\n       If set, traverses the reference fields within the obj as well for a deep merge\n@param objKey\n       lambda specifying how to obtain the key for the Obj while determining which Objs to merge\n@param filter\n       Field paths that need to be filtered from this merge\n@return Obj with child references merged",
"name" : "mergeChildren",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "objKey",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "child",
"valueType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "filter",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeChildren",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "objKey",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "child",
"valueType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "filter",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "deep", "objKey", "filter" ]
}
}, {
"type" : "Method",
"name" : "sumObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds the numeric Obj fields with the other Objs respective fields.\nIf deep is set it will traverse reference and collection fields and sum corresponding numeric fields in\nreferences with same name and collection elements at same index or key.",
"name" : "sumObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "sumObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "other", "deep" ]
}
}, {
"type" : "Method",
"name" : "singletonArray",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Build an array of the correct type with a single element which is this instance.\n\n@return new array instance with this as only element.",
"name" : "singletonArray",
"returnType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"name" : "singletonArray",
"returnType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
}
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "array",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an array of instances of this type.",
"name" : "array",
"params" : [ {
"name" : "elements",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "array",
"params" : [ {
"name" : "elements",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
}
},
"paramNames" : [ "elements" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "arrayBuilder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "ArrayBuilder<mixing TypeMeta>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an array of instances of this type.",
"name" : "arrayBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "ArrayBuilder<mixing TypeMeta>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "arrayBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "ArrayBuilder<mixing TypeMeta>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "singletonSet",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "SetType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Build an set of the correct type with a single element which is this instance.\n\n@return new array instance with this as only element.",
"name" : "singletonSet",
"returnType" : {
"type" : "SetType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"name" : "singletonSet",
"returnType" : {
"type" : "SetType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
}
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "setBuilder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<mixing TypeMeta>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates a set of instances of this type.",
"name" : "setBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<mixing TypeMeta>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "setBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<mixing TypeMeta>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapBuilder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<string, mixing TypeMeta>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Create a map of string to elements of this type.",
"name" : "mapBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<string, mixing TypeMeta>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<string, mixing TypeMeta>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapBuilderOf",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<any, mixing TypeMeta>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Create a map with the given key type and elements of this type.",
"name" : "mapBuilderOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<any, mixing TypeMeta>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapBuilderOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<any, mixing TypeMeta>",
"hadDeclaredVarBindings" : true
},
"paramNames" : [ "keyType" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "myReferenceType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myReferenceType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myReferenceType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
}
}
}, {
"type" : "Method",
"name" : "myMapTypeOf",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myMapTypeOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myMapTypeOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"paramNames" : [ "keyType" ]
}
}, {
"type" : "Method",
"name" : "myMapType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myMapType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myMapType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
}
}
}, {
"type" : "Method",
"name" : "myArrayType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myArrayType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myArrayType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
}
}
}, {
"type" : "Method",
"name" : "mySetType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "mySetType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mySetType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
}
}
}, {
"type" : "Method",
"name" : "myStreamType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myStreamType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myStreamType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
}
}
}, {
"type" : "Method",
"name" : "toBuilder",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing TypeMeta>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return new ObjBuilder with initial state set to fields of this instance.",
"name" : "toBuilder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing TypeMeta>",
"hadDeclaredVarBindings" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toBuilder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing TypeMeta>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "builder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing TypeMeta>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return new ObjBuilder of this instance.",
"name" : "builder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing TypeMeta>",
"hadDeclaredVarBindings" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "builder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing TypeMeta>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fromFields",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type from provided fields\n@param fields\n           Fields to construct the instance of the obj with\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0) populated\n\n@see withDefaults",
"name" : "fromFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "fields", "withDefaults" ]
}
}, {
"type" : "Method",
"name" : "make",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj", "StringSerializable" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type with no non-default field values unless explicitly specified by passing param true\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0)\n           populated\n\n@see withDefaults",
"name" : "make",
"params" : [ {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Construct an instance from provided fields\n@param fields\n           Fields (in the format <field_name, value>) to construct an instance of the obj. Note that \"type\" as a\n           field_name will be considered as the actual Obj's type, e.g. Obj.make({\"type\": \"Panda\"}) is equivalent\n           to Panda.make()\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32\n           -> 0) populated. Passing an empty value for a field will result in the default field value being set if\n           the field does not {@link ValueModifier#PRESERVES_EMPTY preserve empty} and {@link FieldType#hasDefault\n           has a default value}.\n\n\n@see fromFields\n@see beforeMake\n@see afterMake\n@see withDefaults",
"name" : "make",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : " Construct an instance of this type from provided fields. Note it is more efficient to use #fromFields and other overloads\n\n ```js\n User.make({\n   email: 'joe@smith.com',\n   realName: 'Joe Smith'\n })\n\n Obj.make({\n   type: 'User',\n   email: 'joe@smith.com',\n   realName: 'Joe Smith'\n })\n ```\n\n ```py\n c3.User.make({\n   \"email\": 'joe@smith.com',\n   \"realName\": 'Joe Smith'\n })\n\n c3.Obj.make({\n   \"type\": 'User',\n   \"email\": 'joe@smith.com',\n   \"realName\": 'Joe Smith'\n })\n\n c3.User(email='joe@smith.com', realName='Joe Smith')\n\n c3.Obj(type='User', email='joe@smith.com', realName='Joe Smith')\n```\n\n Note that this is **not** the same as the [serialization format](serdeser.c3doc). This is a convenient way to\n specify fields and values in the \"JSON like\" form supported by each language, but the usual serialization rules,\n such as {@link Ann.Ser} do not apply.\n @param fields\n            Fields to construct the instance of the obj with\n @param withDefaults\n            If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0) populated\n\n @see fromFields\n @see beforeMake\n @see afterMake\n @see withDefaults",
"name" : "make",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 2
}, {
"type" : "MethodType",
"doc" : "Construct an instance of this type from the string. This is an alias for #fromString, as a specific overload\nwhen the argument is a known string.\n\n@see #fromString",
"name" : "make",
"params" : [ {
"name" : "s",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 3
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "make",
"params" : [ {
"name" : "withDefaultsOrFieldsOrFieldsOrS",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "withDefaultsOrFieldsOrFieldsOrS", "withDefaults" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "remake",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type from provided instance of a subtype or a \"duck type\".",
"name" : "remake",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "failIfExtraOrInvalidFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"final" : true,
"inline" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Construct an instance of TypeMeta from provided instance of a subtype or a \"duck type\".",
"name" : "remake",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "failIfExtraOrInvalidFields",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "pkg",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"final" : true,
"inline" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "remake",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "failIfExtraOrInvalidFields",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ]
}
}, {
"name" : "pkg",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "other", "failIfExtraOrInvalidFields", "pkg" ]
}
}, {
"type" : "Method",
"name" : "remakeAs",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an obj of the new type with all fields that exist on the original obj that are defined in the new type\nconverted and copied to the new obj instance. Note, that checking assignability and conversion of field values\ncould be costly if types have different value types for same fields.\n\n@param type\n        Type of new obj to return\n@return new obj of the requested type with all fields present in the original obj that are defined in the new type\n        converted and copied to it",
"name" : "remakeAs",
"genericVars" : [ {
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "remakeAs",
"genericVars" : [ {
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"paramNames" : [ "type" ]
}
}, {
"type" : "Method",
"name" : "beforeMake",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : true,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : false,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Optional override that will be called every time instance of this type is created.\n\n\nNote that it introduces additional overhead so should only be implemented for low volume data.",
"name" : "beforeMake",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"private" : true,
"optional" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "beforeMake",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "afterMake",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Optional override that will be called after every instance creation.\n\nNote that it introduces additional overhead so should only be implemented for low volume data.",
"name" : "afterMake",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"private" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "afterMake",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
}
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "cachedEmptyInst",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an empty inst using `MyType.make()` and caches it. Avoid recreating multiple copies of the spec for\nevery action dispatch. The cached inst can also be used for comparing whether the object is an empty or not\nWill only create empty instance for immutable Obj e.g. if an Obj is Mutable, this method will throw an error\n\n@see ValueType#defaultEmptyValue",
"name" : "cachedEmptyInst",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "cachedEmptyInst",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
}
}
}, {
"type" : "Method",
"name" : "toData",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Data"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Represent the current obj instance as {@link Data}",
"name" : "toData",
"returnType" : {
"type" : "ReferenceType",
"name" : "Data"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toData",
"returnType" : {
"type" : "ReferenceType",
"name" : "Data"
}
}
}, {
"type" : "Method",
"name" : "declaredSrcLine",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : true,
"isProperty" : true,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "Int32Type",
"name" : "int32"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : false,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Source line number in a C3 Type declaration [.c3typ] file starting with 1 where this metadata element is declared.",
"name" : "declaredSrcLine",
"returnType" : {
"type" : "Int32Type",
"name" : "int32"
},
"optional" : true,
"inline" : true,
"member" : true,
"property" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "declaredSrcLine",
"returnType" : {
"type" : "Int32Type",
"name" : "int32"
}
}
}, {
"type" : "Method",
"name" : "declaredSrcCharInLine",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : true,
"isProperty" : true,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "Int32Type",
"name" : "int32"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : false,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Source character position in a line in a C3 Type declaration [.c3typ] file starting with 1 where this metadata\nelement is declared.",
"name" : "declaredSrcCharInLine",
"returnType" : {
"type" : "Int32Type",
"name" : "int32"
},
"optional" : true,
"inline" : true,
"member" : true,
"property" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "declaredSrcCharInLine",
"returnType" : {
"type" : "Int32Type",
"name" : "int32"
}
}
}, {
"type" : "Method",
"name" : "pkgVersion",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Version of the #pkg when this type was built",
"name" : "pkgVersion",
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "pkgVersion",
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
}
}
}, {
"type" : "Method",
"name" : "typesys",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return package for built-in Type System; this could be different from #pkg() when package is loaded from a disk\n        for code gen",
"name" : "typesys",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg"
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "typesys",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg"
}
}
}, {
"type" : "Method",
"name" : "isGeneric",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return whether this type is parametric",
"name" : "isGeneric",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isGeneric",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isNarrowed",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether or not this type has a generic prototype from which it was narrowed i.e. if all its generic variables are\nbound. Note that when it has neither unbound nor bound variables it is neither generic nor narrowed.",
"name" : "isNarrowed",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isNarrowed",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isNarrowedToAny",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether or not all variables are bound to `any` or to the variable's restriction.\n\n@see #bindAll",
"name" : "isNarrowedToAny",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isNarrowedToAny",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "prototype",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Generic Type from which this type was bound / narrowed.\n\nFor example, `NormTimeseries<double>` type #prototype set to unbound `NormTimeseries`.\n\n@see #name\n@see #prototypeName",
"name" : "prototype",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "prototype",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
}
}
}, {
"type" : "Method",
"name" : "vars",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "VarReferenceType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "The list of unbound variables and any restrictions on them.",
"name" : "vars",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "VarReferenceType"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "vars",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "VarReferenceType"
}
}
}
}, {
"type" : "Method",
"name" : "varsByName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "VarReferenceType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "The map of unbound variables by name.",
"name" : "varsByName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "VarReferenceType"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "varsByName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "VarReferenceType"
}
}
}
}, {
"type" : "Method",
"name" : "var",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "VarReferenceType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get a single unbound variable reference by name.",
"name" : "var",
"params" : [ {
"name" : "var",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "VarReferenceType"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "var",
"params" : [ {
"name" : "var",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "VarReferenceType"
},
"paramNames" : [ "var", "failIfMissing" ]
}
}, {
"type" : "Method",
"name" : "varAt",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "VarReferenceType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get a single unbound variable reference at index.",
"name" : "varAt",
"params" : [ {
"name" : "var",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "VarReferenceType"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "varAt",
"params" : [ {
"name" : "var",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "VarReferenceType"
},
"paramNames" : [ "var", "failIfMissing" ]
}
}, {
"type" : "Method",
"name" : "varIndex",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get a single unbound variable index in the #vars array.",
"name" : "varIndex",
"params" : [ {
"name" : "var",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Get a single unbound variable index in the #vars array based on a var name for a given mixin.",
"name" : "varIndex",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "var",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
},
"inline" : true,
"member" : true,
"ordinal" : 1
}, {
"type" : "MethodType",
"name" : "varIndex",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "var",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
},
"inline" : true,
"member" : true,
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "varIndex",
"params" : [ {
"name" : "varOrMixinOrMixin",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ]
}
}, {
"name" : "failIfMissingOrVarOrVar",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ]
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
},
"paramNames" : [ "varOrMixinOrMixin", "failIfMissingOrVarOrVar", "failIfMissing" ]
}
}, {
"type" : "Method",
"name" : "isVar",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether or not the provided variable name is an unbound generic variable.",
"name" : "isVar",
"params" : [ {
"name" : "var",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isVar",
"params" : [ {
"name" : "var",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "var" ]
}
}, {
"type" : "Method",
"name" : "hasVarBinding",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return whether or not given generic variable has a binding.\n\n@see #bindVar",
"name" : "hasVarBinding",
"params" : [ {
"name" : "var",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasVarBinding",
"params" : [ {
"name" : "var",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "var" ]
}
}, {
"type" : "Method",
"name" : "hasVarBindings",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return whether or not any generic variables have bindings.\n\n@see #bindVar",
"name" : "hasVarBindings",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasVarBindings",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "varBinding",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "ValueType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get a single variable binding value. Note that the value may be null if unbound or may not be fully bound if\ngiven variable was bound to another generic variable.\n\n@param var name of the generic variable",
"name" : "varBinding",
"params" : [ {
"name" : "var",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfUnbound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "ValueType"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Get a single variable binding value at provided index in declared variables array. Note that the value may be null\nif unbound or if variable at index was bound to another generic variable.\n\n@param index of a generic variable",
"name" : "varBinding",
"params" : [ {
"name" : "indx",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
}, {
"name" : "failIfUnbound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "ValueType"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Get a single variable binding value for the specified type. The specified type may be the same type or a mixin.\nNote that the specified type is the one that declares the generic variable. The type on which the method is called\nmay be one that mixes in that type or a bound version of that type.\n\nFor example, on `Range<datetime>` both forms will return `datetime`:\n - `type.meta().varBinding(Range, \"V\")`\n - `type.meta().varBinding(\"V\")`\n\nHowever, {@link IntRange} has no generic binding itself, but binds its mixin {@link Range}:\n - `IntRange.meta().varBinding(\"V\")` returns null\n - `IntRange.meta().varBinding(Range, \"V\")` returns `int`\n\nThe combination of type and variable name is unique, even for a type that mixes in multiple generic types that\nuse the same variable name.\n\nType adds this overload to the base method in {@link Generic}.\n\n@param mixin the type to get the binding for\n@param var name of the variable on the specified type\n@param failIfUnbound if true, throw an error if the variable is not found or not fully bound",
"name" : "varBinding",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "var",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfUnbound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "ValueType"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 2
}, {
"type" : "MethodType",
"name" : "varBinding",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "var",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfUnbound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "ValueType"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 3
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "varBinding",
"params" : [ {
"name" : "varOrIndxOrMixinOrMixin",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
} ]
}
}, {
"name" : "failIfUnboundOrVarOrVar",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ]
}
}, {
"name" : "failIfUnbound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "ValueType"
},
"paramNames" : [ "varOrIndxOrMixinOrMixin", "failIfUnboundOrVarOrVar", "failIfUnbound" ]
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "bindVar",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Bind a single variable to the specified value type and return a new instance. The result may still be generic if\nthere are remaining unbound variables.",
"name" : "bindVar",
"params" : [ {
"name" : "var",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "binding",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Bind a first variable to the specified value type and return a new instance. The result may still be generic if\nthere are remaining unbound variables.",
"name" : "bindVar",
"params" : [ {
"name" : "binding",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 1
}, {
"type" : "MethodType",
"name" : "bindVar",
"params" : [ {
"name" : "serializedBinding",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "bindVar",
"params" : [ {
"name" : "varOrBindingOrSerializedBinding",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ]
}
}, {
"name" : "bindingOrBindings",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
}, {
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
}
} ]
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "varOrBindingOrSerializedBinding", "bindingOrBindings" ]
}
}, {
"type" : "Method",
"name" : "bindVars",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Bind all variables to the specified value types and return a new instance. Bindings are applied in the declaration\n/ mixin order",
"name" : "bindVars",
"params" : [ {
"name" : "bindings",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "bindVars",
"params" : [ {
"name" : "bindings",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "bindings" ]
}
}, {
"type" : "Method",
"name" : "bindAll",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Bind all variables to `any` or to variable restriction",
"name" : "bindAll",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "bindAll",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
}
}
}, {
"type" : "Method",
"name" : "prototypeNameWithBindings",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return prototype name with bindings",
"name" : "prototypeNameWithBindings",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "prototypeNameWithBindings",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "mergedAnnotationsJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "JsonType",
"name" : "json"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Override this method to return the merged set of annotations from itself and its hierarchy\nE.g.\n```type\n  @config(folder=\"x\")\n  type A {\n  }\n  @config(secret=true)\n  type B mixes A\n```\n=> return config(secret=true, folder=\"x\") for type B\nIf not overriden, by default this returns #annotationJson",
"name" : "mergedAnnotationsJson",
"returnType" : {
"type" : "JsonType",
"name" : "json"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergedAnnotationsJson",
"returnType" : {
"type" : "JsonType",
"name" : "json"
}
}
}, {
"type" : "Method",
"name" : "declaredAnnotations",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotations"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "The declared annotations for this metadata element.",
"name" : "declaredAnnotations",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotations"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "declaredAnnotations",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotations"
}
}
}, {
"type" : "Method",
"name" : "annotations",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotations"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "The annotations for this metadata element.",
"name" : "annotations",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotations"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "annotations",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotations"
}
}
}, {
"type" : "Method",
"name" : "hasAnnotations",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Annotatable" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Annotatable"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this metadata element has any annotation.",
"name" : "hasAnnotations",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasAnnotations",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
},
"$nearestImplementedOn" : "Annotatable"
}, {
"type" : "Method",
"name" : "hasAnnotation",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Annotatable" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Annotatable"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this metadata element has annotation with provided name.",
"name" : "hasAnnotation",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasAnnotation",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "ann" ]
},
"$nearestImplementedOn" : "Annotatable"
}, {
"type" : "Method",
"name" : "hasAnnotationValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Annotatable" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Annotatable"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this metadata element has annotation field value.",
"name" : "hasAnnotationValue",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "annField",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasAnnotationValue",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "annField",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "ann", "annField" ]
},
"$nearestImplementedOn" : "Annotatable"
}, {
"type" : "Method",
"name" : "annotation",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Annotation"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Annotatable" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Annotatable"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return annotation with provided name",
"name" : "annotation",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Annotation"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "annotation",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Annotation"
},
"paramNames" : [ "ann", "failIfMissing" ]
},
"$nearestImplementedOn" : "Annotatable"
}, {
"type" : "Method",
"name" : "annotationValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "AnyType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Annotatable" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Annotatable"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return annotation value for provided annotation name and annotation field",
"name" : "annotationValue",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "annField",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "AnyType"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "annotationValue",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "annField",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "AnyType"
},
"paramNames" : [ "ann", "annField" ]
},
"$nearestImplementedOn" : "Annotatable"
}, {
"type" : "Method",
"name" : "withAnnotation",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Add an annotation to the given metadata",
"name" : "withAnnotation",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotation"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Add an annotation to the given metadata\n@param ann\n        annotation to add\n@param annField\n        which field on the annotation needs to be set\n@param value\n        value for the field",
"name" : "withAnnotation",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "annField",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withAnnotation",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotation"
}
}, {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ]
}
}, {
"name" : "annField",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "ann", "annField", "value" ]
}
}, {
"type" : "Method",
"name" : "haveSameAnnotations",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether the specified instances have same annotations.",
"name" : "haveSameAnnotations",
"params" : [ {
"name" : "a1",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Annotatable"
}
}, {
"name" : "a2",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "haveSameAnnotations",
"params" : [ {
"name" : "a1",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Annotatable"
}
}, {
"name" : "a2",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "a1", "a2" ]
}
}, {
"type" : "Method",
"name" : "inheritableAnnotationsJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "JsonType",
"name" : "json"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return the JSON for annotations that can be inherited by children of this element of metadata. Annotations are\nnormally inherited, but ones marked with {@link Annotation#noInherit} will not be.",
"name" : "inheritableAnnotationsJson",
"returnType" : {
"type" : "JsonType",
"name" : "json"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "inheritableAnnotationsJson",
"returnType" : {
"type" : "JsonType",
"name" : "json"
}
}
}, {
"type" : "Method",
"name" : "renderer",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "HtmlRenderer"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Documentable" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Documentable"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return an instance of an {@link HtmlRenderer} set up to render this instance. If there is no capable renderer,\nnull may be returned. The implementation must be available within the browser (typically `js-client`).",
"name" : "renderer",
"returnType" : {
"type" : "ReferenceType",
"name" : "HtmlRenderer"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js-client" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "renderer",
"returnType" : {
"type" : "ReferenceType",
"name" : "HtmlRenderer"
}
},
"$nearestImplementedOn" : "Documentable"
}, {
"type" : "Method",
"name" : "docParsed",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"name" : "DocumentationParserSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Documentation"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Documentation parsing will produce a structured documentation object from the attributes of the metadata along\nwith the contents of the documentation comment. This can be examined and also rendered for display to the user\nusing {@link DocumentationRenderer}.\n\nIf this is not one of the known metadata types, nor has any documentation associated, the method returns null.\nOtherwise, it will build an object that contains as much as is possible to assemble about the piece of\nstructure, both from the metadata itself and from the text in #docText.\n\n@return parsed documentation object\n\n@see DocumentationParser",
"name" : "docParsed",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"name" : "DocumentationParserSpec"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Documentation"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "docParsed",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"name" : "DocumentationParserSpec"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Documentation"
},
"paramNames" : [ "spec" ]
}
}, {
"type" : "Method",
"name" : "docMarkdown",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Rendered markdown document for the Documentable instance.",
"name" : "docMarkdown",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "docMarkdown",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "docText",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Rendered plain text for the Documentable instance.",
"name" : "docText",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "docText",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "haveSameDoc",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether the specified instances have same documentation.",
"name" : "haveSameDoc",
"params" : [ {
"name" : "d1",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Documentable"
}
}, {
"name" : "d2",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "haveSameDoc",
"params" : [ {
"name" : "d1",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Documentable"
}
}, {
"name" : "d2",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "d1", "d2" ]
}
}, {
"type" : "Method",
"name" : "keyFieldType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return key field type.",
"name" : "keyFieldType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "keyFieldType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}
}, {
"type" : "Method",
"name" : "keyFieldValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return key field value.",
"name" : "keyFieldValue",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "keyFieldValue",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "singletonMap",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"modifier" : "NON_EMPTY",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "WithKey"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Build a map of the correct type with a single element which is this instance and key field value as key.",
"name" : "singletonMap",
"returnType" : {
"type" : "MapType",
"modifier" : "NON_EMPTY",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "WithKey"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "singletonMap",
"returnType" : {
"type" : "MapType",
"modifier" : "NON_EMPTY",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "WithKey"
}
}
}
}, {
"type" : "Method",
"name" : "cachedFingerprint",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "cachedFingerprint",
"returnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "cachedFingerprint",
"returnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
}
}
}, {
"type" : "Method",
"name" : "identifier",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return identifier that can safely be used in the code for provided language",
"name" : "identifier",
"params" : [ {
"name" : "lang",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "ImplLanguage"
}
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "identifier",
"params" : [ {
"name" : "lang",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "ImplLanguage"
}
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "lang" ]
}
}, {
"type" : "Method",
"name" : "toString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "TypeMeta.toString will build the DSL type declaration string.\n@see #fromString",
"name" : "toString",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toString",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "fromString",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "TypeMeta.fromString will build a type instance from a valid DSL declaration string.\n@see #toString",
"name" : "fromString",
"params" : [ {
"name" : "s",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromString",
"params" : [ {
"name" : "s",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta",
"mixing" : true
},
"paramNames" : [ "s" ]
}
}, {
"type" : "Method",
"name" : "cacheKey",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "The name of this instance.",
"name" : "cacheKey",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "cacheKey",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "isRemix",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return whether this TypeMeta has any #declaredRemixes",
"name" : "isRemix",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isRemix",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "forName",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get the type metadata for an instantiated type by name.",
"name" : "forName",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "forName",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"paramNames" : [ "name", "failIfMissing" ]
}
}, {
"type" : "Method",
"name" : "qname",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "TypeQName"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return the name of this type, qualified by its package. For example, the Facility type will have a name of\n`Facility` and a qname of `foundation.Facility`, which is the package that defines it.\n\n@see #name",
"name" : "qname",
"returnType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "TypeQName"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "qname",
"returnType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "TypeQName"
}
}
}
}, {
"type" : "Method",
"name" : "relativeMetadataPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "The path of folder where this type's declaration file is located:\nFormat: [gen|test]/src/<packageSubPath>/<name>\nE.g. for the given package folder structure\n myPkg\n  |\n  -  src\n      |\n      - folder1\n          |\n          - folder2\n              |\n              - SomeType1.c3typ\n      - SomeType3.c3typ\n  -  test\n      |\n       - src\n          |\n          - SomeType2.c3typ\n  -  gen\n      |\n       - src\n          |\n          - SomeType4.c3typ\n\nFor SomeType1.c3typ will return -> src/folder1/folder2/SomeType1\nFor SomeType3.c3typ will return -> src/SomeType3\nFor SomeType2.c3typ will return -> test/src/SomeType2\nFor SomeType4.c3typ will return -> gen/src/SomeType4\n\n@see metadataPath",
"name" : "relativeMetadataPath",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "relativeMetadataPath",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "relativeTypePath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Helper method for constructing relative type file path from pkg root.\n\n@see #relativeMetadataPath",
"name" : "relativeTypePath",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "relativeTypePath",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "innerTypeName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return the inner type name of this type, if it is indeed inner type otherwise `null`\n\n@see #name",
"name" : "innerTypeName",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "innerTypeName",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "isInnerType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this is an inner type",
"name" : "isInnerType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isInnerType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "nativeRemixName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return name of the native remix type declaration; includes declared action requirement",
"name" : "nativeRemixName",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "nativeRemixName",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "isNativeRemix",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether or not this is a native remix type. This means that its implementation is particular to a certain language,\nor even {@Link Action.Requirement}.\n\n```type\nnative py remix type DataFrame\n```\n\nThe native remix type native to the \"py\" {@Link Action.Requirement} and a remix of the \"DateFrame\" type.\n\n@see nativeActionRequirement",
"name" : "isNativeRemix",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isNativeRemix",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "hasNativeRemix",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this type or any of it's mixins has a native remix for a given {@Link Action.Requirement}\n\n@see isNativeRemix",
"name" : "hasNativeRemix",
"params" : [ {
"name" : "actionEngine",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasNativeRemix",
"params" : [ {
"name" : "actionEngine",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "actionEngine" ]
}
}, {
"type" : "Method",
"name" : "nativeActionRequirement",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "If this is a native remix type then {@Link Action.Requirement} that this type has specific implementation for.",
"name" : "nativeActionRequirement",
"returnType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "nativeActionRequirement",
"returnType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
}
}, {
"type" : "Method",
"name" : "isAbstract",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this is an abstract type that cannot be directly instantiated.",
"name" : "isAbstract",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isAbstract",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isInline",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this is an inline type i.e. one who's \"declared\" methods are implicitly inline.\n\n@see #declaredInline\n@see MethodType#isInline",
"name" : "isInline",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isInline",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isEntity",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type is an entity (aka persistable or stored) type by virtue of mixing {@link Persistable}).\nNote that will return `false` for {@link Persistable} type itself.",
"name" : "isEntity",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isEntity",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isDynamic",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this is an unnamed dynamic type created at runtime using #withFieldType or Pkg#dynamicType.",
"name" : "isDynamic",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isDynamic",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isExternal",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return True if the type is external (e.g. Mixes External).",
"name" : "isExternal",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isExternal",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isVersionable",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return True if the type is versionable (e.g. mixes Versionable).",
"name" : "isVersionable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isVersionable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isGeography",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return True if the type is a Geography (e.g. mixes Geo).",
"name" : "isGeography",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isGeography",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isGeometry",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return True if the type is a Geometry (e.g. mixes Geom).",
"name" : "isGeometry",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isGeometry",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isNoSystemCols",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return True if type mixes NoSystemCols",
"name" : "isNoSystemCols",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isNoSystemCols",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isPersistable",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type is potentially an entity, or is the {@link Persistable} type itself. This is an alias for\n`isA(Persistable)`.\n\nNote that Persistable itself isPersistable, so often #isEntity is more useful.\n\n@see isEntity",
"name" : "isPersistable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isPersistable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isPersistableUpsertHelper",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "isPersistableUpsertHelper",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isPersistableUpsertHelper",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isInvalidationDisabled",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "isInvalidationDisabled",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isInvalidationDisabled",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isPersistKey",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type is only persists its key (e.g. Persistable, Identified, Named).\n\n@param includePersistable\n       if true, then types mixing {@link Persistable} will return false.  Otherwise they will return true.\n\n@return true if this type only persists its key.",
"name" : "isPersistKey",
"params" : [ {
"name" : "dontIncludePersistable",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isPersistKey",
"params" : [ {
"name" : "dontIncludePersistable",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "dontIncludePersistable" ]
}
}, {
"type" : "Method",
"name" : "persistKeyField",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return if {@link isPersistKey} returns true, the key field to be persisted (e.g. \"name\" or \"id\").",
"name" : "persistKeyField",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "persistKeyField",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "isNotPersistable",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type can *not* be persisted. I.e. it is not an entity type or is abstract.\n\n@see #isEntity\n@see #isPersistable",
"name" : "isNotPersistable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isNotPersistable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isDatastoreKv",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if type has {@link Ann.Db} with any key value datastore (i.e. mixes KvStore or default \"kv\" store)",
"name" : "isDatastoreKv",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isDatastoreKv",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "canPersistKvRaw",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if the type is in the KV datastore and persistence can be optimized persisting the input raw values\n        (e.g no boxing of primitive values for fields with the \"any\" value type.",
"name" : "canPersistKvRaw",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "canPersistKvRaw",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isAnnotation",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type is an annotation type, marked with the `@annotation` annotation.",
"name" : "isAnnotation",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isAnnotation",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isEnum",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type is a declared enum.\n\n@see Enum",
"name" : "isEnum",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isEnum",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isUnion",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type is a declared anyof (union).\n\n@see Union",
"name" : "isUnion",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isUnion",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link Obj}",
"name" : "isObj",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isObj",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isPartitionable",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link Partitionable}",
"name" : "isPartitionable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isPartitionable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isDimensionBase",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link DimensionBase}",
"name" : "isDimensionBase",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isDimensionBase",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "pgPartition",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "PgPartitionDef"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return the {@link PgPartitionDef} for the type if it is defined and valid.",
"name" : "pgPartition",
"returnType" : {
"type" : "ReferenceType",
"name" : "PgPartitionDef"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "pgPartition",
"returnType" : {
"type" : "ReferenceType",
"name" : "PgPartitionDef"
}
}
}, {
"type" : "Method",
"name" : "hasTsFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 type contains fields that have ValueType of {@link Timeseries}",
"name" : "hasTsFields",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasTsFields",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link Value} but not {@link Obj}",
"name" : "isValue",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isValue",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isTypesys",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a used to declare C3 Type Systems",
"name" : "isTypesys",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isTypesys",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isMutable",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link Mutable}",
"name" : "isMutable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isMutable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isStateful",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link Stateful}",
"name" : "isStateful",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isStateful",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isStringSerializable",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link StringSerializable}",
"name" : "isStringSerializable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isStringSerializable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isSerializable",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link Serializable}",
"name" : "isSerializable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isSerializable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isWithType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link WithType}",
"name" : "isWithType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isWithType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isWithKey",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link WithKey}",
"name" : "isWithKey",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isWithKey",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isWithId",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link WithId}",
"name" : "isWithId",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isWithId",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isWithName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link WithName}",
"name" : "isWithName",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isWithName",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isWithUniqueId",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link WithUniqueId}",
"name" : "isWithUniqueId",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isWithUniqueId",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isWithUniqueName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link WithUniqueName}",
"name" : "isWithUniqueName",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isWithUniqueName",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isIdentifiable",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link Identifiable}",
"name" : "isIdentifiable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isIdentifiable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isIdentified",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link Identified}",
"name" : "isIdentified",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isIdentified",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isNameable",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link Nameable}",
"name" : "isNameable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isNameable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isNamed",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link Named}",
"name" : "isNamed",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isNamed",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isAnonymous",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is anonymous i.e it doesn't have a name",
"name" : "isAnonymous",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isAnonymous",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isDataPoint",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type represents \"fast data\".\n\n@see DataPoint",
"name" : "isDataPoint",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isDataPoint",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isSpec",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type is a parameter specification for a function. Note that spec parameters get auto initialized when\npassed as arguments to a function / API call.\n\n@see Spec",
"name" : "isSpec",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isSpec",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isResult",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type represents result of the function call. Note that result types get automatically validated after\nreturn from a method or API call.\n\n@see Result",
"name" : "isResult",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isResult",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isSingleton",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link Singleton}",
"name" : "isSingleton",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isSingleton",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isReClaim",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link ReClaim}",
"name" : "isReClaim",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isReClaim",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isDefaultInstance",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link DefaultInstance}",
"name" : "isDefaultInstance",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isDefaultInstance",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isDefaultClaim",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link DefaultClaim}",
"name" : "isDefaultClaim",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isDefaultClaim",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isCached",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link Cached}",
"name" : "isCached",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isCached",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isConfig",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link Config}",
"name" : "isConfig",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isConfig",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isPrivate",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type is marked as a private type (not to be used outside its package).",
"name" : "isPrivate",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isPrivate",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isMetadata",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link Metadata}",
"name" : "isMetadata",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isMetadata",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isSeedData",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link SeedData}",
"name" : "isSeedData",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isSeedData",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isByteStream",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link ByteStream}",
"name" : "isByteStream",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isByteStream",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isMetadataTransformer",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link MetadataTransformer}",
"name" : "isMetadataTransformer",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isMetadataTransformer",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isSource",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link Source}",
"name" : "isSource",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isSource",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isTimedDataHeader",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link TimedDataHeader}",
"name" : "isTimedDataHeader",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isTimedDataHeader",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isIntervalDataHeader",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link IntervalDataHeader}",
"name" : "isIntervalDataHeader",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isIntervalDataHeader",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isTimedValueType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if the type supports timed fetch",
"name" : "isTimedValueType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isTimedValueType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isTimedIntervalType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if the type is a timed interval type",
"name" : "isTimedIntervalType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isTimedIntervalType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isTimeseries",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if the type is a Timeseries type",
"name" : "isTimeseries",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isTimeseries",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isTimedRelationType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if the type is a {@link TimedRelation} or {@link TimedRelationRef} or {@link TimedIntervalRelation}\nor {@link TimedIntervalRelationRef}",
"name" : "isTimedRelationType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isTimedRelationType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isTimedValueHistory",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if the type is a timed value history type",
"name" : "isTimedValueHistory",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isTimedValueHistory",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isTimedRelation",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if the type is a {@link TimedRelation} type",
"name" : "isTimedRelation",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isTimedRelation",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isTimedCharacteristicType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if the type is a timed characteristic type",
"name" : "isTimedCharacteristicType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isTimedCharacteristicType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isTimedIntervalCharacteristicHistory",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if the type is a timed interval characteristic history type",
"name" : "isTimedIntervalCharacteristicHistory",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isTimedIntervalCharacteristicHistory",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isTimedFetchType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if the type supports timed fetch",
"name" : "isTimedFetchType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isTimedFetchType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isIntervalDataPoint",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link IntervalDataPoint}",
"name" : "isIntervalDataPoint",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isIntervalDataPoint",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isTimedDataPoint",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link TimedDataPoint}",
"name" : "isTimedDataPoint",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isTimedDataPoint",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isTimeseriesDataPoints",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link TimeseriesDataPoints}",
"name" : "isTimeseriesDataPoints",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isTimeseriesDataPoints",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isAnyTimeseriesDataPoint",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is sub type of either {@link IntervalDataPoint}, {@link TimedDataPoint} or\n{@link TimeseriesDataPoints}",
"name" : "isAnyTimeseriesDataPoint",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isAnyTimeseriesDataPoint",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isAclEnabled",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link AclEnabled}",
"name" : "isAclEnabled",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isAclEnabled",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isAclEnabledTypes",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link AclEnabledTypes}",
"name" : "isAclEnabledTypes",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isAclEnabledTypes",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isJdbcStore",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 type is a subtype of {@link JdbcStore}",
"name" : "isJdbcStore",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isJdbcStore",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isDataImpl",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link DataImpl}",
"name" : "isDataImpl",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isDataImpl",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isArray",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link Array}",
"name" : "isArray",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isArray",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isMap",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link Map}",
"name" : "isMap",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isMap",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isLambda",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 Type is a subtype of {@link Lambda}",
"name" : "isLambda",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isLambda",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isColumnar",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if this C3 type is a subtype of {@link Columnar}",
"name" : "isColumnar",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isColumnar",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isA",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Determine whether this type mixes in (directly or indirectly) another type\nor is that type itself.\n\n@param other instance of other type\n\n@see #isSame\n@see #isCoercible",
"name" : "isA",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Determine whether this type mixes in (directly or indirectly) another type\nor is that type itself.\n\n@param other instance of other type\n\n@see #isSame\n@see #isCoercible",
"name" : "isA",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "TypeMeta"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Determine whether this type mixes in (directly or indirectly) another type or is that type itself.\n\n@param other name of the other type\n\n@see #isSame\n@see #isCoercible",
"name" : "isA",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isA",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Type"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "TypeMeta"
}
} ]
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "other" ]
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "isBoxedType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type is a boxed type.",
"name" : "isBoxedType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isBoxedType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isBoxedPrimitiveType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type is a boxed primitive type (Integer, String, ...).",
"name" : "isBoxedPrimitiveType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isBoxedPrimitiveType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isBoxedArrayType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type is a boxed array type.",
"name" : "isBoxedArrayType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isBoxedArrayType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isBoxedMapType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type is a boxed map type.",
"name" : "isBoxedMapType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isBoxedMapType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isBoxedSetType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type is a boxed set type.",
"name" : "isBoxedSetType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isBoxedSetType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isBoxedCollectionType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type is a boxed collection type.",
"name" : "isBoxedCollectionType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isBoxedCollectionType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "unboxType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "ValueType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Unboxes this boxed primitive type, returning the underlying value type.",
"name" : "unboxType",
"params" : [ {
"name" : "failIfNot",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "ValueType"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "unboxType",
"params" : [ {
"name" : "failIfNot",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "ValueType"
},
"paramNames" : [ "failIfNot" ]
}
}, {
"type" : "Method",
"name" : "unboxPrimitiveType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "PrimitiveType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Unboxes this boxed primitive type, returning the underlying primitive type.",
"name" : "unboxPrimitiveType",
"params" : [ {
"name" : "failIfNot",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "PrimitiveType"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "unboxPrimitiveType",
"params" : [ {
"name" : "failIfNot",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "PrimitiveType"
},
"paramNames" : [ "failIfNot" ]
}
}, {
"type" : "Method",
"name" : "unboxArrayType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "ArrayType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Unboxes this boxed array type.",
"name" : "unboxArrayType",
"returnType" : {
"type" : "ReferenceType",
"name" : "ArrayType"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "unboxArrayType",
"returnType" : {
"type" : "ReferenceType",
"name" : "ArrayType"
}
}
}, {
"type" : "Method",
"name" : "unboxMapType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "MapType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Unboxes this boxed map type.",
"name" : "unboxMapType",
"returnType" : {
"type" : "ReferenceType",
"name" : "MapType"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "unboxMapType",
"returnType" : {
"type" : "ReferenceType",
"name" : "MapType"
}
}
}, {
"type" : "Method",
"name" : "commonFieldNames",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns the number of field names shared between ths and other.",
"name" : "commonFieldNames",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
}
} ],
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "commonFieldNames",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
}
} ],
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"paramNames" : [ "other" ]
}
}, {
"type" : "Method",
"name" : "merge",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns a new TypeMeta with all declaredFieldTypes from ths plus any declaredFieldTypes from other that were not\nalready on ths. If both TypeMetas have a field with the same name and different type, the type from ths will be\npreserved.",
"name" : "merge",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "merge",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"paramNames" : [ "other" ]
}
}, {
"type" : "Method",
"name" : "opBinaryReturnType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "ValueType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns ValueType that is to be returned based on BinaryOp between this and given ValueType.\n\n@param opAndValueTypeKey\n         input expected is binaryOp + \":\" + otherValueType.cacheKey()",
"name" : "opBinaryReturnType",
"params" : [ {
"name" : "opAndValueTypeKey",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "ValueType"
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "opBinaryReturnType",
"params" : [ {
"name" : "opAndValueTypeKey",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "ValueType"
},
"paramNames" : [ "opAndValueTypeKey" ]
}
}, {
"type" : "Method",
"name" : "opAggReturnType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "ValueType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns ValueType that is to be returned based on AggOp on this.\n\n@param op\n         aggregation  operator.",
"name" : "opAggReturnType",
"params" : [ {
"name" : "op",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"enumRefType" : {
"name" : "AggOp"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "ValueType"
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "opAggReturnType",
"params" : [ {
"name" : "op",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"enumRefType" : {
"name" : "AggOp"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "ValueType"
},
"paramNames" : [ "op" ]
}
}, {
"type" : "Method",
"name" : "opIsMissingReturnType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "ValueType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns ValueType that is to be returned based on `isMissing` call on this.",
"name" : "opIsMissingReturnType",
"returnType" : {
"type" : "ReferenceType",
"name" : "ValueType"
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "opIsMissingReturnType",
"returnType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
}
}, {
"type" : "Method",
"name" : "prototypeName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return the name of the type from which this type was bound. This is generally the same as the name, but in the case\nof bound types #prototypeName does not including the bindings.\n\nFor example, `NormTimeseries<double>` would have a prototypeName of `NormTimeseries`.\n\n@see #name\n@see #prototype",
"name" : "prototypeName",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "prototypeName",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "innerTypeNames",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "SetType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return names of all inner types defined by this type or on all of its inner types if `deep` arg is true",
"name" : "innerTypeNames",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "SetType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "innerTypeNames",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "SetType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"paramNames" : [ "deep" ]
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "innerTypes",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return all inner types defined by this type",
"name" : "innerTypes",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "innerTypes",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"paramNames" : [ "deep" ]
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "innerType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return inner type meta defined by this type by name",
"name" : "innerType",
"params" : [ {
"name" : "innerType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "innerType",
"params" : [ {
"name" : "innerType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"paramNames" : [ "innerType", "failIfMissing" ]
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "innerTypeToType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return inner type (not meta) defined by this type by name",
"name" : "innerTypeToType",
"params" : [ {
"name" : "innerType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "innerTypeToType",
"params" : [ {
"name" : "innerType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"paramNames" : [ "innerType", "failIfMissing" ]
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "outerTypeName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return name of the immediate outer type if this is an inner type",
"name" : "outerTypeName",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "outerTypeName",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "outerType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return immediate outer type if this is an inner type",
"name" : "outerType",
"returnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "outerType",
"returnType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "outerRootTypeName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return name of the root outer type if this is an inner type",
"name" : "outerRootTypeName",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "outerRootTypeName",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "outerRootTypePkgSubPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return metadata sub path of the root outer type if this is an inner type",
"name" : "outerRootTypePkgSubPath",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "outerRootTypePkgSubPath",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "outerRootType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return root outer type if this is an inner type",
"name" : "outerRootType",
"returnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "outerRootType",
"returnType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "isExtendable",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type can be extended by another type.",
"name" : "isExtendable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isExtendable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isNotExtendable",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type can no longer be extended by another type.",
"name" : "isNotExtendable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isNotExtendable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isExtension",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type is an extending another type.",
"name" : "isExtension",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isExtension",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "baseType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get the base type if this type is an extended type (e.g. it `extends` another type) or null if it isn't an\nextension type.\n\n@param failIfMissing\n          if true, throw an exception if the type is not an extension type\n\n@see #isExtension\n@see #rootType",
"name" : "baseType",
"params" : [ {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "baseType",
"params" : [ {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"paramNames" : [ "failIfMissing" ]
}
}, {
"type" : "Method",
"name" : "baseTypeMeta",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : true,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "baseTypeMeta",
"params" : [ {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "baseTypeMeta",
"params" : [ {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"paramNames" : [ "failIfMissing" ]
}
}, {
"type" : "Method",
"name" : "rootType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get the root type if this type is an extended type (e.g. it `extends` another type) or the type itself if it isn't\nan extension type.\n\n@see #isExtension\n@see #baseType",
"name" : "rootType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "rootType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}
}, {
"type" : "Method",
"name" : "typeIdent",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Gets the value of the typeKey appended to the type's base type's extensionIdent + \":\". This value is used to\nmark/identify object instances into one specific type.",
"name" : "typeIdent",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "typeIdent",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "isNotMixable",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type can no longer be mixed in by another package.",
"name" : "isNotMixable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isNotMixable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "mixins",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get the mixins of this type and types they mixin in turn.\n\n@see #declaredMixinReferenceTypes\n@see #declaredMixinReferenceType\n@see #declaredMixinTypes\n@see #declaredMixinType\n@see #implicitAndDeclaredMixinTypes\n@see #implicitAndDeclaredMixinType",
"name" : "mixins",
"params" : [ {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "'MIXIN'"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mixins",
"params" : [ {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "'MIXIN'"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"paramNames" : [ "order" ]
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "mixinMetas",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "mixinMetas",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mixinMetas",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
}
}
}, {
"type" : "Method",
"name" : "protoFilteredMixinMetas",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns the {@link #mixinMetas} based on the provided prototypeNames. If multiple metas with the same\nprototypeName are found, then the first encountered meta is selected. e.g For types defined below:\n```c3typ\nFoo<T> mixes Value\n```\n```c3typ\nBar mixes Foo<Bar>, Value\n```\n```c3typ\nBaz mixes Foo<Baz>, Bar, Value\n```\nFollowing would be the expected behavior:\n```js\nvar prototypeNames = SetType.ofStr().makeBuilder().addAll('Foo', 'Value');\n// Note that only the first encountered `Foo` mixin was returned.\nBaz.meta().protoFilteredMixinMetas(prototypeNames).mapToStr(a => a.name) == ['Foo<Baz>`, `Value`]\n\nprototypeNames = SetType.ofStr().makeBuilder().addAll('Bar');\n Baz.meta().protoFilteredMixinMetas(prototypeNames).mapToStr(a => a.name) == ['Bar`]\n```\n@see #uniqueProtoMixinMetas\n@see #mixinMetas",
"name" : "protoFilteredMixinMetas",
"params" : [ {
"name" : "prototypeNames",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetBuilder<string>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "protoFilteredMixinMetas",
"params" : [ {
"name" : "prototypeNames",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetBuilder<string>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"paramNames" : [ "prototypeNames" ]
}
}, {
"type" : "Method",
"name" : "uniqueProtoMixinMetas",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns the {@link #mixinMetas} based on the unique prototypeNames of the provided type.\nIf multiple metas with the same protoTypeName are found, then the first encountered meta is selected.\ne.g For types defined below:\n```c3typ\nFoo<T> mixes Value\n```\n```c3typ\nBar mixes Foo<Bar>, Value\n```\n```c3typ\nBaz mixes Foo<Baz>, Bar, Value\n```\nFollowing would be the expected behavior:\n```js\nBaz.meta().uniqueProtoMixinMetas().mapToStr(a => a.name) == ['Foo<Baz>`, `Bar`, `Value`]\n```\n@see #protoFilteredMixinMetas\n@see #mixinMetas",
"name" : "uniqueProtoMixinMetas",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "uniqueProtoMixinMetas",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
}
}
}, {
"type" : "Method",
"name" : "mixin",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : true,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get a single mixin by name.\n\n@param name type name to search for",
"name" : "mixin",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"cached" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mixin",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"paramNames" : [ "name", "failIfMissing" ]
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "mixinMeta",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : true,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "mixinMeta",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mixinMeta",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"paramNames" : [ "name", "failIfMissing" ]
}
}, {
"type" : "Method",
"name" : "mixinReferenceTypes",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "ReferenceType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get the mixin reference types of this type and types they mixin in turn.\n\n@see #declaredMixinRefTypes\n@see #declaredMixinRefType\n@see #declaredMixinTypes\n@see #declaredMixinType\n@see #mixins\n@see #mixin",
"name" : "mixinReferenceTypes",
"params" : [ {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "MIXIN"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "ReferenceType"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mixinReferenceTypes",
"params" : [ {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "MIXIN"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "ReferenceType"
}
},
"paramNames" : [ "order" ]
}
}, {
"type" : "Method",
"name" : "mixinReferenceType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : true,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "ReferenceType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get a single declared mixin reference type by name.\n\n@param name type name to search for",
"name" : "mixinReferenceType",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "ReferenceType"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mixinReferenceType",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "ReferenceType"
},
"paramNames" : [ "name", "failIfMissing" ]
}
}, {
"type" : "Method",
"name" : "mixinsWithSourceCode",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get the mixins that have source code implemented for the specified {@Link Action.Requirement} and\nall other {@Link Action.Requirement action requirements} whose {@link Action.Requirement#meetsRequirement requirements are met} by the provided action requirement.\n\n@param actionRequirement to check\n\n@see #hasSourceCode",
"name" : "mixinsWithSourceCode",
"params" : [ {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mixinsWithSourceCode",
"params" : [ {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"paramNames" : [ "actionRequirement" ]
}
}, {
"type" : "Method",
"name" : "declaredMixins",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get the declared mixins of this type.\n\n@see #mixins",
"name" : "declaredMixins",
"params" : [ {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "MIXIN"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "declaredMixins",
"params" : [ {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "MIXIN"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"paramNames" : [ "order" ]
}
}, {
"type" : "Method",
"name" : "declaredMixinMetas",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "declaredMixinMetas",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "declaredMixinMetas",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
}
}
}, {
"type" : "Method",
"name" : "declaredMixin",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get a single declared mixin by name.\n\n@param name type name to search for",
"name" : "declaredMixin",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "declaredMixin",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"paramNames" : [ "name" ]
}
}, {
"type" : "Method",
"name" : "declaredMixinMeta",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "declaredMixinMeta",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "declaredMixinMeta",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"paramNames" : [ "name" ]
}
}, {
"type" : "Method",
"name" : "implicitAndDeclaredMixinRefTypes",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "ReferenceType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get the declared and implicit mixins reference types for this type. Implicit mixin examples are `Persistable`\nfor entity types or `Enum` for enum types.\n\n@see #mixins",
"name" : "implicitAndDeclaredMixinRefTypes",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "ReferenceType"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "implicitAndDeclaredMixinRefTypes",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "ReferenceType"
}
}
}
}, {
"type" : "Method",
"name" : "implicitAndDeclaredMixins",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get the declared and implicit mixins of this type. Implicit mixin examples are `Persistable` for entity types or\n`Enum` for enum types.\n\n@see #mixins",
"name" : "implicitAndDeclaredMixins",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "implicitAndDeclaredMixins",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
}
}
}, {
"type" : "Method",
"name" : "implicitAndDeclaredMixinMetas",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "implicitAndDeclaredMixinMetas",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "implicitAndDeclaredMixinMetas",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
}
}
}, {
"type" : "Method",
"name" : "subTypes",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return all types in the current package mixing this type",
"name" : "subTypes",
"params" : [ {
"name" : "includeSelf",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "subTypes",
"params" : [ {
"name" : "includeSelf",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"paramNames" : [ "includeSelf" ]
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "subTypeMetas",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return all types in the current package mixing this type",
"name" : "subTypeMetas",
"params" : [ {
"name" : "includeSelf",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "subTypeMetas",
"params" : [ {
"name" : "includeSelf",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"paramNames" : [ "includeSelf" ]
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "subTypeNames",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return all type names in the current package mixing this type",
"name" : "subTypeNames",
"params" : [ {
"name" : "includeSelf",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "subTypeNames",
"params" : [ {
"name" : "includeSelf",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"paramNames" : [ "includeSelf" ]
}
}, {
"type" : "Method",
"name" : "extensionTypes",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return all types in the current package extending this type",
"name" : "extensionTypes",
"params" : [ {
"name" : "includeSelf",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "extensionTypes",
"params" : [ {
"name" : "includeSelf",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"paramNames" : [ "includeSelf" ]
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "extensionTypeMetas",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return all types in the current package extending this type",
"name" : "extensionTypeMetas",
"params" : [ {
"name" : "includeSelf",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "extensionTypeMetas",
"params" : [ {
"name" : "includeSelf",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"paramNames" : [ "includeSelf" ]
}
}, {
"type" : "Method",
"name" : "extensionTypeNames",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return all type names in the current package extending this type",
"name" : "extensionTypeNames",
"params" : [ {
"name" : "includeSelf",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "extensionTypeNames",
"params" : [ {
"name" : "includeSelf",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"paramNames" : [ "includeSelf" ]
}
}, {
"type" : "Method",
"name" : "unionAlts",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "AnyOfType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Alternatives for a Union type.\n\n@see Union",
"name" : "unionAlts",
"returnType" : {
"type" : "ReferenceType",
"name" : "AnyOfType"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "unionAlts",
"returnType" : {
"type" : "ReferenceType",
"name" : "AnyOfType"
}
}
}, {
"type" : "Method",
"name" : "isRemixed",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return `true` if this type is remixed",
"name" : "isRemixed",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isRemixed",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isNotRemixable",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type can no longer be remixed in by another package.",
"name" : "isNotRemixable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isNotRemixable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "remixAliases",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "SetType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return all remix aliases for this type.",
"name" : "remixAliases",
"returnType" : {
"type" : "SetType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "remixAliases",
"returnType" : {
"type" : "SetType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}
}, {
"type" : "Method",
"name" : "declaredNativeRemix",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return native remix declaration of this type for a provided {@Link Action.Requirement actionRequirement} and\nall other {@Link Action.Requirement action requirements} whose {@link Action.Requirement#meetsRequirement requirements are met} by the provided action requirement\nor null if this type does not have native remix",
"name" : "declaredNativeRemix",
"params" : [ {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "declaredNativeRemix",
"params" : [ {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"paramNames" : [ "actionRequirement" ]
}
}, {
"type" : "Method",
"name" : "nativeRemix",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return native remix of this type for a provided {@Link Action.Requirement actionRequirement} or null if this type does not have native remix nor does\n        any of its mixins",
"name" : "nativeRemix",
"params" : [ {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "nativeRemix",
"params" : [ {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"paramNames" : [ "actionRequirement" ]
}
}, {
"type" : "Method",
"name" : "allRemixPackages",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "SetType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return names of all depending packages that contain remix of this type.",
"name" : "allRemixPackages",
"returnType" : {
"type" : "SetType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "allRemixPackages",
"returnType" : {
"type" : "SetType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}
}, {
"type" : "Method",
"name" : "isFinal",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type can no longer be mixed in or remixed by another package.",
"name" : "isFinal",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isFinal",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "declaredFieldTypesByName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "DeclaredFieldType"
}
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get a map of declared or overridden field or method types by field / method name for this type. Note since there\ncould be more then one field declaration for a name resulting map element type is actually array of FieldTypes.\n\n@see declaredFieldTypes\n@see overriddenFieldTypes",
"name" : "declaredFieldTypesByName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "DeclaredFieldType"
}
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "declaredFieldTypesByName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "DeclaredFieldType"
}
}
}
}
}, {
"type" : "Method",
"name" : "declaredFieldType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : true,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "DeclaredFieldType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get a single declared or overridden field or method by name for this type. Note since there could be more then one\nfield declaration for the same name returns array of FieldTypes.",
"name" : "declaredFieldType",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "DeclaredFieldType"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "declaredFieldType",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "DeclaredFieldType"
}
},
"paramNames" : [ "fieldOrMethod", "failIfMissing" ]
}
}, {
"type" : "Method",
"name" : "declaresOrOverridesField",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return `true` if this type declares or overrides provided field.\n\n@see declaresField\n@see overridesField",
"name" : "declaresOrOverridesField",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "declaresOrOverridesField",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "fieldOrMethod" ]
}
}, {
"type" : "Method",
"name" : "declaresField",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return `true` if this type declares not just overrides provided field.\n\n@see overridesField",
"name" : "declaresField",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "declaresField",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "fieldOrMethod" ]
}
}, {
"type" : "Method",
"name" : "overridesField",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return `true` if this types overrides provided field or method. I.e. one of the mixins declare field or method\n        with the same name.\n\n@see declaresField",
"name" : "overridesField",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "overridesField",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "fieldOrMethod" ]
}
}, {
"type" : "Method",
"name" : "overriddenFieldTypes",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "DeclaredFieldType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get all overridden field or method types by field / method name for this type.",
"name" : "overriddenFieldTypes",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "DeclaredFieldType"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "overriddenFieldTypes",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "DeclaredFieldType"
}
}
}
}, {
"type" : "Method",
"name" : "overriddenFieldTypesByName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "DeclaredFieldType"
}
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get a map of overridden field or method types by field / method name for this type.",
"name" : "overriddenFieldTypesByName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "DeclaredFieldType"
}
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "overriddenFieldTypesByName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "DeclaredFieldType"
}
}
}
}
}, {
"type" : "Method",
"name" : "overriddenFieldType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : true,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "DeclaredFieldType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get a single overridden field or method by name for this type.",
"name" : "overriddenFieldType",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "DeclaredFieldType"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "overriddenFieldType",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "DeclaredFieldType"
}
},
"paramNames" : [ "fieldOrMethod", "failIfMissing" ]
}
}, {
"type" : "Method",
"name" : "fieldTypeFirstDeclaredOn",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get the type (this one or the mixin) on which the specified field was originally declared. If no such field is\ndeclared in the hierarchy, return null.\n\n```type\ntype X {\n  doit: optional member function()\n}\n\ntype Y mixes X {\n  doit: ~ js server\n}\n```\n\nIn the example above, calling from type *Y*, `fieldTypeDeclaredOn(\"doit\")` returns Y (since it is re-declared\nthere), but fieldTypeFirstDeclaredOn returns *X* (since that is the original declaration).\n\n@see fieldTypeDeclaredOn\n@see declaresField\n@see overridesField\n@see Method#overloadImplementedOn",
"name" : "fieldTypeFirstDeclaredOn",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldTypeFirstDeclaredOn",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"paramNames" : [ "fieldOrMethod", "failIfMissing" ]
}
}, {
"type" : "Method",
"name" : "fieldTypeFirstDeclaredOnMeta",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : true,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "fieldTypeFirstDeclaredOnMeta",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldTypeFirstDeclaredOnMeta",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"paramNames" : [ "fieldOrMethod", "failIfMissing" ]
}
}, {
"type" : "Method",
"name" : "fieldTypeDeclaredOn",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get the type (this one or the closest mixin) on which the specified field is declared. If no such field is\ndeclared in the hierarchy, return null. Note that this might be the original declaration of the field as a type\nmay override a field with additional information, such as providing a method implementation.\n\n@see fieldTypeFirstDeclaredOn\n@see Method#overloadImplementedOn",
"name" : "fieldTypeDeclaredOn",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldTypeDeclaredOn",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Type"
}
},
"paramNames" : [ "fieldOrMethod", "failIfMissing" ]
}
}, {
"type" : "Method",
"name" : "fieldTypeDeclaredOnMeta",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : true,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "fieldTypeDeclaredOnMeta",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldTypeDeclaredOnMeta",
"params" : [ {
"name" : "fieldOrMethod",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"paramNames" : [ "fieldOrMethod", "failIfMissing" ]
}
}, {
"type" : "Method",
"name" : "fieldTypeNames",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "SetType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get all field type names for this type. This includes fields defined on mixins as well as defined (or redefined\n/ overriden) on the type itself.",
"name" : "fieldTypeNames",
"params" : [ {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "MIXIN"
}
} ],
"returnType" : {
"type" : "SetType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldTypeNames",
"params" : [ {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "MIXIN"
}
} ],
"returnType" : {
"type" : "SetType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"paramNames" : [ "order" ]
}
}, {
"type" : "Method",
"name" : "fieldTypeAndMethodNames",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "SetType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get all method and field type names for this type. This includes methods and fields defined on mixins as well as\ndefined (or redefined / overriden) on the type itself.",
"name" : "fieldTypeAndMethodNames",
"params" : [ {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "MIXIN"
}
} ],
"returnType" : {
"type" : "SetType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldTypeAndMethodNames",
"params" : [ {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "MIXIN"
}
} ],
"returnType" : {
"type" : "SetType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"paramNames" : [ "order" ]
}
}, {
"type" : "Method",
"name" : "fieldTypes",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get all field types for this type. This includes fields defined on mixins as well as defined (or redefined) on the\ntype itself.",
"name" : "fieldTypes",
"params" : [ {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "MIXIN"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldTypes",
"params" : [ {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "MIXIN"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"paramNames" : [ "order" ]
}
}, {
"type" : "Method",
"name" : "fieldTypesWithAnn",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get all field types for this type with specified {@link Annotation}. This includes fields defined on mixins as\nwell as defined (or redefined) on the type itself.",
"name" : "fieldTypesWithAnn",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "MIXIN"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldTypesWithAnn",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "MIXIN"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"paramNames" : [ "ann", "order" ]
}
}, {
"type" : "Method",
"name" : "fieldPaths",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return list of all field paths on this type, including fields coming from mixins",
"name" : "fieldPaths",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldPaths",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}
}
}, {
"type" : "Method",
"name" : "fieldPathMergeSpecs",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Generate merge specs for each data field paths on this type",
"name" : "fieldPathMergeSpecs",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldPathMergeSpecs",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}
}, {
"type" : "Method",
"name" : "xmlTxtContentFieldType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get field type with XmlField-txtContent annotation",
"name" : "xmlTxtContentFieldType",
"returnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "xmlTxtContentFieldType",
"returnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
}, {
"type" : "Method",
"name" : "fieldTypesByName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get a map of field types by field name for this type. This includes fields defined on mixins as well as defined\n(or redefined) on the type itself.",
"name" : "fieldTypesByName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldTypesByName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "fieldType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : true,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get a single field type by name.\n\n@param field field name to find\n@param failIfMissing throw an error if the field doesn't exist",
"name" : "fieldType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"cached" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"paramNames" : [ "field", "failIfMissing" ]
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "fieldTypeAtOrdinal",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : true,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Looks up a field type by it's ordinal\n@param ordinal\n       of the field type\n@param failIfMissing\n       throw an error if the field doesn't exist",
"name" : "fieldTypeAtOrdinal",
"params" : [ {
"name" : "ordinal",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"cached" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldTypeAtOrdinal",
"params" : [ {
"name" : "ordinal",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"paramNames" : [ "ordinal", "failIfMissing" ]
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "fieldTypeBySerName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get a single field type by serialization name. If a field has an `@ser(name)` annotation (as many do on this type\nfor example), look up the field by that name before looking it up by the formal field name.\n\n@param serName serialized field name to find\n@param failIfMissing throw an error if the field doesn't exist",
"name" : "fieldTypeBySerName",
"params" : [ {
"name" : "serName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldTypeBySerName",
"params" : [ {
"name" : "serName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"paramNames" : [ "serName", "failIfMissing" ]
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "fieldTypesBySerName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get a map of all field types by serialization name. If a field has an `@ser(name)` annotation (as many do on this type\nfor example), look up the field by that name before looking it up by the formal field name.",
"name" : "fieldTypesBySerName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldTypesBySerName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "typeSerName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : true,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Name to be used in serialization for a `WithType#type`.\nBy default it is \"type\" but can be overridden via `@ser(name=\"...\")` on a `type` property\nReturns \"$type\" if another field overrides to the serialized name of `type`.",
"name" : "typeSerName",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"inline" : true,
"member" : true,
"property" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "typeSerName",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "fieldPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
} ]
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Traverses the field or field path",
"name" : "fieldPath",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfInvalid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Traverses the field by provided field type, returning the corresponding FieldPath",
"name" : "fieldPath",
"params" : [ {
"name" : "fieldType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldPath",
"params" : [ {
"name" : "fieldPathOrFieldType",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
} ]
}
}, {
"name" : "failIfInvalid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
} ]
},
"paramNames" : [ "fieldPathOrFieldType", "failIfInvalid" ]
}
}, {
"type" : "Method",
"name" : "dataFieldTypes",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "A list of data field types for this type; i.e. ones that are not methods, constants or inner types. Note that\nresulting array is ordered based on field type ordinal.",
"name" : "dataFieldTypes",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "dataFieldTypes",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "dataFieldTypeOrdinals",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "Int32Type",
"name" : "int32"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get all data field type ordinals.\n\n@see dataFieldTypes",
"name" : "dataFieldTypeOrdinals",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "Int32Type",
"name" : "int32"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "dataFieldTypeOrdinals",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "Int32Type",
"name" : "int32"
}
}
}
}, {
"type" : "Method",
"name" : "eachDataFieldPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Traverses all data fields including in references.",
"name" : "eachDataFieldPath",
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
} ]
}
} ],
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachDataFieldPath",
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
} ]
}
} ],
"paramNames" : [ "action" ]
}
}, {
"type" : "Method",
"name" : "dataFieldTypesByName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get a map of data field types by field name for this type.",
"name" : "dataFieldTypesByName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "dataFieldTypesByName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "dataFieldTypeNames",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get all of data field names for this type.",
"name" : "dataFieldTypeNames",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "dataFieldTypeNames",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}
}, {
"type" : "Method",
"name" : "dataFieldTypesWithDefault",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "A list of data field types for this type that have default values. It also contains a list of field types that are\nrequired primitives",
"name" : "dataFieldTypesWithDefault",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "dataFieldTypesWithDefault",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
}
}, {
"type" : "Method",
"name" : "dataFieldTypesWithValidation",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "A list of data field types for this type that require validation\n@see ValueType#hasValidation",
"name" : "dataFieldTypesWithValidation",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "dataFieldTypesWithValidation",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
}
}, {
"type" : "Method",
"name" : "dataFieldTypesWithSecretAnn",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get all field types for this type with specified {@link Ann.Config#secret}. This includes fields defined on mixins as\nwell as defined (or redefined) on the type itself.",
"name" : "dataFieldTypesWithSecretAnn",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "dataFieldTypesWithSecretAnn",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
}
}, {
"type" : "Method",
"name" : "dataFieldType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : true,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get a single data field type by name.",
"name" : "dataFieldType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"cached" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "dataFieldType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"paramNames" : [ "field", "failIfMissing" ]
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "dataFieldTypesFingerprint",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Produce a checksum that can easily be compared to determine if two fieldTypes are similar. We are excluding methods\nand constants",
"name" : "dataFieldTypesFingerprint",
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "dataFieldTypesFingerprint",
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
}
}
}, {
"type" : "Method",
"name" : "constant",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : true,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get a single constant by name.",
"name" : "constant",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"cached" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "constant",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"paramNames" : [ "field", "failIfMissing" ]
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "constants",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get all constants.",
"name" : "constants",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "constants",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "constantOrdinals",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "Int32Type",
"name" : "int32"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get all constant ordinals.",
"name" : "constantOrdinals",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "Int32Type",
"name" : "int32"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "constantOrdinals",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "Int32Type",
"name" : "int32"
}
}
}
}, {
"type" : "Method",
"name" : "innerTypeConstant",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get a {@link FieldType} describing an {@link #innerType}. This field {@link #isConstant is constant}, with its\n{@link #defaultValue} being the inner type.",
"name" : "innerTypeConstant",
"params" : [ {
"name" : "innerTypeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "innerTypeConstant",
"params" : [ {
"name" : "innerTypeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"paramNames" : [ "innerTypeName", "failIfMissing" ]
}
}, {
"type" : "Method",
"name" : "valueType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : true,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "ValueType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get the value type of a field by name.\n\n@param field field name to find\n@param failIfMissing throw an error if the field doesn't exist",
"name" : "valueType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "ValueType"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "valueType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "ValueType"
},
"paramNames" : [ "field", "failIfMissing" ]
}
}, {
"type" : "Method",
"name" : "traverseType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : true,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Traverses a reference type field or method return type, returning the Type on the other side of that ReferenceType.\nConvenient equivalent to:\n```fieldType(name).valueType().asReferenceType().dereference()```\nor\n```fieldType(name).valueType().asMethodType().returnType().asReferenceType().dereference()```\nor\n```fieldType(name).valueType().asCollectionType().elementType().asReferenceType().dereference()```\nor\n```fieldType(name).valueType().asMethodType().returnType().asCollectionType().elementType().asReferenceType().dereference()```",
"name" : "traverseType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "traverseType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"paramNames" : [ "field", "failIfMissing" ]
}
}, {
"type" : "Method",
"name" : "traverseTypeMeta",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : true,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Traverses a reference type field or method return type, returning the Type on the other side of that ReferenceType.\nConvenient equivalent to:\n```fieldType(name).valueType().asReferenceType().dereference()```\nor\n```fieldType(name).valueType().asMethodType().returnType().asReferenceType().dereference()```\nor\n```fieldType(name).valueType().asCollectionType().elementType().asReferenceType().dereference()```\nor\n```fieldType(name).valueType().asMethodType().returnType().asCollectionType().elementType().asReferenceType().dereference()```",
"name" : "traverseTypeMeta",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "traverseTypeMeta",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"paramNames" : [ "field", "failIfMissing" ]
}
}, {
"type" : "Method",
"name" : "traverseFieldPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Traverse the given field path.",
"name" : "traverseFieldPath",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "traverseFieldPath",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
},
"paramNames" : [ "fieldPath" ]
}
}, {
"type" : "Method",
"name" : "traverseSerField",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : true,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Traverses the ser field name as provided on the type, returning the corresponding FieldPath\n\n@see Ann.Ser\n@param serName\n       serialization name of the field\n@return the field path",
"name" : "traverseSerField",
"params" : [ {
"name" : "serName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "traverseSerField",
"params" : [ {
"name" : "serName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
},
"paramNames" : [ "serName", "failIfMissing" ]
}
}, {
"type" : "Method",
"name" : "serFieldTypes",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "serFieldTypes",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "serFieldTypes",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
}
}, {
"type" : "Method",
"name" : "serFieldType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : true,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return fieldType with the matching serialized name.\n\n@see #serFieldTypes\n@see Ann.Ser",
"name" : "serFieldType",
"params" : [ {
"name" : "serName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "serFieldType",
"params" : [ {
"name" : "serName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"paramNames" : [ "serName", "failIfMissing" ]
}
}, {
"type" : "Method",
"name" : "hasSerNameFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether or not there are any fields in this type whose serialization name differs from the normal field name.\n\n@see FieldType#serName",
"name" : "hasSerNameFields",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasSerNameFields",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "hasFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type has any data fields. Note it skips constants.",
"name" : "hasFields",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasFields",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "hasFieldDefaults",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type has any data field with defaults. Note it skips constants.",
"name" : "hasFieldDefaults",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasFieldDefaults",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "hasRequiredFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type has any required fields.",
"name" : "hasRequiredFields",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasRequiredFields",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "hasConstraints",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type has any constraints such as required fields or @constraint annotation.",
"name" : "hasConstraints",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasConstraints",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "canBePersisted",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return True if entity and not generic",
"name" : "canBePersisted",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "canBePersisted",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "hasPersistableId",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return True if the type has the field `id` and it's persistable.",
"name" : "hasPersistableId",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasPersistableId",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "hasPersistableName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return True if the type has the field `name` and it's persistable.",
"name" : "hasPersistableName",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasPersistableName",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "hasPersistableMeta",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return True if the type has the field `meta` and it's persistable.",
"name" : "hasPersistableMeta",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasPersistableMeta",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "hasPersistableTypeWithBindings",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return True if the type (or one of its base types) has generic bindings",
"name" : "hasPersistableTypeWithBindings",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasPersistableTypeWithBindings",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "hasConfigOverrideUser",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return True if the type has annotation @config(minOverride=\"USER\")",
"name" : "hasConfigOverrideUser",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasConfigOverrideUser",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "persistTypeWithBindings",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return True if instances of this type should persist the specific type bindings.  Note that for types that extend\nthis type and specify the bindings in the type definition will return false.",
"name" : "persistTypeWithBindings",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "persistTypeWithBindings",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "hasMethods",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type has any methods declared.",
"name" : "hasMethods",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasMethods",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "methods",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Method"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "A list of methods for this type.",
"name" : "methods",
"params" : [ {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "MIXIN"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Method"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "methods",
"params" : [ {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "MIXIN"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Method"
}
},
"paramNames" : [ "order" ]
}
}, {
"type" : "Method",
"name" : "methodsByName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "Method"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get a map of methods by name for this type.",
"name" : "methodsByName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "Method"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "methodsByName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "Method"
}
}
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "method",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : true,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Method"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get a single method by name.",
"name" : "method",
"params" : [ {
"name" : "method",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Method"
},
"cached" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "method",
"params" : [ {
"name" : "method",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Method"
},
"paramNames" : [ "method", "failIfMissing" ]
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "methodOverloadsWithAnn",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "MethodType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "A list of method for this type with specified {@link Annotation}.",
"name" : "methodOverloadsWithAnn",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "MIXIN"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "MethodType"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "methodOverloadsWithAnn",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "order",
"valueType" : {
"type" : "StringType",
"name" : "string",
"enumRefType" : {
"name" : "TypeOrder"
}
},
"default" : {
"type" : "Boxed<string>",
"value" : "MIXIN"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "MethodType"
}
},
"paramNames" : [ "ann", "order" ]
}
}, {
"type" : "Method",
"name" : "hasImplicitMethods",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type has any implicit methods (i.e. methods that are valid but not declared for the type) such as\n`with<field-name>`, `set<field-name>`, etc.\n\n@see #implicitMethods",
"name" : "hasImplicitMethods",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasImplicitMethods",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "implicitMethods",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Method"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get the implicit methods for this type such as `with<field-name>`, `set<field-name>` etc.\n\n@see #methods\n@see #implicitMethodsByName",
"name" : "implicitMethods",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Method"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "implicitMethods",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Method"
}
}
}
}, {
"type" : "Method",
"name" : "implicitMethodsByName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "Method"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get the implicit methods map by name for this type.\n\n@see #methods\n@see #implicitMethods",
"name" : "implicitMethodsByName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "Method"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "implicitMethodsByName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "Method"
}
}
}
}, {
"type" : "Method",
"name" : "declaredOrImplicitMethod",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Method"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get a single method by name, whether that method is declared or implicit.\n\n@see #methods\n@see #implicitMethods",
"name" : "declaredOrImplicitMethod",
"params" : [ {
"name" : "method",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Method"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "declaredOrImplicitMethod",
"params" : [ {
"name" : "method",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Method"
},
"paramNames" : [ "method" ]
}
}, {
"type" : "Method",
"name" : "memberMethodNames",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "SetType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get the names of all member methods for this type.",
"name" : "memberMethodNames",
"returnType" : {
"type" : "SetType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "memberMethodNames",
"returnType" : {
"type" : "SetType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}
}, {
"type" : "Method",
"name" : "hasMemberMethod",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type has a member method of the given name",
"name" : "hasMemberMethod",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasMemberMethod",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "name" ]
}
}, {
"type" : "Method",
"name" : "hasSourceCode",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type has source code for function implementations, not including types it mixes in. If an {@Link Action.Requirement} is\nspecified, source code for that {@Link Action.Requirement action requirement}  and all other {@Link Action.Requirement action requirements} whose {@link Action.Requirement#meetsRequirement requirements are met} by the provided action requirement.\nis checked. This does not include script files that are specific to an {@Link Action.Requirement}, only ones that provide the base implementation.\n\n@param actionRequirement The {@Link Action.Requirement} to check.",
"name" : "hasSourceCode",
"params" : [ {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasSourceCode",
"params" : [ {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "actionRequirement" ]
}
}, {
"type" : "Method",
"name" : "sourceCode",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "The combined source code for this type in the specified language. Use {@link #sourceCodeAndFilePaths} for the\nindividual code files.\n\n@param type\n        The Type whose source code will be returned\n@param actionRequirement\n        The {@Link Action.Requirement}  which we want to get source code for. If this action requirement\n        {@link Action.Requirement#meetsRequirementFor meets requirement for} another action requirement, that  source code for that action requirement\n        for the given Type is also included. This method only returns source code for script-based action requirement.\n\n@return Source code for a Type and its remixes. This includes source code from dependent packages. The resulting\n        code is ordered in proper execution order, which is ordered from lowest -> highest precedence. `Pkg`\n        ordering takes highest precedence when determining the order of source code in the resulting string; all\n        source code for the remix of a Type will come after all source code from the package which originally\n        declared the Type. {@link declaredRemixes} enumerates all packages for which the given Type was remixed,\n        in the order of highest -> lowest precedence. {@link package} is the package which originally declared\n        this Type; source code from this package will have the lowest precedence. See\n        {@link Pkg#typeSourceCodePaths} for documentation describing the order of source code files in the scenario\n        that more than one file in a `Pkg` implements methods for the given Type and action requirement.",
"name" : "sourceCode",
"params" : [ {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "sourceCode",
"params" : [ {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "actionRequirement" ]
}
}, {
"type" : "Method",
"name" : "sourceCodeAndFilePaths",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"keyType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Pkg.Path"
}
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "The individual source code files for this type in the specified language. Use {@link #sourceCode} for the merged\nsource code.\n\n@param type\n        The Type whose source code will be returned\n@param actionRequirement\n        The {@Link Action.Requirement} which we want to get source code for. If this action requirement\n        {@link Action.Requirement#meetsRequirementFor meets requirement for} another action requirement, the  source code for that action requirement\n        for the given Type is also included. This method only returns source code for script-based action requirement.\n\n@return A map from source code {@link Pkg.Path} (key) to source code (value) for all source code files for a\n        Type and its remixes. This includes source code from dependent packages. The resulting map is ordered in\n        proper execution order, which is ordered from lowest -> highest precedence. `Pkg` ordering takes highest\n        precedence when determining the order of source code in the resulting map; all source code for the remix of\n        a Type will come after all source code from the package which originally declared the Type.\n        {@link declaredRemixes} enumerates all packages for which the given Type was remixed, in the order of\n        highest -> lowest precedence. {@link package} is the package which originally declared this Type; source\n        code from this package will have the lowest precedence. See {@link Pkg#typeSourceCodePaths} for\n        documentation describing the order of source code files in the scenario that more than one file in a\n        `Pkg` implements methods for the given Type and actionEngine.",
"name" : "sourceCodeAndFilePaths",
"params" : [ {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "MapType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"keyType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Pkg.Path"
}
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "sourceCodeAndFilePaths",
"params" : [ {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "MapType",
"annotationsJson" : [ {
"indexed" : [ ]
} ],
"keyType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Pkg.Path"
}
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"paramNames" : [ "actionRequirement" ]
}
}, {
"type" : "Method",
"name" : "prototypeNameFromFileName",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return prototype name parsed from file name. E.g. \"Array.py-client.py\" -> \"Array\"",
"name" : "prototypeNameFromFileName",
"params" : [ {
"name" : "fileName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "prototypeNameFromFileName",
"params" : [ {
"name" : "fileName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "fileName" ]
}
}, {
"type" : "Method",
"name" : "actionRequirements",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this type has source code for function implementations, not including types it mixes in. If a language is\nspecified, only source code for that language is checked. This does not include script files that are specific to\nan {@Link Action.Requirement}, only ones that provide the base implementation.\n\n@param language The language to check.",
"name" : "actionRequirements",
"params" : [ {
"name" : "language",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "ImplLanguage"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "actionRequirements",
"params" : [ {
"name" : "language",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "ImplLanguage"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
},
"paramNames" : [ "language" ]
}
}, {
"type" : "Method",
"name" : "referenceType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Produce a reference type to this type.",
"name" : "referenceType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "referenceType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
}
}
}, {
"type" : "Method",
"name" : "arrayType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Produce an array type of elements of this type.",
"name" : "arrayType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "arrayType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
}
}
}, {
"type" : "Method",
"name" : "streamType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Produce a stream type of elements of this type.",
"name" : "streamType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "streamType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
}
}
}, {
"type" : "Method",
"name" : "setType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Produce a set type of elements of this type.",
"name" : "setType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "setType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
}
}
}, {
"type" : "Method",
"name" : "mapType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Produce a map type with `string` as key type and this as element type.",
"name" : "mapType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
}
}
}, {
"type" : "Method",
"name" : "mapTypeOf",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Produce a map type of elements of this type and provided with key type.",
"name" : "mapTypeOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapTypeOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"paramNames" : [ "keyType" ]
}
}, {
"type" : "Method",
"name" : "columnarType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Produce a columnar type for this type",
"name" : "columnarType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "columnarType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
}
}
}, {
"type" : "Method",
"name" : "runtimeJavaClassName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Runtime java class of the type.\n\n@see Ann.Java#runtimeClassName",
"name" : "runtimeJavaClassName",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "runtimeJavaClassName",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "schemaName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Schema / table name for this type typically used by entity types.",
"name" : "schemaName",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "schemaName",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "rootC3TableName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return Table name for non-external types (e.g. includes \"C3_2_\" prefix).",
"name" : "rootC3TableName",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "rootC3TableName",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "defaultUi",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeDefaultUi"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Produce a default UI configuration that incorporates the information present in the type itself,\nwhen a default presentation of this type is desired.",
"name" : "defaultUi",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeDefaultUi"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "defaultUi",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeDefaultUi"
}
}
}, {
"type" : "Method",
"name" : "toType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return corresponding and only Type for this TypeMeta",
"name" : "toType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}
}, {
"type" : "Method",
"name" : "toSdkJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation of this TypeMeta to a JSON object specific to a {@Link Action.Engine}.\nTODO: PLAT-32339 this function should be cached, pending impl of eviction policy. Without the policy, the memory burden has been measured to be too heavy",
"name" : "toSdkJson",
"params" : [ {
"name" : "actionEngine",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Action.Engine"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toSdkJson",
"params" : [ {
"name" : "actionEngine",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Action.Engine"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"paramNames" : [ "actionEngine" ]
}
}, {
"type" : "Method",
"name" : "withFieldType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates a new dynamic type with the additional field definition as specified and returns it.\nThis type will be an anonymous type that mixes in the current type, adding the extra field.\n\nThis is a shortcut method for adding a single new field.  See #putFieldTypes\nfor the more general function.\n\n@param field of the new field\n@param valueType type of the new field\n@return new dynamic type",
"name" : "withFieldType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "valueType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withFieldType",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "valueType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"paramNames" : [ "field", "valueType" ]
}
}, {
"type" : "Method",
"name" : "withFieldTypes",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates a new dynamic type with the additional field definitions as specified and returns it.\nThis type will be an anonymous type that mixes in the current type, adding the extra fields.\n\n@param field map of field specifications\n@return new dynamic type",
"name" : "withFieldTypes",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withFieldTypes",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "withFieldTypesAnns",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates a new dynamic type with the additional field definitions as specified and returns it.\nThis type will be an anonymous type that mixes in the current type, adding the extra fields.\n\n@param field iterable of field specifications\n@return new dynamic type",
"name" : "withFieldTypesAnns",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withFieldTypesAnns",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "withSelectedFieldTypes",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates a new dynamic type with only the selected fields.\n\n@param names\n       list of field names to select from this TypeMeta",
"name" : "withSelectedFieldTypes",
"params" : [ {
"name" : "names",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Collection<string>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withSelectedFieldTypes",
"params" : [ {
"name" : "names",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Collection<string>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
},
"paramNames" : [ "names" ]
}
}, {
"type" : "Method",
"name" : "objBuilder",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<O>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return new builder of instance of this type",
"name" : "objBuilder",
"genericVars" : [ {
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<O>",
"hadDeclaredVarBindings" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "@return new builder of instance of this type with fields populated based on provided Obj",
"name" : "objBuilder",
"genericVars" : [ {
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "initial",
"valueType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<O>",
"hadDeclaredVarBindings" : true
},
"inline" : true,
"member" : true,
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "@return builder of instance of this sub type of Typesys",
"name" : "objBuilder",
"genericVars" : [ {
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "pkg",
"valueType" : {
"type" : "ReferenceType",
"name" : "Pkg"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<O>",
"hadDeclaredVarBindings" : true
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "objBuilder",
"genericVars" : [ {
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "initialOrPkg",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"name" : "Pkg"
}
} ]
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<O>",
"hadDeclaredVarBindings" : true
},
"paramNames" : [ "initialOrPkg" ]
}
}, {
"type" : "Method",
"name" : "emptyObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Obj"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return empty instance of this type",
"name" : "emptyObj",
"params" : [ {
"name" : "pkg",
"valueType" : {
"type" : "ReferenceType",
"name" : "Pkg"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "emptyObj",
"params" : [ {
"name" : "pkg",
"valueType" : {
"type" : "ReferenceType",
"name" : "Pkg"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
},
"paramNames" : [ "pkg" ]
}
}, {
"type" : "Method",
"name" : "dereference",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return resolved C3 type from a string serialized reference to it. Type resolution happens in the scope if this\n        type e.g. if provided string is a bound generic variable reference then this method will return type that\n        is bound to that generic variable. It will also bind / resolve generic variable in the provided input\n        string. E.g. assuming `K` is a generic variable in this type bound to `string` and `E` is bound to a\n        `Duration` C3 type then `dereference(\"Pair<K,E>\")` will return `Pair<string, Duration>`",
"name" : "dereference",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "DeclaredReferenceType"
}
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "dereference",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "DeclaredReferenceType"
}
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"paramNames" : [ "typeName", "failIfMissing" ]
}
}, {
"type" : "Method",
"name" : "hasObjPool",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : true,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "True if instances of this type are pooled by fingerprint",
"name" : "hasObjPool",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"final" : true,
"inline" : true,
"member" : true,
"property" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasObjPool",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "call",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Generic dispatch of the C3 Action - i.e. application of function on a C3 Type. It handles both static and member\nfunctions. For static methods #thisArg should be `null`.\n\nNote that args are expected to be of correct value type and no additional conversion will be performed.\n\n@see #callByName\n@see #callJson",
"name" : "call",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "methodType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MethodType"
}
}, {
"name" : "thisArg",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "args",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "NativeType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Generic dispatch of the C3 Action - i.e. application of function on a C3 Type. It handles both static and member\nfunctions. For static methods thisArg should be `null`. If target method is overloaded, will match overload based\non argument value types.\n\nNote that args are expected to be of correct value type and no additional conversion will be performed.\n\n@see #callByName\n@see #callJson",
"name" : "call",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "method",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Method"
}
}, {
"name" : "overloadIndex",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
}, {
"name" : "thisArg",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "args",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "NativeType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Generic dispatch of the C3 Action - i.e. application of function on a C3 Type. It handles both static and member\nfunctions. For static methods thisArg should be `null`. If target method is overloaded, will match overload based\non argument value types.\n\nNote that while implementation will perform argument conversion it's most efficient to call with correct argument\nvalue types.\n\n@see #callByName\n@see #callJson",
"name" : "call",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "thisArg",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "args",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "NativeType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "call",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "methodTypeOrMethodOrAction",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MethodType"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Method"
}
} ]
}
}, {
"name" : "thisArgOrOverloadIndexOrThisArg",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "argsOrThisArgOrArgs",
"valueType" : {
"type" : "AnyType"
},
"varArgs" : true
}, {
"name" : "args",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "NativeType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "methodTypeOrMethodOrAction", "thisArgOrOverloadIndexOrThisArg", "argsOrThisArgOrArgs", "args" ]
}
}, {
"type" : "Method",
"name" : "callByName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Generic dispatch of the C3 Action - i.e. application of function on a C3 Type. It handles both static and member\nfunctions. For member methods args should contain `this` key. If target method is overloaded will match overload\nbased on argument value types.\n\nNote that while implementation will perform argument conversion it's most efficient to call with correct argument\nvalue types.\n\n@see #call\n@see #callJson",
"name" : "callByName",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "args",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "NativeType"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "callByName",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "args",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "NativeType"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "action", "args" ]
}
}, {
"type" : "Method",
"name" : "callByArgsAndKwargs",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Generic dispatch of the C3 Action - i.e. application of function on a C3 Type. It handles both static and member\nfunctions. If target method is overloaded will match overload based on argument value types.\n\nNote that while implementation will perform argument conversion it's most efficient to call with correct argument\nvalue types.\n\n@see #call\n@see #callJson",
"name" : "callByArgsAndKwargs",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "thisArg",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "args",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "NativeType"
}
}
}, {
"name" : "kwargs",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "NativeType"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "callByArgsAndKwargs",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "thisArg",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "args",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "NativeType"
}
}
}, {
"name" : "kwargs",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "NativeType"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "action", "thisArg", "args", "kwargs" ]
}
}, {
"type" : "Method",
"name" : "callJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Generic dispatch of the C3 Action - i.e. application of function on a C3 Type. It handles both static and member\nfunctions. Expectation is that input is a valid serialization of C3 Action named arguments including `this` in case\nof member actions. Return is a C3 value.\n\n@see #call\n@see #callByName",
"name" : "callJson",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "input",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Generic dispatch of the C3 Action - i.e. application of function on a C3 Type. It handles both static and member\nfunctions. Expectation is that args is a valid serialization of C3 Action positional arguments and kwargs\nare a valid serialization of C3 Action named arguments.\nReturn is a C3 value.\n\n@see #call\n@see #callByName",
"name" : "callJson",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "thisArg",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
}, {
"name" : "args",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
}, {
"name" : "kwargs",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "callJson",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "inputOrThisArg",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
}, {
"name" : "args",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
}, {
"name" : "kwargs",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "action", "inputOrThisArg", "args", "kwargs" ]
}
}, {
"type" : "Method",
"name" : "callFromCodeGen",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Dispatch of the C3 Action from a Java Code Generated C3 type instances and implementations\n\n@see #call\n@see #callByName\n@see #callJson",
"name" : "callFromCodeGen",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "method",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Method"
}
}, {
"name" : "overloadIndex",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
}, {
"name" : "thisArg",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "args",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "callFromCodeGen",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "method",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Method"
}
}, {
"name" : "overloadIndex",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
}, {
"name" : "thisArg",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "args",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "method", "overloadIndex", "thisArg", "args" ]
}
}, {
"type" : "Method",
"name" : "memoize",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return result of a call to a method [ aka memoization ]; this is slightly different then #call as actual result\n        type may not match method return type. E.g. if method takes",
"name" : "memoize",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "method",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MethodType"
}
}, {
"name" : "thisArg",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "keys",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "include",
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "memoize",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "method",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MethodType"
}
}, {
"name" : "thisArg",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "keys",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "include",
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "method", "thisArg", "keys", "include", "exclude" ]
}
}, {
"type" : "Method",
"name" : "instantiate",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "O"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "TypeMeta" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "TypeMeta"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return empty instance of this type",
"name" : "instantiate",
"genericVars" : [ {
"name" : "O"
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "O"
},
"private" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "@return new instance of this type based on provided string representation\n\n@see StringSerializable#fromString",
"name" : "instantiate",
"genericVars" : [ {
"name" : "O"
} ],
"params" : [ {
"name" : "s",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "O"
},
"private" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "@return new instance of this type with the specified fields",
"name" : "instantiate",
"genericVars" : [ {
"name" : "O"
} ],
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "pkg",
"valueType" : {
"type" : "ReferenceType",
"name" : "Pkg"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "O"
},
"private" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 2
}, {
"type" : "MethodType",
"doc" : "@return new instance of this type using the language-specific construction mechanism\n\n@see Obj#make",
"name" : "instantiate",
"genericVars" : [ {
"name" : "O"
} ],
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "\"java.lang.Object[]\""
} ]
} ],
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "pkg",
"valueType" : {
"type" : "ReferenceType",
"name" : "Pkg"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "O"
},
"private" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 3
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "instantiate",
"genericVars" : [ {
"name" : "O"
} ],
"params" : [ {
"name" : "sOrFieldsOrFields",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
} ]
}
}, {
"name" : "pkg",
"valueType" : {
"type" : "ReferenceType",
"name" : "Pkg"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "O"
},
"paramNames" : [ "sOrFieldsOrFields", "pkg" ]
},
"$nearestImplementedOn" : "TypeMeta"
}, {
"type" : "Method",
"name" : "scope",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypesysScope"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return type system scope for building / binding declared fields and value types.",
"name" : "scope",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypesysScope"
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "scope",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypesysScope"
}
}
}, {
"type" : "Method",
"name" : "javaInterface",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'java.lang.Class'"
} ]
} ]
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return Java class for interface for instances of this type or null",
"name" : "javaInterface",
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'java.lang.Class'"
} ]
} ]
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "javaInterface",
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'java.lang.Class'"
} ]
} ]
}
}
}, {
"type" : "Method",
"name" : "calcFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return The set of all calc fields, (stored and read) in this type",
"name" : "calcFields",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "calcFields",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}
}
}, {
"type" : "Method",
"name" : "readCalcFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return The set of all read calc fields in this type",
"name" : "readCalcFields",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "readCalcFields",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}
}
}, {
"type" : "Method",
"name" : "rewrittenCalcFieldExpr",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "\"c3.platform.expr.ast.ExprNode\""
} ]
} ]
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return a calc field expression rewritten to replace type casting with typeIdent checks.  Note this only returns\n        a rewritten expression if there were replaced type casts.\n\nFOR INTERNAL USE ONLY",
"name" : "rewrittenCalcFieldExpr",
"params" : [ {
"name" : "origExpr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "\"c3.platform.expr.ast.ExprNode\""
} ]
} ]
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "rewrittenCalcFieldExpr",
"params" : [ {
"name" : "origExpr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "\"c3.platform.expr.ast.ExprNode\""
} ]
} ]
},
"paramNames" : [ "origExpr" ]
}
}, {
"type" : "Method",
"name" : "constraintDepFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return The set of all fields that constraints depend on in this type.",
"name" : "constraintDepFields",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "constraintDepFields",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}
}
}, {
"type" : "Method",
"name" : "dbEngineConstraintFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return List of all fields that the db engine enforces constraints on.",
"name" : "dbEngineConstraintFields",
"params" : [ {
"name" : "newRecord",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "dbEngineConstraintFields",
"params" : [ {
"name" : "newRecord",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"paramNames" : [ "newRecord" ]
}
}, {
"type" : "Method",
"name" : "useSimpleDbEngineConstraintCheck",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if all of the db engine constraint fields are \"simple\" (e.g. don't involve included references).",
"name" : "useSimpleDbEngineConstraintCheck",
"params" : [ {
"name" : "newRecord",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "useSimpleDbEngineConstraintCheck",
"params" : [ {
"name" : "newRecord",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "newRecord" ]
}
}, {
"type" : "Method",
"name" : "dbDomain",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Db.Domain"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return {@link Db.Domain} if this entity type belongs to a specific Db.Domain\n\n@see Ann.Db#domain",
"name" : "dbDomain",
"returnType" : {
"type" : "ReferenceType",
"name" : "Db.Domain"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "dbDomain",
"returnType" : {
"type" : "ReferenceType",
"name" : "Db.Domain"
}
}
}, {
"type" : "Method",
"name" : "targetAppExpr",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Expr"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return {@link Expr} for calculating target app id to call for type\n\n@see Ann.Call#serverRole",
"name" : "targetAppExpr",
"returnType" : {
"type" : "ReferenceType",
"name" : "Expr"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "targetAppExpr",
"returnType" : {
"type" : "ReferenceType",
"name" : "Expr"
}
}
}, {
"type" : "Method",
"name" : "targetNodeRoleExpr",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Expr"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return {@link Expr} for calculating target server role for this type\n\n@see Ann.Call#serverRole",
"name" : "targetNodeRoleExpr",
"returnType" : {
"type" : "ReferenceType",
"name" : "Expr"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "targetNodeRoleExpr",
"returnType" : {
"type" : "ReferenceType",
"name" : "Expr"
}
}
}, {
"type" : "Method",
"name" : "targetNodePoolExpr",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Expr"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return {@link Expr} for calculating target server node pool for this type\n\n@see Ann.Call#nodePool",
"name" : "targetNodePoolExpr",
"returnType" : {
"type" : "ReferenceType",
"name" : "Expr"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "targetNodePoolExpr",
"returnType" : {
"type" : "ReferenceType",
"name" : "Expr"
}
}
}, {
"type" : "Method",
"name" : "targetNodeExpr",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Expr"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return {@link Expr} for calculating target server node for this type\n\n@see Ann.Call#node",
"name" : "targetNodeExpr",
"returnType" : {
"type" : "ReferenceType",
"name" : "Expr"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "targetNodeExpr",
"returnType" : {
"type" : "ReferenceType",
"name" : "Expr"
}
}
}, {
"type" : "Method",
"name" : "targetThreadPoolExpr",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Expr"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return {@link Expr} for calculating target thread-pool for this type\n\n@see Ann.Call#threadPool",
"name" : "targetThreadPoolExpr",
"returnType" : {
"type" : "ReferenceType",
"name" : "Expr"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "targetThreadPoolExpr",
"returnType" : {
"type" : "ReferenceType",
"name" : "Expr"
}
}
}, {
"type" : "Method",
"name" : "hasConstraintDepFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return True if any constraints have any fields they depend on.",
"name" : "hasConstraintDepFields",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasConstraintDepFields",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "hasChildCollection",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return True if the type has any non-fkey child collections. Includes recursive included type fields.",
"name" : "hasChildCollection",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasChildCollection",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "persistableCollectionFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return List of all collection fields (including nested) that are persisted in this type.",
"name" : "persistableCollectionFields",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "persistableCollectionFields",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}
}
}, {
"type" : "Method",
"name" : "collectionTables",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return a map of all tables used for persisted collections, keyed by the field path for the collection field.",
"name" : "collectionTables",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "collectionTables",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}
}, {
"type" : "Method",
"name" : "textSearchFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return list of all fields that have the textSearchField db annotation. For Postgres, a full text search index\n        will be created",
"name" : "textSearchFields",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "textSearchFields",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}
}
}, {
"type" : "Method",
"name" : "fieldTypesWithInitialValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return A list of field types that will have non-null values on Obj instantiation (e.g. fields with default values on\ntypes that aren't entity types as well as boolean fields)",
"name" : "fieldTypesWithInitialValue",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldTypesWithInitialValue",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
}
}, {
"type" : "Method",
"name" : "conditionalConstraint",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Pair<Expr.Compiled<Obj, boolean>, string>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@returns the conditional constraint, if any, for the type.",
"name" : "conditionalConstraint",
"returnType" : {
"type" : "ReferenceType",
"name" : "Pair<Expr.Compiled<Obj, boolean>, string>",
"hadDeclaredVarBindings" : true
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "conditionalConstraint",
"returnType" : {
"type" : "ReferenceType",
"name" : "Pair<Expr.Compiled<Obj, boolean>, string>",
"hadDeclaredVarBindings" : true
}
}
}, {
"type" : "Method",
"name" : "actionEngineScope",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "NativeType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return cached and shared scope / compiled unit of given Action.Engine for this type.",
"name" : "actionEngineScope",
"params" : [ {
"name" : "actionEngine",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Action.Engine"
}
}
} ],
"returnType" : {
"type" : "NativeType"
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "actionEngineScope",
"params" : [ {
"name" : "actionEngine",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Action.Engine"
}
}
} ],
"returnType" : {
"type" : "NativeType"
},
"paramNames" : [ "actionEngine" ]
}
}, {
"type" : "Method",
"name" : "compositeKeyType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return The composite key type for the type, if any. The composite key type is the type in the mixin chain that\n        directly mixes CompositeKey. For CompositeKey types themselves, this will return itself.",
"name" : "compositeKeyType",
"returnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "compositeKeyType",
"returnType" : {
"type" : "ReferenceType",
"name" : "Type"
}
}
}, {
"type" : "Method",
"name" : "compositeKeyFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return the list of fields comprising the composite key, For any type that isA composite key and an empty\n        array otherwise.",
"name" : "compositeKeyFields",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "compositeKeyFields",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}
}
}, {
"type" : "Method",
"name" : "primaryKeyFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return the list of fields comprising the primary key. If the type has a composite key, it will be the fields\n        defined in the key type. Otherwise the id field will be returned for persistable types. For\n        non-persistable fields, an empty array is returned.",
"name" : "primaryKeyFields",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "primaryKeyFields",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}
}
}, {
"type" : "Method",
"name" : "idColName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return the column name for the id field",
"name" : "idColName",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "idColName",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "hasEventStream",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : true,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return `true`, if this is an EventStream or has fields of type EventStream.",
"name" : "hasEventStream",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"property" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasEventStream",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "timedValueFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Gets the set of all fields in this type and, optionally, any of it's extension base types that have\nthe @db(timedValueHistoryField) annotation\n\n@param inclExtBaseFields\n       true indicates that fields defined in extension base types for the type should be included. False\n       means that only fields defined in the type itself should be returned.\n@return the set of all fields in this type and, optionally, any of it's extension base types that have the\n@db(timedValueHistoryField) annotation",
"name" : "timedValueFields",
"params" : [ {
"name" : "inclExtBaseFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "timedValueFields",
"params" : [ {
"name" : "inclExtBaseFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"paramNames" : [ "inclExtBaseFields" ]
}
}, {
"type" : "Method",
"name" : "timedValueHistoryFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Gets the set of all fields in this type and, optionally, any of it's extension base types that are the field\nreferenced in a @db(timedValueHistoryField) annotation for a timed value field\n\n@param inclExtBaseFields\n       true indicates that fields defined in extension base types for the type should be included. False\n       means that only fields defined in the type itself should be returned.\n@return the set of all fields in this type and, optionally, any of it's extension base types that are the field\n        referenced in a @db(timedValueHistoryField) annotation for a timed value field",
"name" : "timedValueHistoryFields",
"params" : [ {
"name" : "inclExtBaseFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "timedValueHistoryFields",
"params" : [ {
"name" : "inclExtBaseFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"paramNames" : [ "inclExtBaseFields" ]
}
}, {
"type" : "Method",
"name" : "timedValueFieldForHistoryField",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get the timed value history field for the specified timed value field.\n\n@param field\n       The timed value field.\n\n@return The timed value history field for the specified timed value field.  If the specified field is not a timed\n        value field, or is not associated with a history field, null is returned.",
"name" : "timedValueFieldForHistoryField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "timedValueFieldForHistoryField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "field" ]
}
}, {
"type" : "Method",
"name" : "timedCharacteristicFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Gets the set of all fields in this type and, optionally, any of it's extension base types that have\nthe @db(timedCharacteristicHistoryField) annotation\n\n@param inclExtBaseFields\n       true indicates that fields defined in extension base types for the type should be included. False\n       means that only fields defined in the type itself should be returned.\n@return the set of all fields in this type and, optionally, any of it's extension base types that have the\n@db(timedCharacteristicHistoryField) annotation",
"name" : "timedCharacteristicFields",
"params" : [ {
"name" : "inclExtBaseFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "timedCharacteristicFields",
"params" : [ {
"name" : "inclExtBaseFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"paramNames" : [ "inclExtBaseFields" ]
}
}, {
"type" : "Method",
"name" : "timedCharacteristicHistoryFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Gets the set of all fields in this type and, optionally, any of it's extension base types that are the field\nreferenced in a @db(timedCharacteristicHistory) annotation for a timed characteristic field\n\n@param inclExtBaseFields\n       true indicates that fields defined in extension base types for the type should be included. False\n       means that only fields defined in the type itself should be returned.\n@return the set of all fields in this type and, optionally, any of it's extension base types that are the field\n        referenced in a @db(timedCharacteristicHistoryField) annotation for a timed characteristic field",
"name" : "timedCharacteristicHistoryFields",
"params" : [ {
"name" : "inclExtBaseFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "timedCharacteristicHistoryFields",
"params" : [ {
"name" : "inclExtBaseFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"paramNames" : [ "inclExtBaseFields" ]
}
}, {
"type" : "Method",
"name" : "timedCharacteristicFieldForHistoryField",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get the timed characteristic history field for the specified timed characteristic field.\n\n@param field\n       The timed characteristic field.\n\n@return The timed characteristic history field for the specified timed characteristic field.  If the specified\n        field is not a timed characteristic field, or is not associated with a history field, null is returned.",
"name" : "timedCharacteristicFieldForHistoryField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "timedCharacteristicFieldForHistoryField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "field" ]
}
}, {
"type" : "Method",
"name" : "keepVersionHistory",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return True if the type is configured to retain a history of edits to each obj.",
"name" : "keepVersionHistory",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "keepVersionHistory",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "indexes",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "SortField"
}
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return list of indexes defined for this type in the @db(index) extension. Each entry will be a list of sort fields\n        for the index.",
"name" : "indexes",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "SortField"
}
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "indexes",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "SortField"
}
}
}
}
}, {
"type" : "Method",
"name" : "uniqueConstraints",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return list of unique indexes defined for this type in the db extension. Each entry will be an array of fields in the\n        unique index.  Index fields can optionally refer to a field of an included reference and that's why FieldPath\n        is used",
"name" : "uniqueConstraints",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "uniqueConstraints",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}
}
}
}, {
"type" : "Method",
"name" : "timedValuesParent",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return a map of timed value parent types/fields grouped by source type.",
"name" : "timedValuesParent",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "timedValuesParent",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}
}
}, {
"type" : "Method",
"name" : "timedCharacteristicsParent",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns a map of timed characteristic parent types/fields grouped by source type.",
"name" : "timedCharacteristicsParent",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "timedCharacteristicsParent",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}
}
}, {
"type" : "Method",
"name" : "calcBwdDeps",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeBackwardDep"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return calc field backward dependencies for a type",
"name" : "calcBwdDeps",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeBackwardDep"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "calcBwdDeps",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeBackwardDep"
}
}
}
}, {
"type" : "Method",
"name" : "aclBwdDeps",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeBackwardDep"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return acl backward dependencies for a type",
"name" : "aclBwdDeps",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeBackwardDep"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "aclBwdDeps",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeBackwardDep"
}
}
}
}, {
"type" : "Method",
"name" : "triggeringFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "SetType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Determines the set of fields that trigger invalidation for the specified queue.\n\n@param queueType\n       Queue type to check invalidation for.\n@param includeBaseTypes\n       If true, base type fields will also be included.\n@param includeExtensionTypes\n       If true, extension types will also be included.\n@param ignoreSelfDeps\n       If true, self deps (e.g. deps that have no parent) will be ignored.\n@param forBeforeUpdate\n       If true, only looking for deps that should be triggered during the beforeUpdate phase.\n\n@return the set of fields that trigger invalidation for the specified queue",
"name" : "triggeringFields",
"params" : [ {
"name" : "queueType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "includeBaseTypes",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "includeExtensionTypes",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "ignoreSelfDeps",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "forBeforeUpdate",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "SetType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "triggeringFields",
"params" : [ {
"name" : "queueType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "includeBaseTypes",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "includeExtensionTypes",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "ignoreSelfDeps",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "forBeforeUpdate",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "SetType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"paramNames" : [ "queueType", "includeBaseTypes", "includeExtensionTypes", "ignoreSelfDeps", "forBeforeUpdate" ]
}
}, {
"type" : "Method",
"name" : "_triggeringFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "SetType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Determines the set of fields that trigger invalidation for the specified key.\n\n@param key\n       key describing trigger scenario\n\n@return the set of fields that trigger invalidation for the specified key.",
"name" : "_triggeringFields",
"params" : [ {
"name" : "key",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "SetType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "_triggeringFields",
"params" : [ {
"name" : "key",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "SetType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"paramNames" : [ "key" ]
}
}, {
"type" : "Method",
"name" : "datastore",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return the value specified in Ann.Db.datastore (if any) or overridden in the Db.Domain.  This will currently be\n        \"kv\" for data persisted in the KV store, null by default for data persisted in the c3 managed relational\n        datastore, or the name of a specific datastore.",
"name" : "datastore",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "datastore",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "secondaryDatastore",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "The datastore to maintain a parallel synchronized copy of the data for the type, typically to a system like\nRedshift for advanced analytic querying capabilities.",
"name" : "secondaryDatastore",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "secondaryDatastore",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "fieldsWithInclude",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return List of all fields that specify the `Ann.Db.include` annotation.",
"name" : "fieldsWithInclude",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldsWithInclude",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}
}
}, {
"type" : "Method",
"name" : "subTypeForTypeIdent",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : true,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return extension type at any level with provided typeIdent.",
"name" : "subTypeForTypeIdent",
"params" : [ {
"name" : "typeIdent",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfInvalid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "subTypeForTypeIdent",
"params" : [ {
"name" : "typeIdent",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfInvalid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"paramNames" : [ "typeIdent", "failIfInvalid" ]
}
}, {
"type" : "Method",
"name" : "isValidTypeIdent",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return True if the typeIdent is valid for any subtype of this type.",
"name" : "isValidTypeIdent",
"params" : [ {
"name" : "typeIdent",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isValidTypeIdent",
"params" : [ {
"name" : "typeIdent",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "typeIdent" ]
}
}, {
"type" : "Method",
"name" : "authz",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "authz",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "authz",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "authzChildActions",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return value of `@action(authzChildActions=` annotation",
"name" : "authzChildActions",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "authzChildActions",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "accessControlGroups",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return value of `@action(accessControlGroups=` annotation",
"name" : "accessControlGroups",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "accessControlGroups",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}
}, {
"type" : "Method",
"name" : "remix",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return remixed type by merging annotations, fields and methods from a provided #remixType into this one",
"name" : "remix",
"params" : [ {
"name" : "remixType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "remix",
"params" : [ {
"name" : "remixType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"paramNames" : [ "remixType" ]
}
}, {
"type" : "Method",
"name" : "repository",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get repository type belongs to.",
"name" : "repository",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "repository",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "ensureValidFieldNames",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Ensures that this TypeMeta contains field names that can be parsed by Type System DSL. For example,\n\"hello:world\" is an invalid field name because it contains the \":\" character which is used as a delimiter between\nfield name and ValueType.\n\n@return new TypeMeta with invalid field names replaced with valid field names",
"name" : "ensureValidFieldNames",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "ensureValidFieldNames",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
}
}
}, {
"type" : "Method",
"name" : "isFacade",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Checks if type is facaded for a given app. Facaded types live in a different app.\n\n@return true if type is facaded in an app other than the one specified. I.e. call to this type from app that is\n        different then provided app will resolve into a remote call",
"name" : "isFacade",
"params" : [ {
"name" : "app",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "AppId"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isFacade",
"params" : [ {
"name" : "app",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "AppId"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "app" ]
}
}, {
"type" : "Method",
"name" : "isNoOverlapTimedIntervalValueHistoryType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "isNoOverlapTimedIntervalValueHistoryType",
"params" : [ {
"name" : "parentType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isNoOverlapTimedIntervalValueHistoryType",
"params" : [ {
"name" : "parentType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "parentType" ]
}
}, {
"type" : "Method",
"name" : "isRawTimeseries",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return True if this type mixes in the IntervalDataHeader type but not the NormalizedTimeseries type",
"name" : "isRawTimeseries",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isRawTimeseries",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isRawTimeseriesDataPoint",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "isRawTimeseriesDataPoint",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isRawTimeseriesDataPoint",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isAnyNormalized",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "isAnyNormalized",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isAnyNormalized",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isNormalizedTimedDataPoint",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "isNormalizedTimedDataPoint",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isNormalizedTimedDataPoint",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isNormalizedTimeseriesDataPoint",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "isNormalizedTimeseriesDataPoint",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isNormalizedTimeseriesDataPoint",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isAnyExpr",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "isAnyExpr",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isAnyExpr",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isRawTimedData",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return True if this type mixes in the TimedDataHeader type but not the NormalizedTimeseries type",
"name" : "isRawTimedData",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isRawTimedData",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isRawTimedDataPoint",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "isRawTimedDataPoint",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isRawTimedDataPoint",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "partitionKeyField",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return name of the field for partitioning instances of this type for storage.",
"name" : "partitionKeyField",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "partitionKeyField",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "partitionKeyFieldType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return FieldType of the field for partitioning instances of this type for storage.",
"name" : "partitionKeyFieldType",
"returnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "partitionKeyFieldType",
"returnType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
}, {
"type" : "Method",
"name" : "compiledPartitionKeyFieldExpr",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Expr.Compiled<any, any>"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return compiled partition key field expression (or id) on the given type",
"name" : "compiledPartitionKeyFieldExpr",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Expr.Compiled<any, any>"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "compiledPartitionKeyFieldExpr",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Expr.Compiled<any, any>"
}
}
}, {
"type" : "Method",
"name" : "shortIdPrefix",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "shortIdPrefix",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "shortIdPrefix",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "shortIdSuffixType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "shortIdSuffixType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "shortIdSuffixType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "shortIdReservationRange",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "shortIdReservationRange",
"returnType" : {
"type" : "IntType",
"name" : "int"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "shortIdReservationRange",
"returnType" : {
"type" : "IntType",
"name" : "int"
}
}
}, {
"type" : "Method",
"name" : "hasShortId",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "hasShortId",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasShortId",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "fkeyFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return a list of all fields that are fkey fields (both array and single ref)",
"name" : "fkeyFields",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fkeyFields",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}
}
}, {
"type" : "Method",
"name" : "fkeyParents",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Map, keyed by types that have fkey fields with this type as a reference type, where each element is the list of\nthe fkey field names.",
"name" : "fkeyParents",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fkeyParents",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "Type"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}
}
}, {
"type" : "Method",
"name" : "fkeyRefFilter",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Db Extension: @return filter spec to be used for a read only one to many relationship.",
"name" : "fkeyRefFilter",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fkeyRefFilter",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "field" ]
}
}, {
"type" : "Method",
"name" : "fkeyRefFkey",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Db Extension: @return field path that is a foreign key in the reference type for a read only one to many\nrelationship.",
"name" : "fkeyRefFkey",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fkeyRefFkey",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "field" ]
}
}, {
"type" : "Method",
"name" : "fkeyRefKey",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Db Extension: @return field path that is a key in the source type for a read only one to many relationship.",
"name" : "fkeyRefKey",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fkeyRefKey",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "field" ]
}
}, {
"type" : "Method",
"name" : "fkeyRefOrder",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Db Extension: @return order spec to be used for a read only one to many relationship.",
"name" : "fkeyRefOrder",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fkeyRefOrder",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "field" ]
}
}, {
"type" : "Method",
"name" : "isFkeyRefArray",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return whether this value type is an fkey reference array field.",
"name" : "isFkeyRefArray",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "@return whether this value type is an fkey reference array field.",
"name" : "isFkeyRefArray",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isFkeyRefArray",
"params" : [ {
"name" : "fieldOrFt",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
} ]
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "fieldOrFt" ]
}
}, {
"type" : "Method",
"name" : "isFkeyRef",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "isFkeyRef",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isFkeyRef",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "field" ]
}
}, {
"type" : "Method",
"name" : "hierDenormTarget",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "HierDenormTarget"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return the hierarchy denorm type for this type's hierarchy",
"name" : "hierDenormTarget",
"returnType" : {
"type" : "ReferenceType",
"name" : "HierDenormTarget"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hierDenormTarget",
"returnType" : {
"type" : "ReferenceType",
"name" : "HierDenormTarget"
}
}
}, {
"type" : "Method",
"name" : "parentDirPathInRepo",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Get the path in repository to directory containing type.",
"name" : "parentDirPathInRepo",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "parentDirPathInRepo",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "persistDuplicates",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return false if duplicates should be removed when persisting instances of this type",
"name" : "persistDuplicates",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "persistDuplicates",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "hasViewIncludeOrFilter",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return true if the type has a viewFilter or viewInclude specified",
"name" : "hasViewIncludeOrFilter",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasViewIncludeOrFilter",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "storedCalcFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Gets the set of all stored calc fields in this type and, optionally, any of its extension base types",
"name" : "storedCalcFields",
"params" : [ {
"name" : "inclExtBaseFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "storedCalcFields",
"params" : [ {
"name" : "inclExtBaseFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"paramNames" : [ "inclExtBaseFields" ]
}
}, {
"type" : "Method",
"name" : "hasStoredCalcOrTimedValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return True if the type has any stored calc fields, timed value fields  or timed characteristic fields.",
"name" : "hasStoredCalcOrTimedValues",
"params" : [ {
"name" : "inclExtBaseFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasStoredCalcOrTimedValues",
"params" : [ {
"name" : "inclExtBaseFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "inclExtBaseFields" ]
}
}, {
"type" : "Method",
"name" : "latestCharacteristicsFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return the list of field that are the \"latest characteristic\" fields linked to `TimedCharacteristicHistory`\n        fields.",
"name" : "latestCharacteristicsFields",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "latestCharacteristicsFields",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}
}
}, {
"type" : "Method",
"name" : "allUniqueConstraintFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "SetType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return set of all fields used in any of the unique field sequences",
"name" : "allUniqueConstraintFields",
"returnType" : {
"type" : "SetType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "allUniqueConstraintFields",
"returnType" : {
"type" : "SetType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}
}
}, {
"type" : "Method",
"name" : "setPrototype",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "setPrototype",
"params" : [ {
"name" : "prototype",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
}
} ],
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "setPrototype",
"params" : [ {
"name" : "prototype",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
}
} ],
"paramNames" : [ "prototype" ]
}
}, {
"type" : "Method",
"name" : "retainedObjs",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StreamType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "retainedObjs",
"params" : [ {
"name" : "filter",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"name" : "offset",
"valueType" : {
"type" : "IntType",
"name" : "int"
}
}, {
"name" : "limit",
"valueType" : {
"type" : "IntType",
"name" : "int"
}
} ],
"returnType" : {
"type" : "StreamType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "retainedObjs",
"params" : [ {
"name" : "filter",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"name" : "offset",
"valueType" : {
"type" : "IntType",
"name" : "int"
}
}, {
"name" : "limit",
"valueType" : {
"type" : "IntType",
"name" : "int"
}
} ],
"returnType" : {
"type" : "StreamType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"paramNames" : [ "filter", "offset", "limit" ]
}
}, {
"type" : "Method",
"name" : "allocated",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "allocated",
"returnType" : {
"type" : "IntType",
"name" : "int"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "allocated",
"returnType" : {
"type" : "IntType",
"name" : "int"
}
}
}, {
"type" : "Method",
"name" : "hasConfiguredAnnotations",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "hasConfiguredAnnotations",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasConfiguredAnnotations",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isUnique",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "True if this field is unique. This is expected to be called on an entity type and that the field path\nis a valid field path in this type.",
"name" : "isUnique",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isUnique",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "fieldPath" ]
}
}, {
"type" : "Method",
"name" : "isArchiveable",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "isArchiveable",
"params" : [ {
"name" : "tenantConfigNoArchive",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isArchiveable",
"params" : [ {
"name" : "tenantConfigNoArchive",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "tenantConfigNoArchive" ]
}
}, {
"type" : "Method",
"name" : "isCompositeKeyType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "isCompositeKeyType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isCompositeKeyType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isAnnotationType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "isAnnotationType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isAnnotationType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isCompactType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "isCompactType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isCompactType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isPlatformType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "isPlatformType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isPlatformType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isSystemType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "isSystemType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isSystemType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isVersioned",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "isVersioned",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isVersioned",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isEvaluatable",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "isEvaluatable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isEvaluatable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isSearchable",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns true if the type mixes {@link Searchable}",
"name" : "isSearchable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isSearchable",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "isConstant",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return True if the given field is a constant, i.e., fixed to its default value.",
"name" : "isConstant",
"params" : [ {
"name" : "fieldName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isConstant",
"params" : [ {
"name" : "fieldName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "fieldName" ]
}
}, {
"type" : "Method",
"name" : "fieldReferenceType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "ReferenceType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Reference type for the provided reference field type name.\n\n@param name\n       of the reference typed field\n@return a reference type for the field",
"name" : "fieldReferenceType",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "ReferenceType"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldReferenceType",
"params" : [ {
"name" : "name",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "ReferenceType"
},
"paramNames" : [ "name" ]
}
}, {
"type" : "Method",
"name" : "validateSchema",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Called by platform when a Persistable type is accessed to ensure that its schema is up to date.\n\n@return true if the schema was updated in this JVM/app",
"name" : "validateSchema",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "validateSchema",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "validateKvSchema",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Called by platform when a Kv type is accessed to ensure that its schema is up to date.\n\n@return true if the schema was updated in this JVM/app (result of first call is cached return value).",
"name" : "validateKvSchema",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "validateKvSchema",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "doValidateSchema",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Called by {@link validateSchema} to validate the schema for a type and all its extension types.\n\n@return true if the schema was updated in this JVM for the type and current app code (result of first call is\n        cached return value).",
"name" : "doValidateSchema",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "doValidateSchema",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "dependencies",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMetaDeps"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Calculates all \"forward\" dependencies of this type to other types or metadata elements",
"name" : "dependencies",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMetaDeps"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "dependencies",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMetaDeps"
}
}
}, {
"type" : "Method",
"name" : "fingerprintWithDeps",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return fingerprint / checksum of this type including it's dependencies\n\n@see Fingerprintable#fingerprint",
"name" : "fingerprintWithDeps",
"returnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fingerprintWithDeps",
"returnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
}
}
}, {
"type" : "Method",
"name" : "metaElementAt",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Typesys"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Retrieves child metadata element at character position in the declaration of this C3 type\n\n@param line\n       line number starting with 1 in the source file\n@param charInLine\n       character position in a line starting with 1 in the source file\n@return child metadata element at character position in the declaration of this C3 type",
"name" : "metaElementAt",
"params" : [ {
"name" : "line",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
}, {
"name" : "charInLine",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Typesys"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "metaElementAt",
"params" : [ {
"name" : "line",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
}, {
"name" : "charInLine",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Typesys"
},
"paramNames" : [ "line", "charInLine" ]
}
}, {
"type" : "Method",
"name" : "declaredMetaElements",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : true,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"annotationsJson" : [ {
"sorted" : [ {
"name" : "key",
"value" : true
} ]
} ],
"keyType" : {
"type" : "Int32Type",
"name" : "int32"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Typesys"
}
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return map of declared child metadata elements where key is source line number starting with 1 in a c3typ and\n        values are elements declared on that line ordered by declaration character position",
"name" : "declaredMetaElements",
"returnType" : {
"type" : "MapType",
"annotationsJson" : [ {
"sorted" : [ {
"name" : "key",
"value" : true
} ]
} ],
"keyType" : {
"type" : "Int32Type",
"name" : "int32"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Typesys"
}
}
},
"cached" : true,
"inline" : true,
"member" : true,
"property" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "declaredMetaElements",
"returnType" : {
"type" : "MapType",
"annotationsJson" : [ {
"sorted" : [ {
"name" : "key",
"value" : true
} ]
} ],
"keyType" : {
"type" : "Int32Type",
"name" : "int32"
},
"elementType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Typesys"
}
}
}
}
}, {
"type" : "Method",
"name" : "toTupleType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "TupleType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return named TupleType for the given TypeMeta",
"name" : "toTupleType",
"returnType" : {
"type" : "ReferenceType",
"name" : "TupleType"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toTupleType",
"returnType" : {
"type" : "ReferenceType",
"name" : "TupleType"
}
}
}, {
"type" : "Method",
"name" : "toSubtype",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'c3.platform.typesys.type.Subtype_Base'"
}, {
"name" : "codeGenExtends",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toSubtype",
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'c3.platform.typesys.type.Subtype_Base'"
}, {
"name" : "codeGenExtends",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY"
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toSubtype",
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'c3.platform.typesys.type.Subtype_Base'"
}, {
"name" : "codeGenExtends",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY"
}
}
}, {
"type" : "Method",
"name" : "_javaSubtype",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'c3.platform.typesys.type.Subtype_Base'"
} ]
} ]
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "_javaSubtype",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'c3.platform.typesys.type.Subtype_Base'"
} ]
} ]
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "_javaSubtype",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'c3.platform.typesys.type.Subtype_Base'"
} ]
} ]
},
"paramNames" : [ "mixin" ]
}
}, {
"type" : "Method",
"name" : "_myJavaMethods",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'c3.platform.Methods_Base'"
} ]
} ]
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "_myJavaMethods",
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'c3.platform.Methods_Base'"
} ]
} ]
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "_myJavaMethods",
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'c3.platform.Methods_Base'"
} ]
} ]
}
}
}, {
"type" : "Method",
"name" : "_javaMethods",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"cachedKey" : "arg",
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'c3.platform.Methods_Base'"
} ]
} ]
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "_javaMethods",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'c3.platform.Methods_Base'"
} ]
} ]
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "_javaMethods",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'c3.platform.Methods_Base'"
} ]
} ]
},
"paramNames" : [ "mixin" ]
}
}, {
"type" : "Method",
"name" : "replaceTypeMeta",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Replaces the old {@link TypeMeta} instance with the new one.",
"name" : "replaceTypeMeta",
"params" : [ {
"name" : "old",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
}
}, {
"name" : "new",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
}
} ],
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "replaceTypeMeta",
"params" : [ {
"name" : "old",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
}
}, {
"name" : "new",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "TypeMeta"
}
} ],
"paramNames" : [ "old", "new" ]
}
}, {
"type" : "Method",
"name" : "avroSchema",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'org.apache.avro.Schema'"
} ]
} ]
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "avroSchema",
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'org.apache.avro.Schema'"
} ]
} ]
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "avroSchema",
"returnType" : {
"type" : "NativeType",
"annotationsJson" : [ {
"java" : [ {
"name" : "class",
"value" : "'org.apache.avro.Schema'"
} ]
} ]
}
}
}, {
"type" : "Method",
"name" : "searchableFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns the field names of all of the fields on a {@link Searchable} type with the {@link Ann.Search} annotation",
"name" : "searchableFields",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "searchableFields",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}
}, {
"type" : "Method",
"name" : "cacheNulls",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return True if the cache is null",
"name" : "cacheNulls",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "cacheNulls",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"type" : "Method",
"name" : "all",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns the {@link TypeMeta} of the types.\n\n@param names\n       Names of the types to filter on. Action will throw an exception if a passed type name is null or invalid.\n       If empty, it returns {@link TypeMeta} for all the types.\n       If not empty, only returns the {@link TypeMeta} for the passed type names.\n@param includeInnerTypes\n       Includes inner {@link TypeMeta}s if set to true",
"name" : "all",
"params" : [ {
"name" : "names",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"name" : "includeInnerTypes",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "all",
"params" : [ {
"name" : "names",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"name" : "includeInnerTypes",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "ReferenceType",
"name" : "TypeMeta"
}
},
"paramNames" : [ "names", "includeInnerTypes" ]
}
} ],
"hasSourceCode" : {
"js-ide-vscode-client-node" : true
}
});
function afterMake() {
const inst = this;
return new Proxy(inst, {
get: (target, property, receiver) => {
if (property == 'fieldTypes') {
return _fieldTypes.bind(inst);
} else if (property == 'methods') {
return _methods.bind(inst);
} else {
return inst[property];
}
}
});
}
function constants() {
let a = [];
this.fieldTypes().forEach(ft => {
if (ft.constant)
a.push(ft);
});
return a;
}
function constant(field, failIfMissing) {
let ft = this.constants().find(c => c.name == field);
if (ft == null && failIfMissing)
throw new Error(`Missing constant ${this.name}.${field}.`);
return ft;
}
function dataFieldTypes() {
let a = [];
this.fieldTypes().forEach(ft => {
if (!ft.constant)
a.push(ft);
});
return a;
}
function dataFieldTypesByName() {
let m = {};
this.dataFieldTypes().forEach(ft => m[ft.name] = ft);
return m;
}
function dataFieldType(field, failIfMissing) {
let ft = this.dataFieldTypesByName()[field];
if (ft == null && failIfMissing)
throw new Error(`Missing data field ${this.name}.${field}.`);
return ft;
}
function extensionTypes(includeSelf) {
return this.extensionTypeNames(includeSelf).mapTo(Type.myReferenceType(), n => C3.pkg().type(n, true));
}
function fieldTypesByName() {
let m = {};
this.fieldTypes().forEach(ft => m[ft.name] = ft);
return m;
}
function fieldType(field, failIfMissing) {
let ft = this.fieldTypesByName()[field];
if (ft == null && failIfMissing)
throw new Error(`Missing field ${this.name}.${field}.`);
return ft;
}
function fieldTypeAtOrdinal(ordinal, failIfMissing) {
let ft = null;
try {
ft = this.dataFieldTypes()[ordinal];
} catch (e) {
if (failIfMissing)
throw new Error(`Missing field for type ${this.name} at ordinal ${ordinal}`);
}
return ft;
}
function fieldTypeBySerName(name, failIfMissing) {
let ft = this.fieldTypesBySerName()[name];
if (ft == null && failIfMissing) {
throw new Error(`Missing field serialized by "${name}" in ${this.name}.`);
}
return ft;
}
function fieldTypesBySerName() {
let m = {};
this.fieldTypes().forEach(ft => m[ft.serName()] = ft);
return m;
}
function innerTypeNames(deep) {
const outerNamePrefix = this.name + '.';
let names = this.$conn.typeSystem().$names.filter(typeName => typeName.startsWith(outerNamePrefix))
.map(fullName => fullName.substring(outerNamePrefix.length));
if (!deep) {
names = names.filter(typeName => _splitName(typeName).length === 1);
}
return new Set(names);
}
function innerType(innerType, failIfMissing) {
return C3.pkg().typeMeta(this.name + "." + innerType, failIfMissing);
}
function innerTypeToType(innerType, failIfMissing) {
return C3.pkg().type(this.name + "." + innerType, failIfMissing);
}
function innerTypes(deep) {
return this.innerTypeNames(deep).map(n => this.innerType(n, true));
}
function innerTypeName() {
let parts = _splitName(this.name);
if (parts.length > 1) return parts[parts.length - 1];
}
function instantiate(...args) {
if (args.length < 1) {
return this.toType()._instantiate();
}
if (typeof args[0] === 'string' && this.isA(StringSerializable)) {
return this.toType().fromString(args[0]);
}
return this.toType()._instantiate(args[0]);
}
function isA(other) {
if (typeof other === 'object' && typeof other.name === 'function') {
other = other.name();
}
if (typeof other === 'string') {
other = other.replace(/<.*>\./g, '.').replace(/<.*$/, '');
}
if (typeof other === 'function' && other.name) {
other = other.name;
}
return other == this.name || other == this.prototypeName() || this.mixin(other) != null;
}
function isInnerType() {
return this.innerTypeName() != null;
}
function methodsByName() {
let m = {};
this.methods().forEach(ft => m[ft.name] = ft);
return m;
}
function method(field, failIfMissing) {
let m = this.methodsByName()[field];
if (m == null && failIfMissing) {
throw new Error(`Missing method ${this.name}.${field}.`);
}
return m;
}
function mixins(order) {
if (this.$cache.mixins && (order == null || order === 'MIXIN')) {
return this.$cache.mixins;
}
return this.$conn.typeSystem().call(this.type().name(), 'mixins', this, order);
}
function mixin(name, failIfMissing) {
let mx = this.mixins().find(mx => mx.meta().prototypeName() == name);
if (mx == null && failIfMissing) {
throw new Error(`Missing mixin ${name} of ${this.name}.`);
}
return mx;
}
function outerType() {
let name = this.outerTypeName();
if (name != null) return C3.pkg().type(name, true);
}
function outerTypeName() {
let parts = _splitName(this.name);
if (parts.length > 1) return parts.slice(0, parts.length - 1).join('.');
}
function outerRootType() {
let name = this.outerRootTypeName();
if (name != null) return C3.pkg().type(name, true);
}
function outerRootTypeName() {
let parts = _splitName(this.name);
if (parts.length > 1) return parts[0];
}
function subTypes(includeSelf) {
return this.subTypeNames(includeSelf).mapTo(Type.myReferenceType(), n => C3.pkg().type(n, true));
}
function toJson(...args) {
return { ...this };
}
function toTypedJson(...args) {
let jsn = this.toJson(args);
jsn['type'] = 'TypeMeta';
return jsn;
}
function typeSerName() {
let m = this.method("type", false);
return m != null ? this.fieldTypeBySerName(m.serName(), false) != null ? "$type" : m.serName()
: null;
}
function varBinding() {
let varName, failIfUnbound, bind, name;
if (arguments.length >= 2 && typeof arguments[1] === 'string') {
name = typeof arguments[0] == 'object' ? arguments[0].name : arguments[0];
varName = arguments[1];
failIfUnbound = arguments[2];
let type = this.mixin(name);
if (type == null && failIfUnbound)
throw new Error(`Missing mixin "${name}" on ${this.name}.`);
bind = (type != null) ? type.meta().varBindings.get(varName) : undefined;
} else {
varName = arguments[0];
failIfUnbound = arguments[1];
bind = this.varBindings.get(varName);
}
if (bind == null && failIfUnbound) {
throw new Error(`Missing binding of "${varName}" on ${this.name}.`);
}
return bind;
}
function _fieldTypes(order) {
return this.$cache.get('fieldTypes$parented', false, () => {
const orig = this.fieldTypes(order);
const type = this.toType();
orig.forEach(ft => ft.$parent = type);
return orig;
});
}
function _methods(order) {
return this.$cache.get('methods$parented', false, () => {
const orig = this.methods(order);
const type = this.toType();
orig.forEach(m => {
m.$parent = type;
m.overloads().forEach(mt => mt.$parent = m);
});
return orig;
});
}
function _splitName(name) {
const parts = [];
let cur = '';
let open = 0;
for (let c of name) {
if (c == '<') {
open++;
cur += c;
} else if (c == '>') {
open--;
cur += c;
} else if (c == '.' && open < 1) {
parts.push(cur);
cur = '';
} else {
cur += c;
}
}
parts.push(cur);
return parts;
}
"use strict";
function $Builder(type, inst) {
let fields = {};
this.$type = type;
this.$setup = function (_inst) {};
this.$findType = function (type, _fields) { return type; };
this.$makeField = function (ft, value) { return value; };
this.$afterMake = function (inst) { return inst; };
if (inst != null) {
Object.keys(inst).forEach(fn => fields[fn] = inst[fn]);
}
Object.defineProperties(this, {
$objType: { value: type },
$onbuild: { value: undefined, writable: true },
$fields: { value: fields, configurable: true },
$refs: { value: {}, configurable: true },
$arrays: { value: {}, configurable: true },
$sets: { value: {}, configurable: true },
$maps: { value: {}, configurable: true },
$builder: { value: true },
});
}
$Builder.prototype.a = function a(field, element, doNotConvert) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isArray()) {
throw Err.invalidCall('ObjBuilder.a', `non-array field ${field.name}`);
}
let b = this.$arrays[field.name];
if (b == null) {
b = this.$fields[field.name];
if (b == null || !b.$builder) {
b = this.$arrays[field.name] = vt.makeBuilder(b);
}
}
if (arguments.length == 1) {
return b;
} else if (arguments.length == 2 || arguments.length == 3) {
b.add(element);
return this;
} else {
throw Err.invalidCall('ObjBuilder.a', 'expected field and element');
}
};
$Builder.prototype.clear = function clear() {
Object.defineProperty(this, '$fields', { value: {}, configurable: true });
Object.defineProperty(this, "$refs", { value: {}, configurable: true });
Object.defineProperty(this, "$arrays", { value: {}, configurable: true });
Object.defineProperty(this, "$sets", { value: {}, configurable: true });
Object.defineProperty(this, "$maps", { value: {}, configurable: true });
};
$Builder.prototype.constrain = function constrain() {
throw new Error('Unsupported operation ObjBuilder.constrain for JavaScript.');
};
$Builder.prototype.current = function current() {
let init = {};
Object.keys(this.$fields).forEach(p => {
let v = this.$fields[p];
if (v != null && v.$builder)
v = v.current();
init[p] = v;
});
return this.$objType.make(init);
};
$Builder.prototype.isEmpty = function isEmpty() {
return Object.keys(this.$fields).length === 0 &&
Object.keys(this.$refs).length === 0 &&
Object.keys(this.$arrays).length === 0 &&
Object.keys(this.$sets).length === 0 &&
Object.keys(this.$maps).length === 0;
};
$Builder.prototype.m = function m(field, key, element, doNotConvert) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isMap()) {
throw new Error(`Invalid call to ObjBuilder.m: non-map field ${field.name}.`);
}
let b = this.$maps[field.name];
if (b == null) {
b = this.$fields[field.name];
if (b == null || !b.$builder) {
b = this.$maps[field.name] = vt.makeBuilder(b);
}
}
if (arguments.length == 1) {
return b;
} else if (arguments.length == 3 || arguments.length == 4) {
b.put(key, element);
return this;
} else {
throw new Error(`Invalid call to ObjBuilder.m: expected field, key and value.`);
}
};
$Builder.prototype.mergeJson = function mergeJson(json) {
if (json != null) {
Object.keys(json).forEach(fn => this.v(fn, json[fn], false));
}
return this;
};
$Builder.prototype.mergeObj = function mergeObj(other, otherFieldsFilter) {
if (other == null) {
return this;
}
if (arguments.length == 1) {
if (this.objType() == other.type()) {
other.eachFieldValue((ft, v) => this.v(ft, v));
} else {
other.eachFieldValue((ft, v) => this.v(this.objType().fieldType(ft.name), v));
}
return this;
} else if (arguments.length == 2) {
if (other.instanceOf(otherFieldsFilter)) {
const tm = otherFieldsFilter.meta();
other.eachFieldValue((ft, v) => {
if (tm.fieldType(ft.name) != null)
this.v(ft, v);
});
}
return this;
}
throw new Error(`Invalid call to ObjBuilder.mergeObj: expected other and otherFieldsFilter.`);
};
$Builder.prototype.objType = function objType() {
return this.$objType;
};
$Builder.prototype.r = function r(field) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isReference()) {
throw new Error(`Invalid call to ObjBuilder.r: non-reference field ${field.name}.`);
}
let type = vt.dereference(true);
let b = this.$refs[field.name];
if (b == null) {
if (b == null || !b.$builder) {
b = this.$refs[field.name] = type.builder().mergeObj(b);
}
}
return b;
};
$Builder.prototype.s = function s(field, element, doNotConvert) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isSet()) {
throw Err.invalidCall('ObjBuilder.a', `non-array field ${field.name}`);
}
let b = this.$sets[field.name];
if (b == null) {
b = this.$fields[field.name];
if (b == null || !b.$builder) {
b = this.$sets[field.name] = vt.makeBuilder(b);
}
}
if (arguments.length == 1) {
return b;
} else if (arguments.length == 2 || arguments.length == 3) {
b.add(element);
return this;
} else {
throw Err.invalidCall('ObjBuilder.s', 'expected field and element');
}
};
$Builder.prototype.setFields = function setFields(fields, doNotConvert) {
if (fields != null) {
for (let [name, v] of fields) {
const ft = this.$objType.meta().fieldType(name, true);
if (v == null) {
delete this.$fields[ft.name];
} else {
this.$fields[ft.name] = v;
}
}
}
return this;
};
$Builder.prototype.v = function v(field, value, doNotConvert) {
if (arguments.length < 2) {
throw new Error(`Invalid call to ObjBuilder.v: expected field and value.`);
}
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
this.$fields[field.name] = value;
return this;
};
$Builder.prototype.build = function build() {
const type = this.$findType(this.$type, this.$fields);
let inst = Object.create(type.$objProto);
this.$setup(inst);
Object.keys(this.$refs).forEach(fn => {
this.$fields[fn] = this.$refs[fn].build();
});
Object.keys(this.$arrays).forEach(fn => {
this.$fields[fn] = this.$arrays[fn].build();
});
Object.keys(this.$sets).forEach(fn => {
this.$fields[fn] = this.$sets[fn].build();
});
Object.keys(this.$maps).forEach(fn => {
this.$fields[fn] = this.$maps[fn].build();
});
Object.keys(this.$fields).forEach(fn => {
let ft = type.$init.fieldTypes.find(fieldType => fieldType.name === fn && !fieldType.constant);
if (ft && inst[fn] === undefined && this.$fields[fn] != null) {
inst[fn] = this.$makeField(ft, this.$fields[fn]);
}
});
type.$init.fieldTypes.forEach(ft => {
if (!ft.constant && !_hasOwnProperty(inst, ft.name)) {
let vt = ft.valueType;
if (vt.modifier !== 'PRESERVES_EMPTY') {
let v = this.$makeField(ft, null);
if (v != null) {
inst[ft.name] = v;
}
}
}
});
if (typeof afterMake === 'function' && afterMake !== $global.afterMake && !$Builder.$afterMake) {
Object.defineProperty($Builder, '$afterMake', { value: true, configurable: true });
try {
inst = afterMake.call(inst);
} finally {
delete $Builder.$afterMake;
}
}
inst = this.$afterMake(inst);
Object.freeze(inst);
if (this.$onbuild) {
this.$onbuild(inst);
}
return inst;
};
$Builder.prototype.type = function type() { return $type; };
$Builder.prototype.v = function v(field, value, doNotConvert) {
if (arguments.length < 2) {
throw new Error('Invalid call to ObjBuilder.v: expected field and value.');
}
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
this.$fields[field.name] = value;
return this;
};
$Builder.prototype.metadataPath = function (v) {
if (v == null) {
delete this.$fields.metadataPath;
} else {
this.$fields.metadataPath = v;
}
return this;
};
$Builder.prototype.package = function (v) {
if (v == null) {
delete this.$fields.package;
} else {
this.$fields.package = v;
}
return this;
};
$Builder.prototype.packageSubPath = function (v) {
if (v == null) {
delete this.$fields.packageSubPath;
} else {
this.$fields.packageSubPath = v;
}
return this;
};
$Builder.prototype.pkg = function (v) {
if (v == null) {
delete this.$fields.pkg;
} else {
this.$fields.pkg = v;
}
return this;
};
$Builder.prototype.name = function (v) {
if (v == null) {
delete this.$fields.name;
} else {
this.$fields.name = v;
}
return this;
};
$Builder.prototype.varBindings = function (v) {
if (v == null) {
delete this.$fields.varBindings;
} else {
this.$fields.varBindings = v;
}
return this;
};
$Builder.prototype.annotationsJson = function (v) {
if (v == null) {
delete this.$fields.annotationsJson;
} else {
this.$fields.annotationsJson = v;
}
return this;
};
$Builder.prototype.doc = function (v) {
if (v == null) {
delete this.$fields.doc;
} else {
this.$fields.doc = v;
}
return this;
};
$Builder.prototype.docSingleLine = function (v) {
if (v == null) {
delete this.$fields.docSingleLine;
} else {
this.$fields.docSingleLine = v;
}
return this;
};
$Builder.prototype.declaredNative = function (v) {
if (v == null) {
delete this.$fields.declaredNative;
} else {
this.$fields.declaredNative = v;
}
return this;
};
$Builder.prototype.declaredEntity = function (v) {
if (v == null) {
delete this.$fields.declaredEntity;
} else {
this.$fields.declaredEntity = v;
}
return this;
};
$Builder.prototype.declaredEnum = function (v) {
if (v == null) {
delete this.$fields.declaredEnum;
} else {
this.$fields.declaredEnum = v;
}
return this;
};
$Builder.prototype.declaredUnionAlts = function (v) {
if (v == null) {
delete this.$fields.declaredUnionAlts;
} else {
this.$fields.declaredUnionAlts = v;
}
return this;
};
$Builder.prototype.declaredDuck = function (v) {
if (v == null) {
delete this.$fields.declaredDuck;
} else {
this.$fields.declaredDuck = v;
}
return this;
};
$Builder.prototype.declaredAbstract = function (v) {
if (v == null) {
delete this.$fields.declaredAbstract;
} else {
this.$fields.declaredAbstract = v;
}
return this;
};
$Builder.prototype.declaredInline = function (v) {
if (v == null) {
delete this.$fields.declaredInline;
} else {
this.$fields.declaredInline = v;
}
return this;
};
$Builder.prototype.declaredFinal = function (v) {
if (v == null) {
delete this.$fields.declaredFinal;
} else {
this.$fields.declaredFinal = v;
}
return this;
};
$Builder.prototype.declaredPrivate = function (v) {
if (v == null) {
delete this.$fields.declaredPrivate;
} else {
this.$fields.declaredPrivate = v;
}
return this;
};
$Builder.prototype.declaredExtendable = function (v) {
if (v == null) {
delete this.$fields.declaredExtendable;
} else {
this.$fields.declaredExtendable = v;
}
return this;
};
$Builder.prototype.declaredNotExtendable = function (v) {
if (v == null) {
delete this.$fields.declaredNotExtendable;
} else {
this.$fields.declaredNotExtendable = v;
}
return this;
};
$Builder.prototype.declaredExtendsRefType = function (v) {
if (v == null) {
delete this.$fields.declaredExtendsRefType;
} else {
this.$fields.declaredExtendsRefType = v;
}
return this;
};
$Builder.prototype.declaredNotMixable = function (v) {
if (v == null) {
delete this.$fields.declaredNotMixable;
} else {
this.$fields.declaredNotMixable = v;
}
return this;
};
$Builder.prototype.declaredMixinRefTypes = function (v) {
if (v == null) {
delete this.$fields.declaredMixinRefTypes;
} else {
this.$fields.declaredMixinRefTypes = v;
}
return this;
};
$Builder.prototype.declaredRemix = function (v) {
if (v == null) {
delete this.$fields.declaredRemix;
} else {
this.$fields.declaredRemix = v;
}
return this;
};
$Builder.prototype.declaredNotRemixable = function (v) {
if (v == null) {
delete this.$fields.declaredNotRemixable;
} else {
this.$fields.declaredNotRemixable = v;
}
return this;
};
$Builder.prototype.declaredRemixAlias = function (v) {
if (v == null) {
delete this.$fields.declaredRemixAlias;
} else {
this.$fields.declaredRemixAlias = v;
}
return this;
};
$Builder.prototype.declaredTypeKey = function (v) {
if (v == null) {
delete this.$fields.declaredTypeKey;
} else {
this.$fields.declaredTypeKey = v;
}
return this;
};
$Builder.prototype.declaredFieldTypes = function (v) {
if (v == null) {
delete this.$fields.declaredFieldTypes;
} else {
this.$fields.declaredFieldTypes = v;
}
return this;
};
$Builder.prototype.declaredInnerTypes = function (v) {
if (v == null) {
delete this.$fields.declaredInnerTypes;
} else {
this.$fields.declaredInnerTypes = v;
}
return this;
};
$Builder.prototype.declaredNativeRemixes = function (v) {
if (v == null) {
delete this.$fields.declaredNativeRemixes;
} else {
this.$fields.declaredNativeRemixes = v;
}
return this;
};
$Builder.prototype.declaredRemixes = function (v) {
if (v == null) {
delete this.$fields.declaredRemixes;
} else {
this.$fields.declaredRemixes = v;
}
return this;
};
$Builder.prototype.declaredSourceCode = function (v) {
if (v == null) {
delete this.$fields.declaredSourceCode;
} else {
this.$fields.declaredSourceCode = v;
}
return this;
};
$Builder.prototype.declaredVars = function (v) {
if (v == null) {
delete this.$fields.declaredVars;
} else {
this.$fields.declaredVars = v;
}
return this;
};
$Builder.prototype.declaredNativeRequirement = function (v) {
if (v == null) {
delete this.$fields.declaredNativeRequirement;
} else {
this.$fields.declaredNativeRequirement = v;
}
return this;
};
$Builder.prototype.declaredSchemaName = function (v) {
if (v == null) {
delete this.$fields.declaredSchemaName;
} else {
this.$fields.declaredSchemaName = v;
}
return this;
};
$Builder.prototype.defaultActionRequirement = function (v) {
if (v == null) {
delete this.$fields.defaultActionRequirement;
} else {
this.$fields.defaultActionRequirement = v;
}
return this;
};
$Builder.prototype._staticsCache = function (v) {
if (v == null) {
delete this.$fields._staticsCache;
} else {
this.$fields._staticsCache = v;
}
return this;
};
$Builder.prototype._sourceCodeCache = function (v) {
if (v == null) {
delete this.$fields._sourceCodeCache;
} else {
this.$fields._sourceCodeCache = v;
}
return this;
};
let $logger;
function log() {
if ($logger == null) {
$logger = C3.Logger.for($type.name());
}
return $logger;
};
const $type = new Type$Proto($conn, $init);
const $proto = new (function TypeMeta() {});
Object.defineProperty($proto, '$conn', { value: $conn });
Object.defineProperties($type, {
$objProto: { value: $proto },
$withType: { value: true }
});
Object.defineProperty($type, Symbol.hasInstance, { value: function(inst) { return inst != null && inst.$c3inst && inst.$c3inst.meta().isA(this); } });
$proto.outerRootTypeName = outerRootTypeName;
$proto.instantiate = instantiate;
$proto.fieldTypesByName = fieldTypesByName;
$proto.typeSerName = typeSerName;
$proto.dataFieldTypes = dataFieldTypes;
$proto.afterMake = afterMake;
$proto.fieldType = fieldType;
$proto.mixins = mixins;
$proto.extensionTypes = extensionTypes;
$proto.innerTypes = innerTypes;
$proto.fieldTypeAtOrdinal = fieldTypeAtOrdinal;
$proto.innerType = innerType;
$proto.outerRootType = outerRootType;
$proto.varBinding = varBinding;
$proto.dataFieldTypesByName = dataFieldTypesByName;
$proto.method = method;
$proto.dataFieldType = dataFieldType;
$proto.constant = constant;
$proto.innerTypeToType = innerTypeToType;
$proto.innerTypeName = innerTypeName;
$proto.fieldTypesBySerName = fieldTypesBySerName;
$proto.methodsByName = methodsByName;
$proto.fieldTypeBySerName = fieldTypeBySerName;
$proto.innerTypeNames = innerTypeNames;
$proto.mixin = mixin;
$proto.constants = constants;
$proto.isInnerType = isInnerType;
$proto.subTypes = subTypes;
$proto.isA = isA;
$proto.outerTypeName = outerTypeName;
$proto.outerType = outerType;
$type.buildArray = function buildArray(builder) {
const b = this.arrayBuilder();
builder(b);
return b.build();
};
$type.buildMap = function buildMap(builder) {
const b = this.mapBuilder();
builder(b);
return b.build();
};
$type.builder = function builder(inst) { return new $Builder(this, inst); };
Object.defineProperty($type.builder, '$std', { value: true });
$type._instantiate = function _instantiate(fields) {
if (typeof fields === 'string') {
return this.fromString(fields);
}
return this.builder(fields).build();
};
$type.buildSet = function buildSet(builder) {
const b = this.setBuilder();
builder(b);
return b.build();
};
$proto.type = function type() { return $type; };
$proto.log = log;
$proto.withMetadataPath = function(v) { return this.type().builder(this).metadataPath(v).build(); };
$proto.withoutMetadataPath = function() { return this.type().builder(this).metadataPath().build(); };
$proto.withPackage = function(v) { return this.type().builder(this).package(v).build(); };
$proto.withoutPackage = function() { return this.type().builder(this).package().build(); };
$proto.withPackageSubPath = function(v) { return this.type().builder(this).packageSubPath(v).build(); };
$proto.withoutPackageSubPath = function() { return this.type().builder(this).packageSubPath().build(); };
$proto.withPkg = function(v) { return this.type().builder(this).pkg(v).build(); };
$proto.withoutPkg = function() { return this.type().builder(this).pkg().build(); };
$proto.withName = function(v) { return this.type().builder(this).name(v).build(); };
$proto.withoutName = function() { return this.type().builder(this).name().build(); };
$proto.withVarBindings = function(v) { return this.type().builder(this).varBindings(v).build(); };
$proto.withoutVarBindings = function() { return this.type().builder(this).varBindings().build(); };
$proto.withAnnotationsJson = function(v) { return this.type().builder(this).annotationsJson(v).build(); };
$proto.withoutAnnotationsJson = function() { return this.type().builder(this).annotationsJson().build(); };
$proto.withDoc = function(v) { return this.type().builder(this).doc(v).build(); };
$proto.withoutDoc = function() { return this.type().builder(this).doc().build(); };
$proto.withDocSingleLine = function(v) { return this.type().builder(this).docSingleLine(v).build(); };
$proto.withoutDocSingleLine = function() { return this.type().builder(this).docSingleLine().build(); };
$proto.withDeclaredNative = function(v) { return this.type().builder(this).declaredNative(v).build(); };
$proto.withoutDeclaredNative = function() { return this.type().builder(this).declaredNative().build(); };
$proto.withDeclaredEntity = function(v) { return this.type().builder(this).declaredEntity(v).build(); };
$proto.withoutDeclaredEntity = function() { return this.type().builder(this).declaredEntity().build(); };
$proto.withDeclaredEnum = function(v) { return this.type().builder(this).declaredEnum(v).build(); };
$proto.withoutDeclaredEnum = function() { return this.type().builder(this).declaredEnum().build(); };
$proto.withDeclaredUnionAlts = function(v) { return this.type().builder(this).declaredUnionAlts(v).build(); };
$proto.withoutDeclaredUnionAlts = function() { return this.type().builder(this).declaredUnionAlts().build(); };
$proto.withDeclaredDuck = function(v) { return this.type().builder(this).declaredDuck(v).build(); };
$proto.withoutDeclaredDuck = function() { return this.type().builder(this).declaredDuck().build(); };
$proto.withDeclaredAbstract = function(v) { return this.type().builder(this).declaredAbstract(v).build(); };
$proto.withoutDeclaredAbstract = function() { return this.type().builder(this).declaredAbstract().build(); };
$proto.withDeclaredInline = function(v) { return this.type().builder(this).declaredInline(v).build(); };
$proto.withoutDeclaredInline = function() { return this.type().builder(this).declaredInline().build(); };
$proto.withDeclaredFinal = function(v) { return this.type().builder(this).declaredFinal(v).build(); };
$proto.withoutDeclaredFinal = function() { return this.type().builder(this).declaredFinal().build(); };
$proto.withDeclaredPrivate = function(v) { return this.type().builder(this).declaredPrivate(v).build(); };
$proto.withoutDeclaredPrivate = function() { return this.type().builder(this).declaredPrivate().build(); };
$proto.withDeclaredExtendable = function(v) { return this.type().builder(this).declaredExtendable(v).build(); };
$proto.withoutDeclaredExtendable = function() { return this.type().builder(this).declaredExtendable().build(); };
$proto.withDeclaredNotExtendable = function(v) { return this.type().builder(this).declaredNotExtendable(v).build(); };
$proto.withoutDeclaredNotExtendable = function() { return this.type().builder(this).declaredNotExtendable().build(); };
$proto.withDeclaredExtendsRefType = function(v) { return this.type().builder(this).declaredExtendsRefType(v).build(); };
$proto.withoutDeclaredExtendsRefType = function() { return this.type().builder(this).declaredExtendsRefType().build(); };
$proto.withDeclaredNotMixable = function(v) { return this.type().builder(this).declaredNotMixable(v).build(); };
$proto.withoutDeclaredNotMixable = function() { return this.type().builder(this).declaredNotMixable().build(); };
$proto.withDeclaredMixinRefTypes = function(v) { return this.type().builder(this).declaredMixinRefTypes(v).build(); };
$proto.withoutDeclaredMixinRefTypes = function() { return this.type().builder(this).declaredMixinRefTypes().build(); };
$proto.withDeclaredRemix = function(v) { return this.type().builder(this).declaredRemix(v).build(); };
$proto.withoutDeclaredRemix = function() { return this.type().builder(this).declaredRemix().build(); };
$proto.withDeclaredNotRemixable = function(v) { return this.type().builder(this).declaredNotRemixable(v).build(); };
$proto.withoutDeclaredNotRemixable = function() { return this.type().builder(this).declaredNotRemixable().build(); };
$proto.withDeclaredRemixAlias = function(v) { return this.type().builder(this).declaredRemixAlias(v).build(); };
$proto.withoutDeclaredRemixAlias = function() { return this.type().builder(this).declaredRemixAlias().build(); };
$proto.withDeclaredTypeKey = function(v) { return this.type().builder(this).declaredTypeKey(v).build(); };
$proto.withoutDeclaredTypeKey = function() { return this.type().builder(this).declaredTypeKey().build(); };
$proto.withDeclaredFieldTypes = function(v) { return this.type().builder(this).declaredFieldTypes(v).build(); };
$proto.withoutDeclaredFieldTypes = function() { return this.type().builder(this).declaredFieldTypes().build(); };
$proto.withDeclaredInnerTypes = function(v) { return this.type().builder(this).declaredInnerTypes(v).build(); };
$proto.withoutDeclaredInnerTypes = function() { return this.type().builder(this).declaredInnerTypes().build(); };
$proto.withDeclaredNativeRemixes = function(v) { return this.type().builder(this).declaredNativeRemixes(v).build(); };
$proto.withoutDeclaredNativeRemixes = function() { return this.type().builder(this).declaredNativeRemixes().build(); };
$proto.withDeclaredRemixes = function(v) { return this.type().builder(this).declaredRemixes(v).build(); };
$proto.withoutDeclaredRemixes = function() { return this.type().builder(this).declaredRemixes().build(); };
$proto.withDeclaredSourceCode = function(v) { return this.type().builder(this).declaredSourceCode(v).build(); };
$proto.withoutDeclaredSourceCode = function() { return this.type().builder(this).declaredSourceCode().build(); };
$proto.withDeclaredVars = function(v) { return this.type().builder(this).declaredVars(v).build(); };
$proto.withoutDeclaredVars = function() { return this.type().builder(this).declaredVars().build(); };
$proto.withDeclaredNativeRequirement = function(v) { return this.type().builder(this).declaredNativeRequirement(v).build(); };
$proto.withoutDeclaredNativeRequirement = function() { return this.type().builder(this).declaredNativeRequirement().build(); };
$proto.withDeclaredSchemaName = function(v) { return this.type().builder(this).declaredSchemaName(v).build(); };
$proto.withoutDeclaredSchemaName = function() { return this.type().builder(this).declaredSchemaName().build(); };
$proto.withDefaultActionRequirement = function(v) { return this.type().builder(this).defaultActionRequirement(v).build(); };
$proto.withoutDefaultActionRequirement = function() { return this.type().builder(this).defaultActionRequirement().build(); };
$proto.with_staticsCache = function(v) { return this.type().builder(this)._staticsCache(v).build(); };
$proto.without_staticsCache = function() { return this.type().builder(this)._staticsCache().build(); };
$proto.with_sourceCodeCache = function(v) { return this.type().builder(this)._sourceCodeCache(v).build(); };
$proto.without_sourceCodeCache = function() { return this.type().builder(this)._sourceCodeCache().build(); };
$proto.toJSON = function toJSON() { return this.toTypedJson(); };
Object.freeze($type);
Object.freeze($proto);
return $type;
})());
$conn._registerType((function() {
const $init = _deepFreeze({
"type" : "TypeMeta",
"metadataPath" : "platform/src/typesys/type/Annotatable.c3typ",
"package" : "platform",
"packageSubPath" : "typesys.type",
"name" : "Annotatable",
"doc" : "Metadata objects can be annotated to specify additional behavior or constraints. Annotations are themselves types\nthat mix {@link Annotation} and are marked with `@annotation`.\n\n```c3typ\n@annotation\ntype Ann.Ser mixes Annotation {\n```\n\nAnnotations are a way of creating custom metadata for purposes not supported directly by the type system itself.\nFor example, the core metadata for a type is maintained as fields of {@link TypeMeta}, but often there are\nextra things that can be specified about types, and those can be done with annotations.\n\nFor example, extra information on serialization can be added to a field definition:\n```type\n  @ser(name='type')\n  kind: string enum WidgetType\n```\n\nThis in effect extends the type system. These annotations can appear in any package.\n\n@see Type\n@see Ann.Annotation",
"declaredAbstract" : true,
"declaredMixinRefTypes" : [ {
"name" : "Typesys"
} ],
"declaredFieldTypes" : [ {
"doc" : "The set of annotations defined on this element of metadata represented as json value.",
"name" : "annotationsJson",
"valueType" : {
"type" : "JsonType",
"name" : "json"
}
}, {
"doc" : "Override this method to return the merged set of annotations from itself and its hierarchy\nE.g.\n```type\n  @config(folder=\"x\")\n  type A {\n  }\n  @config(secret=true)\n  type B mixes A\n```\n=> return config(secret=true, folder=\"x\") for type B\nIf not overriden, by default this returns #annotationJson",
"name" : "mergedAnnotationsJson",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "JsonType",
"name" : "json"
},
"abstract" : true,
"member" : true
}
}, {
"doc" : "The declared annotations for this metadata element.",
"name" : "declaredAnnotations",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotations"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "The annotations for this metadata element.",
"name" : "annotations",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotations"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether this metadata element has any annotation.",
"name" : "hasAnnotations",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Whether this metadata element has annotation with provided name.",
"name" : "hasAnnotation",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Whether this metadata element has annotation field value.",
"name" : "hasAnnotationValue",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "annField",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "@return annotation with provided name",
"name" : "annotation",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Annotation"
},
"member" : true,
"actionRequirementNames" : [ "java", "js" ]
}
}, {
"doc" : "@return annotation value for provided annotation name and annotation field",
"name" : "annotationValue",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "annField",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "AnyType"
},
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ]
}
}, {
"doc" : "Add an annotation to the given metadata",
"name" : "withAnnotation",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotation"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"member" : true
}
}, {
"doc" : "Add an annotation to the given metadata\n@param ann\n        annotation to add\n@param annField\n        which field on the annotation needs to be set\n@param value\n        value for the field",
"name" : "withAnnotation",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "annField",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"member" : true
}
}, {
"doc" : "Whether the specified instances have same annotations.",
"name" : "haveSameAnnotations",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "a1",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Annotatable"
}
}, {
"name" : "a2",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"doc" : "Return the JSON for annotations that can be inherited by children of this element of metadata. Annotations are\nnormally inherited, but ones marked with {@link Annotation#noInherit} will not be.",
"name" : "inheritableAnnotationsJson",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "JsonType",
"name" : "json"
},
"member" : true
}
} ],
"isWithType" : true,
"isObj" : true,
"isMutable" : false,
"isStateful" : false,
"isSingleton" : false,
"isDefaultInstance" : false,
"isAbstract" : true,
"hasEventStream" : false,
"isGeneric" : false,
"isNativeRemix" : false,
"hasVarBindings" : false,
"prototypeName" : "Annotatable",
"typeSerName" : "type",
"hasSerNameFields" : false,
"annotations" : {
"type" : "Annotations"
},
"mixins" : [ "Typesys", "WithType", "Value", "Obj", "Serializable", "Fingerprintable", "MemoryMeasurable" ],
"referenceType" : {
"type" : "ReferenceType",
"name" : "Annotatable"
},
"mixinsWithSourceCode" : {
"js-ide-vscode-client-node" : [ "WithType", "Obj" ]
},
"fieldTypes" : [ {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"doc" : "The metadata path where the parent type's declaration file is located:\nFormat: meta://<package>/[gen|test]/src/<packageSubPath>/<name>.c3typ\nE.g. for the given package folder structure:\n```\nmyRepo\n |\n -  myPkg\n     |\n     -  src\n         |\n         - folder1\n             |\n             - folder2\n                 |\n                 - SomeType1.c3typ\n         - SomeType3.c3typ\n     -  test\n         |\n          - src\n             |\n             - SomeType2.c3typ\n     -  gen\n         |\n          - src\n             |\n             - SomeType4.c3typ\n```\nFor SomeType1.c3typ will return -> meta://myPkg/src/folder1/folder2/SomeType1.c3typ\nFor SomeType3.c3typ will return -> meta://myPkg/src/SomeType3.c3typ\nFor SomeType2.c3typ will return -> meta://myPkg/test/src/SomeType2.c3typ\nFor SomeType4.c3typ will return -> meta://myPkg/gen/src/SomeType4.c3typ\n\n@see #package\n@see #packageSubPath",
"name" : "metadataPath",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"suppress" : true
}
},
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"doc" : "The name of the package where this type was declared.\n\nFor example, if package \"app\", depends on \"industry\", which depends on \"foundation\", provisioning app will bring\nin the types in the industry and foundation packages as well. This means that the `package` of the Location\ntype will be foundation, even if it gets remixed by industry (or even app).\n\n@see #metadataPath\n@see #packageSubPath",
"name" : "package",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"suppress" : true
}
},
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"doc" : "Dot (\".\") separated relative path of the folder where this type's declaration file is located in the package\nE.g. for the given structure\n```\nmyRepo\n |\n -  myPkg\n     |\n     -  src\n         |\n         - folder1\n             |\n             - folder2\n                 |\n                 - SomeType1.c3typ\n         - SomeType3.c3typ\n     -  test\n         |\n          - src\n             |\n             - SomeType2.c3typ\n     -  gen\n         |\n          - src\n             |\n             - SomeType4.c3typ\n```\nFor SomeType1.c3typ will return -> folder1.folder2\nFor SomeType3.c3typ will return -> \"\" (empty string)\nFor SomeType3.c3typ will return -> \"\" (empty string)\nFor SomeType4.c3typ will return -> \"\" (empty string)\n\n@see #metadataPath\n@see #package",
"name" : "packageSubPath",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"suppress" : true
}
},
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"ser" : [ {
"name" : "hidden",
"value" : true
} ]
}, {
"constraint" : [ {
"name" : "readOnly",
"value" : true
} ]
} ],
"doc" : "@return C3 application package this Type System element belongs to",
"name" : "pkg",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"ser" : [ {
"name" : "hidden",
"value" : true
} ]
}, {
"constraint" : [ {
"name" : "readOnly",
"value" : true
} ]
} ],
"annotationJsonByName" : {
"ser" : [ {
"name" : "hidden",
"value" : true
} ],
"constraint" : [ {
"name" : "readOnly",
"value" : true
} ]
},
"constraint" : {
"type" : "Ann.Constraint",
"readOnly" : true
},
"ser" : {
"type" : "Ann.Ser",
"hidden" : true
}
},
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg",
"isNumber" : false,
"instanceType" : "Pkg"
}
}, {
"type" : "FieldType",
"doc" : "The set of annotations defined on this element of metadata represented as json value.",
"name" : "annotationsJson",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations"
},
"valueType" : {
"type" : "JsonType",
"name" : "json",
"isNumber" : false
}
} ],
"methods" : [ {
"type" : "Method",
"name" : "type",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "C3 Type of this instance.",
"name" : "type",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "type",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "replaceType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns new instance with all references to old type, including result of #type, replaced with new type. If new\ntype does not contain fields from old or field value types are not convertable then drops the field.\n\nThis method is used during live metadata update",
"name" : "replaceType",
"params" : [ {
"name" : "old",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "new",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "replaceType",
"params" : [ {
"name" : "old",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "new",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"paramNames" : [ "old", "new" ]
}
}, {
"type" : "Method",
"name" : "super",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithType" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithType"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : " Produce a calling proxy that represents the content of all Obj type's mixins, but not the type itself. This is\n useful for redispatching **member** methods reimplemented on this type to a parent implementation:\n ```js\n function toString() {\n   return this.super().toString() + ', x=' + this.x;\n }\n ```\n\n ```py\n def toString(this):\n    return this.super().toString() + ', x=' + this.x\n```\n\n To redispatch **static** methods, see {@link Type#super}.\n\n Note that this not the same as the language-specific `super` keyword because it works through the type system and\n supports multiple mixins. It behaves like the Python `super()` function, except called on the instance rather than\n globally.\n\n If `mixin` is the implementing type in a client implementation, this will delegate the call to the server.\n This can be used to create a local implementation \"around\" the server implementation for additional caching or\n other local state management.\n\n @param mixin if specified, this mixin is used instead or an error is thrown\n @return \"super\" calling proxy for this object\n\n @see Type.super",
"name" : "super",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "ReferenceType",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "super",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "ReferenceType",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"paramNames" : [ "mixin" ]
},
"$nearestImplementedOn" : "WithType"
}, {
"type" : "Method",
"name" : "toJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a JSON object.\n\n@return JSON object representation\n\n@see #fromJson",
"name" : "toJson",
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"name" : "toJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"name" : "toJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
} ]
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ]
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"paramNames" : [ "include", "exclude" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "toTypedJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a _typed_ JSON object.\n@param omitTopLevelType\n       Whether to leave out `type: {{ type of this serializable instance }}` as the **first** key-value pair in\n       the outer level of the produced json.\n@param runtime\n       If provided, then any special serialization logic required for the {@link ImplLanguage.Runtime} will be\n       performed. **NOTE** This argument is ignored if `typed` is not `true`. @see Ann.Ser\n\n\n@return JSON object representation\n\n@see #fromJson\n@see #toJson\n@see serdeser.c3doc\n@see JsonType",
"name" : "toTypedJson",
"params" : [ {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"name" : "toTypedJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"name" : "toTypedJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toTypedJson",
"params" : [ {
"name" : "omitTopLevelTypeOrIncludeOrInclude",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
} ]
}
}, {
"name" : "actionRequirementOrExcludeOrExclude",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
}, {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
} ]
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"paramNames" : [ "omitTopLevelTypeOrIncludeOrInclude", "actionRequirementOrExcludeOrExclude" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "toJsonString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toJsonString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized JSON string.\n\n@return JSON object as string",
"name" : "toJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "pretty" ]
}
}, {
"type" : "Method",
"name" : "toTypedJsonString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toTypedJsonString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"name" : "toTypedJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toTypedJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "pretty", "omitTopLevelType" ]
}
}, {
"type" : "Method",
"name" : "toJsString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toJsString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized JavaScript object literal.\n\n@return JavaScript object literal string",
"name" : "toJsString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJsString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "withType" ]
}
}, {
"type" : "Method",
"name" : "toXmlString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toXmlString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized XML string.\n\n@return XML element as string\n\n@see #fromXmlString",
"name" : "toXmlString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toXmlString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "withType" ]
}
}, {
"type" : "Method",
"name" : "serialize",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a string serialized representation of the object.\n\n@return string serialized object representation",
"name" : "serialize",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "serialize",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "contentType" ]
}
}, {
"type" : "Method",
"name" : "fromJson",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Annotatable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the JSON-based representation and reconstruct the corresponding object.\n\nfromJson is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which may be\na type that mixes in the type on which it is called). This means that the resulting object's type will be isA the\ncalled-on type, but perhaps not identical. In particular, `Obj.fromJson` works for any actual type and will return\nan instance of the correct type.\n\n@see #toJson",
"name" : "fromJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Annotatable",
"mixing" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Annotatable",
"mixing" : true
},
"paramNames" : [ "json" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fromJsonString",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Annotatable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the JSON-based representation and reconstruct the corresponding object.\n\nfromJsonString is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which may be\na type that mixes in the type on which it is called). This means that the resulting object's type will be isA the\ncalled-on type, but perhaps not identical. In particular, `Obj.fromJsonString` works for any actual type and will return\nan instance of the correct type.\n\n@see #toJsonString",
"name" : "fromJsonString",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Annotatable",
"mixing" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromJsonString",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Annotatable",
"mixing" : true
},
"paramNames" : [ "json" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fromXmlString",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Annotatable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the XML-based representation and reconstruct the corresponding object.\n\nfromXmlString is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which\nmay be a type that mixes in the type on which it is called). This means that the resulting object's type will be\nisA the called type, but perhaps not identical. In particular, `Obj.fromXmlString` works for any actual type and\nwill return an instance of the correct type.\n\n@see #toXmlString",
"name" : "fromXmlString",
"params" : [ {
"name" : "xml",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Annotatable",
"mixing" : true
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromXmlString",
"params" : [ {
"name" : "xml",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Annotatable",
"mixing" : true
},
"paramNames" : [ "xml" ]
}
}, {
"type" : "Method",
"name" : "deserialize",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Annotatable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load from contentType representation and reconstruct the corresponding object.\n\nfromString is be called on the type be deserialized and must reconstruct an object of the appropriate type\n(which may be a type that mixes in the type on which it is called). This means that the resulting object's type\nwill be isA the called-on type, but perhaps not identical. In particular, `fromString` works for any actual\ntype and will return an instance of the correct type.",
"name" : "deserialize",
"params" : [ {
"name" : "contentStr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Annotatable",
"mixing" : true
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "deserialize",
"params" : [ {
"name" : "contentStr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Annotatable",
"mixing" : true
},
"paramNames" : [ "contentStr", "contentType" ]
}
}, {
"type" : "Method",
"name" : "fingerprint",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Produce a checksum that can easily be compared to determine if two objects are definitely different. Note that\nthere is a slight possibility that two objects with the same fingerprint will actually differ.\n\nThe fingerprint recurses into field values, including collections and referenced Objs. The handling of nested\n{@link Identified identified} references (typically entities) differ in that _only_ the `id` field is included\nunless the allIdentifiedRefFields option is specified.\n\nIf the object graph may contain recursive embedded object references, the trackRecursiveRefs option may be used.\nHowever, maintaining the list of visited objects is costly so this should not be done unnecessarily.\n\n@param allIdentifiedRefFields\n          if `true`, fingerprint individual fields of persistable references, not just the `id`\n@param trackRecursiveRefs\n          if `true`, a set of referenced objects is maintained to avoid infinite recursion\n@param traversedRefs\n          only considered together with trackRecursiveRefs and if provided then all traversed references are\n          checked against and added to it\n@return integer fingerprint\n\n@see https://en.wikipedia.org/wiki/Fingerprint_(computing)",
"name" : "fingerprint",
"params" : [ {
"name" : "allIdentifiedRefFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "trackRecursiveRefs",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "traversedRefs",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<Obj>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fingerprint",
"params" : [ {
"name" : "allIdentifiedRefFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "trackRecursiveRefs",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "traversedRefs",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<Obj>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"paramNames" : [ "allIdentifiedRefFields", "trackRecursiveRefs", "traversedRefs" ]
}
}, {
"type" : "Method",
"name" : "retainedMemory",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Measures retained memory by this instance.\n\n@param deep\n       if true and this instance contains references to other objects also measures memory retained by those\n@param allMeasured\n       if set then will skip instances that are in the set and will add instances that where measured by this call\n@return retained memory in bytes for this instances",
"name" : "retainedMemory",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "allMeasured",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<any>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "retainedMemory",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "allMeasured",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<any>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"paramNames" : [ "deep", "allMeasured" ]
}
}, {
"type" : "Method",
"name" : "instanceOf",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Checks whether this Obj is an instance of the specified type by checking both its type and the mixin chain.\nThis is the most convenient way to ask \"is this type usable in a context requiring the other type?\"\n\n@return true if this instance is of this type or any of its mixins",
"name" : "instanceOf",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Checks whether this instance is an instance of the specified type by checking both its type and the mixin chain.\nThis is the most convenient way to ask \"is this type usable in a context requiring the other type?\"\n\n@return true if this instance is of this type or any of its mixins\n\n@see ValueType#isA",
"name" : "instanceOf",
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "instanceOf",
"params" : [ {
"name" : "typeNameOrType",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ]
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "typeNameOrType" ]
}
}, {
"type" : "Method",
"name" : "isEmptyObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether all the fields of this instance are empty.",
"name" : "isEmptyObj",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isEmptyObj",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "isSame",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether the specified instance represents exactly the same object as this instance.",
"name" : "isSame",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isSame",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "other" ]
}
}, {
"type" : "Method",
"name" : "fieldValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns value of the given field.\n\n@param field\n          Field to return the value for\n       defaultToEmpty\n          will return default empty value if field is missing",
"name" : "fieldValue",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Returns value of the given field type. Be sure to use the FieldType instance for the exact same type as the type of\nthe obj.\n\n@param field\n          Field to return the value for\n       defaultToEmpty\n          will return default empty value if field is missing\n@return value for the given field",
"name" : "fieldValue",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValue",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
} ]
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "field", "defaultToEmpty" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fieldValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldValue"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all non empty field values. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValues",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldValue"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValues",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldValue"
}
}
}
}, {
"type" : "Method",
"name" : "fieldValuesByOrdinal",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all field values including empty ones as array where value of a field is at corresponding ordinal position.\nUnless `skipTrailingEmpty` parameter is set and there are trailing empty values resulting array has same size as\n#dataFieldTypes",
"name" : "fieldValuesByOrdinal",
"params" : [ {
"name" : "skipTrailingEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesByOrdinal",
"params" : [ {
"name" : "skipTrailingEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"paramNames" : [ "skipTrailingEmpty" ]
}
}, {
"type" : "Method",
"name" : "fieldValuesByFieldType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all non empty field values by field type. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValuesByFieldType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesByFieldType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
}
}, {
"type" : "Method",
"name" : "fieldValuesByFieldName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all non empty field values by field name. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValuesByFieldName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesByFieldName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}
}, {
"type" : "Method",
"name" : "fieldNames",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all data field names including those whose values are empty. Array is ordered by field ordinal.",
"name" : "fieldNames",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldNames",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}
}, {
"type" : "Method",
"name" : "at",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return value of the field at provided ordinal\n\n@param ordinal\n        Integer ordinal of the field in the parent type\n@return value of field at ordinal",
"name" : "at",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "ordinal",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Return value for the given serialized expression\n\n@param expr\n        Serialized expression to obtain the value in the given Obj\n@param failIfNotValid\n        If set, fails if not a valid expression\n@return value obtained as a result of expression evaluation",
"name" : "at",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "expr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
}, {
"name" : "failIfNotValid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "at",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "ordinalOrExpr",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
}, {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
} ]
}
}, {
"name" : "failIfNotValid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "ordinalOrExpr", "failIfNotValid" ]
}
}, {
"type" : "Method",
"name" : "fieldValueAtPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Looks up a single field value by path from this Obj. Field paths are separated by dots so an expression like\n`fieldValueAtPath(\"location.elevation\")` is equivalent to `traverse(\"location\").fieldValue(\"elevation\")` except\nthat it also handles `null`. If path contains any collections then only first element will be traversed,\nunless the collection index is specified in the path.\n\nIf you need to traverse all elements of collection fields use #fieldValuesAtPath instead.\n\n@param fieldPath\n          field names separated by dots\n@param failIfNotFound\n          if true, an error will be thrown if the any of the field types aren't defined\n@param context\n          if an error is thrown, the context returned by calling the lambda will be incorporated\n@return the field or null",
"name" : "fieldValueAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValueAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "fieldPath", "failIfNotFound", "context" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fieldValuesAtPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "VarReferenceType",
"name" : "T"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Looks up all the fields by path from root Obj. If path contains any collections then result will contain all\ntraversals, unless the collection index is specified in the path.\n\n@param fieldPath\n          field names separated by dots\n@param failIfNotFound\n          if true, an error will be thrown if the any of the field types aren't defined\n@param context\n          if an error is thrown, the context returned by calling the lambda will be incorporated\n@return fields as a flat list\n\n@see #fieldValueAtPath",
"name" : "fieldValuesAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "VarReferenceType",
"name" : "T"
}
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "VarReferenceType",
"name" : "T"
}
},
"paramNames" : [ "fieldPath", "failIfNotFound", "context" ]
}
}, {
"type" : "Method",
"name" : "eachFieldValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Perform an action for each non-empty field of this object.\n\n@param action\n          lambda to apply",
"name" : "eachFieldValue",
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Perform an action for each field of this object. Fields are filtered based on provided `spec`.\n\n@param spec\n          which fields to include\n@param action\n          lambda to apply",
"name" : "eachFieldValue",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachFieldValue",
"params" : [ {
"name" : "actionOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"paramNames" : [ "actionOrSpec", "action" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "eachFieldValueWhile",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Perform an action for each field of this object while processing action returns `true`. Fields are filtered based\non provided `spec`.\n\n@param spec\n          which fields to include\n@param action\n          lambda to apply; stop if this `action` returns `false\n@return `true` if iteration was not aborted by lambda i.e. it saw all field values",
"name" : "eachFieldValueWhile",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachFieldValueWhile",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "spec", "action" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "eachRef",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type. For reference fields, this means\nthe field value if non-null and for collections of Obj, this means each element in the collection.\n\n@param action\n          function to be executed for each pair of field type and Obj instance",
"name" : "eachRef",
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type. For reference fields, this means\nthe field value if non-null and for collections of Obj, this means each element in the collection.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param action\n          function to be executed for each pair of field type and Obj instance",
"name" : "eachRef",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRef",
"params" : [ {
"name" : "actionOrIncludeEmpty",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
}, {
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ]
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"paramNames" : [ "actionOrIncludeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "eachRefWhile",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type while processing action returns\n`true`.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param action\n          function to be executed for each pair of field type and Obj instance; stops processing if return `false`\n@return `true` if iteration was not aborted by lambda i.e. it saw all refs",
"name" : "eachRefWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRefWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "includeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "eachRefRecursive",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type or in any child refs.",
"name" : "eachRefRecursive",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRefRecursive",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"paramNames" : [ "includeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "eachRefRecursiveWhile",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type or in any child refs. Continue while\nprocessing action returns `true`.",
"name" : "eachRefRecursiveWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRefRecursiveWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "includeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "mapFieldValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Result of this function call is a copy of current instance with all non empty fields replaced based on results of\nthe `mapper` invocation.\n\n@param action\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValues",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Result of this function call is a copy of current instance with all fields replaced based on results of the\n`mapper` invocation.\n\n@param spec\n          which fields to include\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValues",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapFieldValues",
"params" : [ {
"name" : "mapperOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "convertValueOrMapper",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ]
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"paramNames" : [ "mapperOrSpec", "convertValueOrMapper", "convertValue" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapFieldValuesAsync",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing Annotatable>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Result of this function call is a copy of current instance with all non empty fields replaced based on results of\nthe asynchronous `mapper` invocation.\n\n@param action\n          lambda to apply for every field value to produce a new value for that fields\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValuesAsync",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing Annotatable>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Result of this function call is a copy of current instance with all fields replaced based on results of the\nasynchronous `mapper` invocation.\n\n@param spec\n          which fields to include\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValuesAsync",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing Annotatable>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"name" : "mapFieldValuesAsync",
"params" : [ {
"name" : "mapperOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "convertValueOrMapper",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
} ]
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing Annotatable>",
"hadDeclaredVarBindings" : true
},
"paramNames" : [ "mapperOrSpec", "convertValueOrMapper", "convertValue" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapFieldValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Result of this function call is a copy of current instance with specified field value replaced based on result of\nthe `mapper` invocation.\n@param field\n          field being mapped\n@param includeEmpty\n          if set, invokes mapper for fields with empty value\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValue",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapFieldValue",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"paramNames" : [ "field", "includeEmpty", "mapper", "convertValue" ]
}
}, {
"type" : "Method",
"name" : "mapRefs",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Executes the specified lambda against each referenced Obj instance and replaces it's value with result of this\nlambda application.\n\nResult of this function call is a copy of current instance with all references replaced based on results of the\n`mapper` invocation.\n\n@param action\n          function to be executed for each pair of field type and Obj instance\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapRefs",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Executes the specified lambda against each referenced Obj instance and replaces it's value with result of this\nlambda application.\n\nResult of this function call is a copy of current instance with all references replaced based on results of the\n`mapper` invocation.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param mapper\n          function to be executed for each pair of field type and Obj instance for producing new reference value\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapRefs",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapRefs",
"params" : [ {
"name" : "mapperOrIncludeEmpty",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
}, {
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ]
}
}, {
"name" : "convertValueOrMapper",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
} ]
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"paramNames" : [ "mapperOrIncludeEmpty", "convertValueOrMapper", "convertValue" ]
}
}, {
"type" : "Method",
"name" : "foldFieldValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Result of this function is application of `folder` lambda to every non empty field value where `accumulator`\nargument is a result of previous application. Initial value of `accumulator` will be `null`.\n\nThis function is useful for calculating aggregate values based on all current non empty field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Result of this function is application of `folder` lambda to every non empty field value where `accumulator`\nargument is a result of previous application. Initial value of `accumulator` is provided via `initial` parameter.\n\nThis function is useful for calculating aggregate values based on all current non empty field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "initial",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Result of this function is application of `folder` lambda to every field value where `accumulator` argument is a\nresult of previous application. Initial value of `accumulator` is provided via `initial` parameter.\n\nThis function is useful for calculating aggregate values based on all field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "initial",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}, {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "folderOrInitialOrInitial",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
}, {
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ]
}
}, {
"name" : "folderOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "folderOrInitialOrInitial", "folderOrSpec", "folder" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "evalProjection",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "AnyType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Evaluates given projection expression over this instance.",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
}, {
"name" : "resultType",
"valueType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "AnyType"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Evaluates given projection over this instance and returns results as json.",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "JsonType",
"name" : "json"
},
"inline" : true,
"member" : true,
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Evaluates given projection over this instance and returns results as instance of the new Obj.",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
}, {
"name" : "resultType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
},
"inline" : true,
"member" : true,
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
}, {
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
} ]
}
}, {
"name" : "resultTypeOrBindingsOrResultType",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
}, {
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
} ]
}
}, {
"name" : "bindingsOrOptionsOrBindings",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ]
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "AnyType"
},
"paramNames" : [ "projection", "resultTypeOrBindingsOrResultType", "bindingsOrOptionsOrBindings", "options" ]
}
}, {
"type" : "Method",
"name" : "validateObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjResult"
}
} ]
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Populates all missing default values and throws error if any constraint it violated.",
"name" : "validateObj",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Validate that the Obj fields are set according to all the required rules.",
"name" : "validateObj",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjSpec"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjResult"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "validateObj",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjSpec"
}
} ],
"returnType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjResult"
}
} ]
},
"paramNames" : [ "spec" ]
}
}, {
"type" : "Method",
"name" : "withField",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the provided field in it. The name must correspond to an existing field\ndefined on this type or its mixins. The value must be of the correct type if doNotConvert flag is true.\n\n@param field\n          name of the field\n@param value\n          of the field\n@param doNotConvert\n          if true, do not attempt to convert the value to match the field's type\n@return new Obj",
"name" : "withField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the provided field in it. The name must correspond to an existing field\ndefined on this type or its mixins. The value must be of the correct type if doNotConvert flag is true.\n\n@param field\n          the field\n@param value\n          of the field\n@param doNotConvert\n          if true, do not attempt to convert the value to match the field's type\n@return new Obj",
"name" : "withField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
} ]
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"paramNames" : [ "field", "value", "doNotConvert" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "withFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the provided fields in it. The name must correspond to an existing fields\ndefined on this type or its mixins. The values must be of the correct type if doNotConvert flag is true.\n\n@param fields\n          map of fields name/values\n@param doNotConvert\n          if true, attempt to convert the values to match the fields' type\n@return new Obj",
"name" : "withFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"paramNames" : [ "fields", "doNotConvert" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "withFieldAtPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj with the value at the specified path field. If the value is null, the final field is removed.\n\nImmutable objects may return the same instance if the field being set or removed does not actually represent a\nchange to the existing object.\n\n@param path\n          path to set value at\n@param value\n          value to set\n@param doNotConvert\n          if true, attempt to convert the values to match the fields' type\n@param doNotCreateIfMissing\n          true indicates that any empty reference along the path will not set the value\n@return new Obj",
"name" : "withFieldAtPath",
"params" : [ {
"name" : "path",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "doNotCreateIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withFieldAtPath",
"params" : [ {
"name" : "path",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "doNotCreateIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"paramNames" : [ "path", "value", "doNotConvert", "doNotCreateIfMissing" ]
}
}, {
"type" : "Method",
"name" : "withoutField",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the field with the provided name.\n\nImmutable objects may return the same instance if the field being removed is not present in the existing object.\n\n@param name\n          of the field to remove\n@return new Obj with removed field",
"name" : "withoutField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the field with the provided field type.\n\nImmutable objects may return the same instance if the field being removed is not present in the existing object.\n\n@param field\n          of the field to remove\n@return new Obj with removed field",
"name" : "withoutField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
} ]
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"paramNames" : [ "field" ]
}
}, {
"type" : "Method",
"name" : "withoutFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the fields with the provided names.\n\nImmutable objects may return the same instance if the fields being removed are not present in the existing object.\n\n@param names\n          of the fields to remove\n@return new Obj with removed fields",
"name" : "withoutFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "withoutFieldsByType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the fields with the provided field types. Be sure to use the FieldType instance for the\nexact same type as the type of the obj to respect the \"ordinal\" of the field type\n\nImmutable objects may return the same instance if the fields being removed are not present in the existing object.\n\n@param fields\n          of the fields to remove\n@return new Obj with removed fields",
"name" : "withoutFieldsByType",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutFieldsByType",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "withDefaults",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the default values (if defined) for all empty fields. This is implemented by\ncalling {@link FieldType#defaultValue defaultValue} for a field if it is not already set and\n{@link FieldType#hasDefault has a default}. It will also set {@see ValueType#initialValue initial values} for\nfields with required primitive ValueTypes (E.g. x: `!int32` -> will be set to 0). Note that this will not overwrite\nfields that have already been set.\n\n{@link FunctionParam#validateArg} will call {@link #withDefaults} for {@link Spec}s passed as arguments to methods.\nAs a result, methods should be implemented assuming all default values are set on `Spec` arguments.\n\n@param includeEmptyRefsWithDefaults\n          it `true` then missing / empty child references that have fields with defaults will also be instantiated\n@param defaultFields\n          If not empty, a list of default field paths to populate.  Any default fields not specified in the\n          array will be ignored.\n@return new Obj\n\n@see FieldType#defaultValueConst\n@see FieldType#defaultValue",
"name" : "withDefaults",
"params" : [ {
"name" : "includeEmptyRefsWithDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "defaultFields",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withDefaults",
"params" : [ {
"name" : "includeEmptyRefsWithDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "defaultFields",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"paramNames" : [ "includeEmptyRefsWithDefaults", "defaultFields" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mergeObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Merges all the fields of the provided Obj into this instance, producing a new Obj of the same type as this one.\nIn case of conflicts, fields of other instance take precedence unless otherwise specified by the fieldPathMergeSpec\n\n@param other\n          object\n@param fieldPathMergeSpec\n          mapping of fields of the object to the respective merge annotations\n@return the new merged Obj",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "fieldPathMergeSpec",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Merges all the fields of the provided Obj into this instance, producing a new Obj of the same type as this one.\nIn case of conflicts, fields of other instance take precedence.\n\n@param other\n          object\n@param otherFieldsFilter\n          only fields of otherFieldsFilter type from other are merged into this obj.\n@return the new merged Obj",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "otherFieldsFilter",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Merge the fields of this Obj with corresponding fields on other Obj using the provided lambda. This means that\nfields that exist on other Obj and do not exist on this Obj will not be added to final Obj.\n@param deep\n       if set to true then traverse reference and collection fields and merge corresponding fields or elements with\n       the same key or index.",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 2
}, {
"type" : "MethodType",
"doc" : "Merge the fields of this Obj with corresponding fields on other Obj using the provided lambda. This means that\nfields that exist other Obj and do not exist on this Obj will not be added to final Obj or evaluated. Does not\ntraverse child reference and collection fields.",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 3
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "fieldPathMergeSpecOrOtherFieldsFilterOrDeepOrMerger",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ]
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"paramNames" : [ "other", "fieldPathMergeSpecOrOtherFieldsFilterOrDeepOrMerger", "merger" ]
}
}, {
"type" : "Method",
"name" : "mergeAndExpandObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Create new Obj with all non-null fields of this and other. Fields that are non null in both apply merger lambda.\nFields that non null in only one of this and other will be in the resulting Obj without change.",
"name" : "mergeAndExpandObj",
"genericVars" : [ {
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeAndExpandObj",
"genericVars" : [ {
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"paramNames" : [ "other", "merger" ]
}
}, {
"type" : "Method",
"name" : "mergeJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "mergeJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"paramNames" : [ "json" ]
}
}, {
"type" : "Method",
"name" : "mergeChildren",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Merge the obj references within the current obj\n@param deep\n       If set, traverses the reference fields within the obj as well for a deep merge\n@param objKey\n       lambda specifying how to obtain the key for the Obj while determining which Objs to merge\n@param filter\n       Field paths that need to be filtered from this merge\n@return Obj with child references merged",
"name" : "mergeChildren",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "objKey",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "child",
"valueType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "filter",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeChildren",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "objKey",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "child",
"valueType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "filter",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"paramNames" : [ "deep", "objKey", "filter" ]
}
}, {
"type" : "Method",
"name" : "sumObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds the numeric Obj fields with the other Objs respective fields.\nIf deep is set it will traverse reference and collection fields and sum corresponding numeric fields in\nreferences with same name and collection elements at same index or key.",
"name" : "sumObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "sumObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"paramNames" : [ "other", "deep" ]
}
}, {
"type" : "Method",
"name" : "singletonArray",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "Annotatable",
"mixing" : true
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Build an array of the correct type with a single element which is this instance.\n\n@return new array instance with this as only element.",
"name" : "singletonArray",
"returnType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "Annotatable",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"name" : "singletonArray",
"returnType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "Annotatable",
"mixing" : true
}
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "array",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Annotatable",
"mixing" : true
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an array of instances of this type.",
"name" : "array",
"params" : [ {
"name" : "elements",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Annotatable",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "array",
"params" : [ {
"name" : "elements",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Annotatable",
"mixing" : true
}
},
"paramNames" : [ "elements" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "arrayBuilder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "ArrayBuilder<mixing Annotatable>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an array of instances of this type.",
"name" : "arrayBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "ArrayBuilder<mixing Annotatable>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "arrayBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "ArrayBuilder<mixing Annotatable>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "singletonSet",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "SetType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "Annotatable",
"mixing" : true
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Build an set of the correct type with a single element which is this instance.\n\n@return new array instance with this as only element.",
"name" : "singletonSet",
"returnType" : {
"type" : "SetType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "Annotatable",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"name" : "singletonSet",
"returnType" : {
"type" : "SetType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "Annotatable",
"mixing" : true
}
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "setBuilder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<mixing Annotatable>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates a set of instances of this type.",
"name" : "setBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<mixing Annotatable>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "setBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<mixing Annotatable>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapBuilder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<string, mixing Annotatable>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Create a map of string to elements of this type.",
"name" : "mapBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<string, mixing Annotatable>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<string, mixing Annotatable>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapBuilderOf",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<any, mixing Annotatable>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Create a map with the given key type and elements of this type.",
"name" : "mapBuilderOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<any, mixing Annotatable>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapBuilderOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<any, mixing Annotatable>",
"hadDeclaredVarBindings" : true
},
"paramNames" : [ "keyType" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "myReferenceType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myReferenceType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myReferenceType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
}
}
}, {
"type" : "Method",
"name" : "myMapTypeOf",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myMapTypeOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myMapTypeOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"paramNames" : [ "keyType" ]
}
}, {
"type" : "Method",
"name" : "myMapType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myMapType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myMapType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
}
}
}, {
"type" : "Method",
"name" : "myArrayType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myArrayType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myArrayType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
}
}
}, {
"type" : "Method",
"name" : "mySetType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "mySetType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mySetType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
}
}
}, {
"type" : "Method",
"name" : "myStreamType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myStreamType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myStreamType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
}
}
}, {
"type" : "Method",
"name" : "toBuilder",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing Annotatable>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return new ObjBuilder with initial state set to fields of this instance.",
"name" : "toBuilder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing Annotatable>",
"hadDeclaredVarBindings" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toBuilder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing Annotatable>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "builder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing Annotatable>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return new ObjBuilder of this instance.",
"name" : "builder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing Annotatable>",
"hadDeclaredVarBindings" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "builder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing Annotatable>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fromFields",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type from provided fields\n@param fields\n           Fields to construct the instance of the obj with\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0) populated\n\n@see withDefaults",
"name" : "fromFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"paramNames" : [ "fields", "withDefaults" ]
}
}, {
"type" : "Method",
"name" : "make",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type with no non-default field values unless explicitly specified by passing param true\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0)\n           populated\n\n@see withDefaults",
"name" : "make",
"params" : [ {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Construct an instance from provided fields\n@param fields\n           Fields (in the format <field_name, value>) to construct an instance of the obj. Note that \"type\" as a\n           field_name will be considered as the actual Obj's type, e.g. Obj.make({\"type\": \"Panda\"}) is equivalent\n           to Panda.make()\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32\n           -> 0) populated. Passing an empty value for a field will result in the default field value being set if\n           the field does not {@link ValueModifier#PRESERVES_EMPTY preserve empty} and {@link FieldType#hasDefault\n           has a default value}.\n\n\n@see fromFields\n@see beforeMake\n@see afterMake\n@see withDefaults",
"name" : "make",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : " Construct an instance of this type from provided fields. Note it is more efficient to use #fromFields and other overloads\n\n ```js\n User.make({\n   email: 'joe@smith.com',\n   realName: 'Joe Smith'\n })\n\n Obj.make({\n   type: 'User',\n   email: 'joe@smith.com',\n   realName: 'Joe Smith'\n })\n ```\n\n ```py\n c3.User.make({\n   \"email\": 'joe@smith.com',\n   \"realName\": 'Joe Smith'\n })\n\n c3.Obj.make({\n   \"type\": 'User',\n   \"email\": 'joe@smith.com',\n   \"realName\": 'Joe Smith'\n })\n\n c3.User(email='joe@smith.com', realName='Joe Smith')\n\n c3.Obj(type='User', email='joe@smith.com', realName='Joe Smith')\n```\n\n Note that this is **not** the same as the [serialization format](serdeser.c3doc). This is a convenient way to\n specify fields and values in the \"JSON like\" form supported by each language, but the usual serialization rules,\n such as {@link Ann.Ser} do not apply.\n @param fields\n            Fields to construct the instance of the obj with\n @param withDefaults\n            If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0) populated\n\n @see fromFields\n @see beforeMake\n @see afterMake\n @see withDefaults",
"name" : "make",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "make",
"params" : [ {
"name" : "withDefaultsOrFieldsOrFields",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"paramNames" : [ "withDefaultsOrFieldsOrFields", "withDefaults" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "remake",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type from provided instance of a subtype or a \"duck type\".",
"name" : "remake",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "failIfExtraOrInvalidFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "remake",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "failIfExtraOrInvalidFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"paramNames" : [ "other", "failIfExtraOrInvalidFields" ]
}
}, {
"type" : "Method",
"name" : "remakeAs",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an obj of the new type with all fields that exist on the original obj that are defined in the new type\nconverted and copied to the new obj instance. Note, that checking assignability and conversion of field values\ncould be costly if types have different value types for same fields.\n\n@param type\n        Type of new obj to return\n@return new obj of the requested type with all fields present in the original obj that are defined in the new type\n        converted and copied to it",
"name" : "remakeAs",
"genericVars" : [ {
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "remakeAs",
"genericVars" : [ {
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"paramNames" : [ "type" ]
}
}, {
"type" : "Method",
"name" : "beforeMake",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : true,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : false,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Optional override that will be called every time instance of this type is created.\n\n\nNote that it introduces additional overhead so should only be implemented for low volume data.",
"name" : "beforeMake",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"private" : true,
"optional" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "beforeMake",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "afterMake",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : true,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : false,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Optional override that will be called after every instance creation.\n\nNote that it introduces additional overhead so should only be implemented for low volume data.",
"name" : "afterMake",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"private" : true,
"optional" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "afterMake",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
}
}
}, {
"type" : "Method",
"name" : "cachedEmptyInst",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an empty inst using `MyType.make()` and caches it. Avoid recreating multiple copies of the spec for\nevery action dispatch. The cached inst can also be used for comparing whether the object is an empty or not\nWill only create empty instance for immutable Obj e.g. if an Obj is Mutable, this method will throw an error\n\n@see ValueType#defaultEmptyValue",
"name" : "cachedEmptyInst",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "cachedEmptyInst",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
}
}
}, {
"type" : "Method",
"name" : "toData",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Data"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Represent the current obj instance as {@link Data}",
"name" : "toData",
"returnType" : {
"type" : "ReferenceType",
"name" : "Data"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toData",
"returnType" : {
"type" : "ReferenceType",
"name" : "Data"
}
}
}, {
"type" : "Method",
"name" : "declaredSrcLine",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : true,
"isProperty" : true,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "Int32Type",
"name" : "int32"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : false,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Source line number in a C3 Type declaration [.c3typ] file starting with 1 where this metadata element is declared.",
"name" : "declaredSrcLine",
"returnType" : {
"type" : "Int32Type",
"name" : "int32"
},
"optional" : true,
"inline" : true,
"member" : true,
"property" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "declaredSrcLine",
"returnType" : {
"type" : "Int32Type",
"name" : "int32"
}
}
}, {
"type" : "Method",
"name" : "declaredSrcCharInLine",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : true,
"isProperty" : true,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "Int32Type",
"name" : "int32"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : false,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Source character position in a line in a C3 Type declaration [.c3typ] file starting with 1 where this metadata\nelement is declared.",
"name" : "declaredSrcCharInLine",
"returnType" : {
"type" : "Int32Type",
"name" : "int32"
},
"optional" : true,
"inline" : true,
"member" : true,
"property" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "declaredSrcCharInLine",
"returnType" : {
"type" : "Int32Type",
"name" : "int32"
}
}
}, {
"type" : "Method",
"name" : "pkgVersion",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Version of the #pkg when this type was built",
"name" : "pkgVersion",
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "pkgVersion",
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
}
}
}, {
"type" : "Method",
"name" : "typesys",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return package for built-in Type System; this could be different from #pkg() when package is loaded from a disk\n        for code gen",
"name" : "typesys",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg"
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "typesys",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg"
}
}
}, {
"type" : "Method",
"name" : "mergedAnnotationsJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : true,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "JsonType",
"name" : "json"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : false,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Override this method to return the merged set of annotations from itself and its hierarchy\nE.g.\n```type\n  @config(folder=\"x\")\n  type A {\n  }\n  @config(secret=true)\n  type B mixes A\n```\n=> return config(secret=true, folder=\"x\") for type B\nIf not overriden, by default this returns #annotationJson",
"name" : "mergedAnnotationsJson",
"returnType" : {
"type" : "JsonType",
"name" : "json"
},
"abstract" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergedAnnotationsJson",
"returnType" : {
"type" : "JsonType",
"name" : "json"
}
}
}, {
"type" : "Method",
"name" : "declaredAnnotations",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotations"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "The declared annotations for this metadata element.",
"name" : "declaredAnnotations",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotations"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "declaredAnnotations",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotations"
}
}
}, {
"type" : "Method",
"name" : "annotations",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotations"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "The annotations for this metadata element.",
"name" : "annotations",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotations"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "annotations",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotations"
}
}
}, {
"type" : "Method",
"name" : "hasAnnotations",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Annotatable" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Annotatable"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this metadata element has any annotation.",
"name" : "hasAnnotations",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasAnnotations",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
},
"$nearestImplementedOn" : "Annotatable"
}, {
"type" : "Method",
"name" : "hasAnnotation",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Annotatable" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Annotatable"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this metadata element has annotation with provided name.",
"name" : "hasAnnotation",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasAnnotation",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "ann" ]
},
"$nearestImplementedOn" : "Annotatable"
}, {
"type" : "Method",
"name" : "hasAnnotationValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Annotatable" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Annotatable"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether this metadata element has annotation field value.",
"name" : "hasAnnotationValue",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "annField",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "hasAnnotationValue",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "annField",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "ann", "annField" ]
},
"$nearestImplementedOn" : "Annotatable"
}, {
"type" : "Method",
"name" : "annotation",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Annotation"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Annotatable" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Annotatable"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return annotation with provided name",
"name" : "annotation",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Annotation"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "annotation",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "failIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Annotation"
},
"paramNames" : [ "ann", "failIfMissing" ]
},
"$nearestImplementedOn" : "Annotatable"
}, {
"type" : "Method",
"name" : "annotationValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "AnyType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Annotatable" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Annotatable"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return annotation value for provided annotation name and annotation field",
"name" : "annotationValue",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "annField",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "AnyType"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "annotationValue",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "annField",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "AnyType"
},
"paramNames" : [ "ann", "annField" ]
},
"$nearestImplementedOn" : "Annotatable"
}, {
"type" : "Method",
"name" : "withAnnotation",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Add an annotation to the given metadata",
"name" : "withAnnotation",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotation"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Add an annotation to the given metadata\n@param ann\n        annotation to add\n@param annField\n        which field on the annotation needs to be set\n@param value\n        value for the field",
"name" : "withAnnotation",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "annField",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withAnnotation",
"params" : [ {
"name" : "ann",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotation"
}
}, {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ]
}
}, {
"name" : "annField",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable",
"mixing" : true
},
"paramNames" : [ "ann", "annField", "value" ]
}
}, {
"type" : "Method",
"name" : "haveSameAnnotations",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether the specified instances have same annotations.",
"name" : "haveSameAnnotations",
"params" : [ {
"name" : "a1",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Annotatable"
}
}, {
"name" : "a2",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "haveSameAnnotations",
"params" : [ {
"name" : "a1",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Annotatable"
}
}, {
"name" : "a2",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Annotatable"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "a1", "a2" ]
}
}, {
"type" : "Method",
"name" : "inheritableAnnotationsJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "JsonType",
"name" : "json"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return the JSON for annotations that can be inherited by children of this element of metadata. Annotations are\nnormally inherited, but ones marked with {@link Annotation#noInherit} will not be.",
"name" : "inheritableAnnotationsJson",
"returnType" : {
"type" : "JsonType",
"name" : "json"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "inheritableAnnotationsJson",
"returnType" : {
"type" : "JsonType",
"name" : "json"
}
}
} ],
"hasSourceCode" : {
"js-ide-vscode-client-node" : true
}
});
'use strict';
function hasAnnotations() {
return this.annotationsJson != null;
}
function hasAnnotation(ann) {
return this.hasAnnotations() && this.annotations().has(ann);
}
function hasAnnotationValue(ann, annField) {
if (!this.hasAnnotations()) return false;
let a = this.annotation(ann);
return a != null && Val.isNotEmpty(a[annField]);
}
function annotation(ann, failIfMissing) {
let inst;
if (this.hasAnnotations()) {
inst = this.annotations().get(ann);
}
if (inst == null && failIfMissing) {
throw new Error(`Missing annotation ${ann}.`);
}
return inst;
}
function annotationValue(ann, annField) {
let inst = this.annotation(ann, false);
if (inst != null) {
return inst[annField];
}
}
"use strict";
function $Builder(type, inst) {
let fields = {};
this.$type = type;
this.$setup = function (_inst) {};
this.$findType = function (type, _fields) { return type; };
this.$makeField = function (ft, value) { return value; };
this.$afterMake = function (inst) { return inst; };
if (inst != null) {
Object.keys(inst).forEach(fn => fields[fn] = inst[fn]);
}
Object.defineProperties(this, {
$objType: { value: type },
$onbuild: { value: undefined, writable: true },
$fields: { value: fields, configurable: true },
$refs: { value: {}, configurable: true },
$arrays: { value: {}, configurable: true },
$sets: { value: {}, configurable: true },
$maps: { value: {}, configurable: true },
$builder: { value: true },
});
}
$Builder.prototype.a = function a(field, element, doNotConvert) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isArray()) {
throw Err.invalidCall('ObjBuilder.a', `non-array field ${field.name}`);
}
let b = this.$arrays[field.name];
if (b == null) {
b = this.$fields[field.name];
if (b == null || !b.$builder) {
b = this.$arrays[field.name] = vt.makeBuilder(b);
}
}
if (arguments.length == 1) {
return b;
} else if (arguments.length == 2 || arguments.length == 3) {
b.add(element);
return this;
} else {
throw Err.invalidCall('ObjBuilder.a', 'expected field and element');
}
};
$Builder.prototype.clear = function clear() {
Object.defineProperty(this, '$fields', { value: {}, configurable: true });
Object.defineProperty(this, "$refs", { value: {}, configurable: true });
Object.defineProperty(this, "$arrays", { value: {}, configurable: true });
Object.defineProperty(this, "$sets", { value: {}, configurable: true });
Object.defineProperty(this, "$maps", { value: {}, configurable: true });
};
$Builder.prototype.constrain = function constrain() {
throw new Error('Unsupported operation ObjBuilder.constrain for JavaScript.');
};
$Builder.prototype.current = function current() {
let init = {};
Object.keys(this.$fields).forEach(p => {
let v = this.$fields[p];
if (v != null && v.$builder)
v = v.current();
init[p] = v;
});
return this.$objType.make(init);
};
$Builder.prototype.isEmpty = function isEmpty() {
return Object.keys(this.$fields).length === 0 &&
Object.keys(this.$refs).length === 0 &&
Object.keys(this.$arrays).length === 0 &&
Object.keys(this.$sets).length === 0 &&
Object.keys(this.$maps).length === 0;
};
$Builder.prototype.m = function m(field, key, element, doNotConvert) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isMap()) {
throw new Error(`Invalid call to ObjBuilder.m: non-map field ${field.name}.`);
}
let b = this.$maps[field.name];
if (b == null) {
b = this.$fields[field.name];
if (b == null || !b.$builder) {
b = this.$maps[field.name] = vt.makeBuilder(b);
}
}
if (arguments.length == 1) {
return b;
} else if (arguments.length == 3 || arguments.length == 4) {
b.put(key, element);
return this;
} else {
throw new Error(`Invalid call to ObjBuilder.m: expected field, key and value.`);
}
};
$Builder.prototype.mergeJson = function mergeJson(json) {
if (json != null) {
Object.keys(json).forEach(fn => this.v(fn, json[fn], false));
}
return this;
};
$Builder.prototype.mergeObj = function mergeObj(other, otherFieldsFilter) {
if (other == null) {
return this;
}
if (arguments.length == 1) {
if (this.objType() == other.type()) {
other.eachFieldValue((ft, v) => this.v(ft, v));
} else {
other.eachFieldValue((ft, v) => this.v(this.objType().fieldType(ft.name), v));
}
return this;
} else if (arguments.length == 2) {
if (other.instanceOf(otherFieldsFilter)) {
const tm = otherFieldsFilter.meta();
other.eachFieldValue((ft, v) => {
if (tm.fieldType(ft.name) != null)
this.v(ft, v);
});
}
return this;
}
throw new Error(`Invalid call to ObjBuilder.mergeObj: expected other and otherFieldsFilter.`);
};
$Builder.prototype.objType = function objType() {
return this.$objType;
};
$Builder.prototype.r = function r(field) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isReference()) {
throw new Error(`Invalid call to ObjBuilder.r: non-reference field ${field.name}.`);
}
let type = vt.dereference(true);
let b = this.$refs[field.name];
if (b == null) {
if (b == null || !b.$builder) {
b = this.$refs[field.name] = type.builder().mergeObj(b);
}
}
return b;
};
$Builder.prototype.s = function s(field, element, doNotConvert) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isSet()) {
throw Err.invalidCall('ObjBuilder.a', `non-array field ${field.name}`);
}
let b = this.$sets[field.name];
if (b == null) {
b = this.$fields[field.name];
if (b == null || !b.$builder) {
b = this.$sets[field.name] = vt.makeBuilder(b);
}
}
if (arguments.length == 1) {
return b;
} else if (arguments.length == 2 || arguments.length == 3) {
b.add(element);
return this;
} else {
throw Err.invalidCall('ObjBuilder.s', 'expected field and element');
}
};
$Builder.prototype.setFields = function setFields(fields, doNotConvert) {
if (fields != null) {
for (let [name, v] of fields) {
const ft = this.$objType.meta().fieldType(name, true);
if (v == null) {
delete this.$fields[ft.name];
} else {
this.$fields[ft.name] = v;
}
}
}
return this;
};
$Builder.prototype.v = function v(field, value, doNotConvert) {
if (arguments.length < 2) {
throw new Error(`Invalid call to ObjBuilder.v: expected field and value.`);
}
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
this.$fields[field.name] = value;
return this;
};
$Builder.prototype.build = function build() {
const type = this.$findType(this.$type, this.$fields);
let inst = Object.create(type.$objProto);
this.$setup(inst);
Object.keys(this.$refs).forEach(fn => {
this.$fields[fn] = this.$refs[fn].build();
});
Object.keys(this.$arrays).forEach(fn => {
this.$fields[fn] = this.$arrays[fn].build();
});
Object.keys(this.$sets).forEach(fn => {
this.$fields[fn] = this.$sets[fn].build();
});
Object.keys(this.$maps).forEach(fn => {
this.$fields[fn] = this.$maps[fn].build();
});
Object.keys(this.$fields).forEach(fn => {
let ft = type.$init.fieldTypes.find(fieldType => fieldType.name === fn && !fieldType.constant);
if (ft && inst[fn] === undefined && this.$fields[fn] != null) {
inst[fn] = this.$makeField(ft, this.$fields[fn]);
}
});
type.$init.fieldTypes.forEach(ft => {
if (!ft.constant && !_hasOwnProperty(inst, ft.name)) {
let vt = ft.valueType;
if (vt.modifier !== 'PRESERVES_EMPTY') {
let v = this.$makeField(ft, null);
if (v != null) {
inst[ft.name] = v;
}
}
}
});
inst = this.$afterMake(inst);
Object.freeze(inst);
if (this.$onbuild) {
this.$onbuild(inst);
}
return inst;
};
$Builder.prototype.type = function type() { return $type; };
$Builder.prototype.v = function v(field, value, doNotConvert) {
if (arguments.length < 2) {
throw new Error('Invalid call to ObjBuilder.v: expected field and value.');
}
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
this.$fields[field.name] = value;
return this;
};
$Builder.prototype.metadataPath = function (v) {
if (v == null) {
delete this.$fields.metadataPath;
} else {
this.$fields.metadataPath = v;
}
return this;
};
$Builder.prototype.package = function (v) {
if (v == null) {
delete this.$fields.package;
} else {
this.$fields.package = v;
}
return this;
};
$Builder.prototype.packageSubPath = function (v) {
if (v == null) {
delete this.$fields.packageSubPath;
} else {
this.$fields.packageSubPath = v;
}
return this;
};
$Builder.prototype.pkg = function (v) {
if (v == null) {
delete this.$fields.pkg;
} else {
this.$fields.pkg = v;
}
return this;
};
$Builder.prototype.annotationsJson = function (v) {
if (v == null) {
delete this.$fields.annotationsJson;
} else {
this.$fields.annotationsJson = v;
}
return this;
};
let $logger;
function log() {
if ($logger == null) {
$logger = C3.Logger.for($type.name());
}
return $logger;
};
const $type = new Type$Proto($conn, $init);
const $proto = new (function Annotatable() {});
Object.defineProperty($proto, '$conn', { value: $conn });
Object.defineProperties($type, {
$objProto: { value: $proto },
$withType: { value: true }
});
Object.defineProperty($type, Symbol.hasInstance, { value: function(inst) { return inst != null && inst.$c3inst && inst.$c3inst.meta().isA(this); } });
$proto.annotationValue = annotationValue;
$proto.hasAnnotationValue = hasAnnotationValue;
$proto.hasAnnotation = hasAnnotation;
$proto.annotation = annotation;
$proto.hasAnnotations = hasAnnotations;
$type.buildArray = function buildArray(builder) {
const b = this.arrayBuilder();
builder(b);
return b.build();
};
$type.buildMap = function buildMap(builder) {
const b = this.mapBuilder();
builder(b);
return b.build();
};
$type.builder = function builder(inst) { return new $Builder(this, inst); };
Object.defineProperty($type.builder, '$std', { value: true });
$type._instantiate = function _instantiate(fields) {
return this.builder(fields).build();
};
$type.buildSet = function buildSet(builder) {
const b = this.setBuilder();
builder(b);
return b.build();
};
$proto.type = function type() { return $type; };
$proto.log = log;
$proto.withMetadataPath = function(v) { return this.type().builder(this).metadataPath(v).build(); };
$proto.withoutMetadataPath = function() { return this.type().builder(this).metadataPath().build(); };
$proto.withPackage = function(v) { return this.type().builder(this).package(v).build(); };
$proto.withoutPackage = function() { return this.type().builder(this).package().build(); };
$proto.withPackageSubPath = function(v) { return this.type().builder(this).packageSubPath(v).build(); };
$proto.withoutPackageSubPath = function() { return this.type().builder(this).packageSubPath().build(); };
$proto.withPkg = function(v) { return this.type().builder(this).pkg(v).build(); };
$proto.withoutPkg = function() { return this.type().builder(this).pkg().build(); };
$proto.withAnnotationsJson = function(v) { return this.type().builder(this).annotationsJson(v).build(); };
$proto.withoutAnnotationsJson = function() { return this.type().builder(this).annotationsJson().build(); };
$proto.toJSON = function toJSON() { return this.toTypedJson(); };
Object.freeze($type);
Object.freeze($proto);
return $type;
})());
$conn._registerType((function() {
const $init = _deepFreeze({
"type" : "TypeMeta",
"metadataPath" : "platform/src/typesys/type/Documentable.c3typ",
"package" : "platform",
"packageSubPath" : "typesys.type",
"name" : "Documentable",
"doc" : "Metadata objects can have documentation attached. For ones loaded from DSL files, this is generally in the form\nof documentation comments (like this one). During DSL parsing, comments are converted into documentation of the\nstructure they preceded.\n\nFor example, this documentation comes from the comment on the *Documentable* type, declared in `Documentable.c3typ`.\nThe this type declaration in `Documentable.c3typ` looks like:\n```type\n/**\n * Metadata objects can have documentation attached...\n...\ntype Documentable {\n```\n\nThe contents of the comments contain Markdown and JavaDoc/JSDoc style attributes for formatting and links.\nSee {@link documentation-features.c3doc} for details.\n\nAny type that mixes in **Documentable** adds the fields which store documentation. This is true for key\ntype system types such as {@link Type}, {@link FieldType} and {@link MethodType}.\n\nNormally every metadata declaration is expected to be documented with an appropriate documentation comment.\nHowever, it is possible to inherit the documentation using `@inheritdoc`.\n\n```type\n/**\n * @inheritdoc Widget\n *\n * 3-point sprangle widget for partially unexcentric floobs.\n * /\ntype Sprangle mixes Widget, Unexcentric\n```\n\nIn the above example, the Sprangle type will have the documentation from Widget _plus_ its own specific addition.\n\nSee [Documentation Features](documentation-features.c3doc) for details.",
"declaredMixinRefTypes" : [ {
"name" : "HtmlRenderable"
}, {
"name" : "Typesys"
} ],
"declaredFieldTypes" : [ {
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"doc" : "The raw textual documentation associated with this piece of metadata. This will have the original comment\ncharacters removed, but otherwise be a simple block of text with the original formatting retained. Only\ndocumentation comments (starting with `/**`) will be used for this purpose and only when immediately\npreceding the structure they document.",
"name" : "doc",
"valueType" : {
"type" : "StringType",
"name" : "string"
}
}, {
"doc" : "Documentation parsing will produce a structured documentation object from the attributes of the metadata along\nwith the contents of the documentation comment. This can be examined and also rendered for display to the user\nusing {@link DocumentationRenderer}.\n\nIf this is not one of the known metadata types, nor has any documentation associated, the method returns null.\nOtherwise, it will build an object that contains as much as is possible to assemble about the piece of\nstructure, both from the metadata itself and from the text in #docText.\n\n@return parsed documentation object\n\n@see DocumentationParser",
"name" : "docParsed",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "DeclaredReferenceType",
"name" : "DocumentationParserSpec"
}
} ],
"returnType" : {
"type" : "DeclaredReferenceType",
"name" : "Documentation"
},
"member" : true
}
}, {
"doc" : "Rendered markdown document for the Documentable instance.",
"name" : "docMarkdown",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Rendered plain text for the Documentable instance.",
"name" : "docText",
"valueType" : {
"type" : "MethodType",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"member" : true
}
}, {
"doc" : "Whether the specified instances have same documentation.",
"name" : "haveSameDoc",
"valueType" : {
"type" : "MethodType",
"params" : [ {
"name" : "d1",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Documentable"
}
}, {
"name" : "d2",
"valueType" : {
"type" : "DeclaredReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
}, {
"annotationsJson" : [ {
"deprecated" : [ ]
}, {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"name" : "docSingleLine",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "renderer",
"valueType" : {
"type" : "InheritedValueType",
"actionRequirementNames" : [ "java", "js-client" ]
}
} ],
"isWithType" : true,
"isObj" : true,
"isMutable" : false,
"isStateful" : false,
"isSingleton" : false,
"isDefaultInstance" : false,
"isAbstract" : false,
"hasEventStream" : false,
"isGeneric" : false,
"isNativeRemix" : false,
"hasVarBindings" : false,
"prototypeName" : "Documentable",
"typeSerName" : "type",
"hasSerNameFields" : false,
"annotations" : {
"type" : "Annotations"
},
"mixins" : [ "HtmlRenderable", "Value", "Typesys", "WithType", "Obj", "Serializable", "Fingerprintable", "MemoryMeasurable" ],
"referenceType" : {
"type" : "ReferenceType",
"name" : "Documentable"
},
"mixinsWithSourceCode" : {
"js-ide-vscode-client-node" : [ "WithType", "Obj" ]
},
"fieldTypes" : [ {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"doc" : "The metadata path where the parent type's declaration file is located:\nFormat: meta://<package>/[gen|test]/src/<packageSubPath>/<name>.c3typ\nE.g. for the given package folder structure:\n```\nmyRepo\n |\n -  myPkg\n     |\n     -  src\n         |\n         - folder1\n             |\n             - folder2\n                 |\n                 - SomeType1.c3typ\n         - SomeType3.c3typ\n     -  test\n         |\n          - src\n             |\n             - SomeType2.c3typ\n     -  gen\n         |\n          - src\n             |\n             - SomeType4.c3typ\n```\nFor SomeType1.c3typ will return -> meta://myPkg/src/folder1/folder2/SomeType1.c3typ\nFor SomeType3.c3typ will return -> meta://myPkg/src/SomeType3.c3typ\nFor SomeType2.c3typ will return -> meta://myPkg/test/src/SomeType2.c3typ\nFor SomeType4.c3typ will return -> meta://myPkg/gen/src/SomeType4.c3typ\n\n@see #package\n@see #packageSubPath",
"name" : "metadataPath",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"suppress" : true
}
},
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"doc" : "The name of the package where this type was declared.\n\nFor example, if package \"app\", depends on \"industry\", which depends on \"foundation\", provisioning app will bring\nin the types in the industry and foundation packages as well. This means that the `package` of the Location\ntype will be foundation, even if it gets remixed by industry (or even app).\n\n@see #metadataPath\n@see #packageSubPath",
"name" : "package",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"suppress" : true
}
},
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"doc" : "Dot (\".\") separated relative path of the folder where this type's declaration file is located in the package\nE.g. for the given structure\n```\nmyRepo\n |\n -  myPkg\n     |\n     -  src\n         |\n         - folder1\n             |\n             - folder2\n                 |\n                 - SomeType1.c3typ\n         - SomeType3.c3typ\n     -  test\n         |\n          - src\n             |\n             - SomeType2.c3typ\n     -  gen\n         |\n          - src\n             |\n             - SomeType4.c3typ\n```\nFor SomeType1.c3typ will return -> folder1.folder2\nFor SomeType3.c3typ will return -> \"\" (empty string)\nFor SomeType3.c3typ will return -> \"\" (empty string)\nFor SomeType4.c3typ will return -> \"\" (empty string)\n\n@see #metadataPath\n@see #package",
"name" : "packageSubPath",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"suppress" : true
}
},
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"ser" : [ {
"name" : "hidden",
"value" : true
} ]
}, {
"constraint" : [ {
"name" : "readOnly",
"value" : true
} ]
} ],
"doc" : "@return C3 application package this Type System element belongs to",
"name" : "pkg",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"ser" : [ {
"name" : "hidden",
"value" : true
} ]
}, {
"constraint" : [ {
"name" : "readOnly",
"value" : true
} ]
} ],
"annotationJsonByName" : {
"ser" : [ {
"name" : "hidden",
"value" : true
} ],
"constraint" : [ {
"name" : "readOnly",
"value" : true
} ]
},
"constraint" : {
"type" : "Ann.Constraint",
"readOnly" : true
},
"ser" : {
"type" : "Ann.Ser",
"hidden" : true
}
},
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg",
"isNumber" : false,
"instanceType" : "Pkg"
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"doc" : "The raw textual documentation associated with this piece of metadata. This will have the original comment\ncharacters removed, but otherwise be a simple block of text with the original formatting retained. Only\ndocumentation comments (starting with `/**`) will be used for this purpose and only when immediately\npreceding the structure they document.",
"name" : "doc",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"annotationJsonByName" : {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"suppress" : true
}
},
"valueType" : {
"type" : "StringType",
"name" : "string",
"isNumber" : false
}
}, {
"type" : "FieldType",
"annotationsJson" : [ {
"deprecated" : [ ]
}, {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"name" : "docSingleLine",
"hasDefault" : false,
"annotations" : {
"type" : "Annotations",
"annotationsJson" : [ {
"deprecated" : [ ]
}, {
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
} ],
"annotationJsonByName" : {
"deprecated" : [ ],
"dsl" : [ {
"name" : "suppress",
"value" : true
} ]
},
"dsl" : {
"type" : "Ann.Dsl",
"suppress" : true
},
"deprecated" : {
"type" : "Ann.Deprecated"
}
},
"valueType" : {
"type" : "BooleanType",
"name" : "boolean",
"isNumber" : false
}
} ],
"methods" : [ {
"type" : "Method",
"name" : "renderer",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "HtmlRenderer"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Documentable" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Documentable"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return an instance of an {@link HtmlRenderer} set up to render this instance. If there is no capable renderer,\nnull may be returned. The implementation must be available within the browser (typically `js-client`).",
"name" : "renderer",
"returnType" : {
"type" : "ReferenceType",
"name" : "HtmlRenderer"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js-client" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "renderer",
"returnType" : {
"type" : "ReferenceType",
"name" : "HtmlRenderer"
}
},
"$nearestImplementedOn" : "Documentable"
}, {
"type" : "Method",
"name" : "type",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "C3 Type of this instance.",
"name" : "type",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "type",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "replaceType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns new instance with all references to old type, including result of #type, replaced with new type. If new\ntype does not contain fields from old or field value types are not convertable then drops the field.\n\nThis method is used during live metadata update",
"name" : "replaceType",
"params" : [ {
"name" : "old",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "new",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "replaceType",
"params" : [ {
"name" : "old",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "new",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"paramNames" : [ "old", "new" ]
}
}, {
"type" : "Method",
"name" : "super",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "WithType" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "WithType"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : " Produce a calling proxy that represents the content of all Obj type's mixins, but not the type itself. This is\n useful for redispatching **member** methods reimplemented on this type to a parent implementation:\n ```js\n function toString() {\n   return this.super().toString() + ', x=' + this.x;\n }\n ```\n\n ```py\n def toString(this):\n    return this.super().toString() + ', x=' + this.x\n```\n\n To redispatch **static** methods, see {@link Type#super}.\n\n Note that this not the same as the language-specific `super` keyword because it works through the type system and\n supports multiple mixins. It behaves like the Python `super()` function, except called on the instance rather than\n globally.\n\n If `mixin` is the implementing type in a client implementation, this will delegate the call to the server.\n This can be used to create a local implementation \"around\" the server implementation for additional caching or\n other local state management.\n\n @param mixin if specified, this mixin is used instead or an error is thrown\n @return \"super\" calling proxy for this object\n\n @see Type.super",
"name" : "super",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "ReferenceType",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "super",
"params" : [ {
"name" : "mixin",
"valueType" : {
"type" : "ReferenceType",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "NativeType",
"modifier" : "NON_EMPTY"
},
"paramNames" : [ "mixin" ]
},
"$nearestImplementedOn" : "WithType"
}, {
"type" : "Method",
"name" : "toJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a JSON object.\n\n@return JSON object representation\n\n@see #fromJson",
"name" : "toJson",
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"name" : "toJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"name" : "toJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
} ]
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ]
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"paramNames" : [ "include", "exclude" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "toTypedJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a _typed_ JSON object.\n@param omitTopLevelType\n       Whether to leave out `type: {{ type of this serializable instance }}` as the **first** key-value pair in\n       the outer level of the produced json.\n@param runtime\n       If provided, then any special serialization logic required for the {@link ImplLanguage.Runtime} will be\n       performed. **NOTE** This argument is ignored if `typed` is not `true`. @see Ann.Ser\n\n\n@return JSON object representation\n\n@see #fromJson\n@see #toJson\n@see serdeser.c3doc\n@see JsonType",
"name" : "toTypedJson",
"params" : [ {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "actionRequirement",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"name" : "toTypedJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"name" : "toTypedJson",
"params" : [ {
"name" : "include",
"valueType" : {
"type" : "ReferenceType",
"name" : "Include"
}
}, {
"name" : "exclude",
"valueType" : {
"type" : "ReferenceType",
"name" : "Exclude"
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toTypedJson",
"params" : [ {
"name" : "omitTopLevelTypeOrIncludeOrInclude",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Include"
}
}
} ]
}
}, {
"name" : "actionRequirementOrExcludeOrExclude",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Action.Requirement"
}
}
}, {
"valueType" : {
"type" : "StringType",
"name" : "string",
"serRefType" : {
"name" : "Exclude"
}
}
} ]
}
} ],
"returnType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
},
"paramNames" : [ "omitTopLevelTypeOrIncludeOrInclude", "actionRequirementOrExcludeOrExclude" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "toJsonString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toJsonString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized JSON string.\n\n@return JSON object as string",
"name" : "toJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "pretty" ]
}
}, {
"type" : "Method",
"name" : "toTypedJsonString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toTypedJsonString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"name" : "toTypedJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toTypedJsonString",
"params" : [ {
"name" : "pretty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "omitTopLevelType",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "pretty", "omitTopLevelType" ]
}
}, {
"type" : "Method",
"name" : "toJsString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toJsString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized JavaScript object literal.\n\n@return JavaScript object literal string",
"name" : "toJsString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toJsString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "withType" ]
}
}, {
"type" : "Method",
"name" : "toXmlString",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "toXmlString",
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a serialized XML string.\n\n@return XML element as string\n\n@see #fromXmlString",
"name" : "toXmlString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toXmlString",
"params" : [ {
"name" : "withType",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
},
"paramNames" : [ "withType" ]
}
}, {
"type" : "Method",
"name" : "serialize",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Convert the internal object representation to a string serialized representation of the object.\n\n@return string serialized object representation",
"name" : "serialize",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "serialize",
"params" : [ {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"paramNames" : [ "contentType" ]
}
}, {
"type" : "Method",
"name" : "fromJson",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Documentable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the JSON-based representation and reconstruct the corresponding object.\n\nfromJson is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which may be\na type that mixes in the type on which it is called). This means that the resulting object's type will be isA the\ncalled-on type, but perhaps not identical. In particular, `Obj.fromJson` works for any actual type and will return\nan instance of the correct type.\n\n@see #toJson",
"name" : "fromJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Documentable",
"mixing" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Documentable",
"mixing" : true
},
"paramNames" : [ "json" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fromJsonString",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Documentable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the JSON-based representation and reconstruct the corresponding object.\n\nfromJsonString is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which may be\na type that mixes in the type on which it is called). This means that the resulting object's type will be isA the\ncalled-on type, but perhaps not identical. In particular, `Obj.fromJsonString` works for any actual type and will return\nan instance of the correct type.\n\n@see #toJsonString",
"name" : "fromJsonString",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Documentable",
"mixing" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromJsonString",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Documentable",
"mixing" : true
},
"paramNames" : [ "json" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fromXmlString",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Documentable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load the XML-based representation and reconstruct the corresponding object.\n\nfromXmlString is be called on the type be deserialized and must reconstruct an Obj of the appropriate type (which\nmay be a type that mixes in the type on which it is called). This means that the resulting object's type will be\nisA the called type, but perhaps not identical. In particular, `Obj.fromXmlString` works for any actual type and\nwill return an instance of the correct type.\n\n@see #toXmlString",
"name" : "fromXmlString",
"params" : [ {
"name" : "xml",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Documentable",
"mixing" : true
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromXmlString",
"params" : [ {
"name" : "xml",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Documentable",
"mixing" : true
},
"paramNames" : [ "xml" ]
}
}, {
"type" : "Method",
"name" : "deserialize",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Documentable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Load from contentType representation and reconstruct the corresponding object.\n\nfromString is be called on the type be deserialized and must reconstruct an object of the appropriate type\n(which may be a type that mixes in the type on which it is called). This means that the resulting object's type\nwill be isA the called-on type, but perhaps not identical. In particular, `fromString` works for any actual\ntype and will return an instance of the correct type.",
"name" : "deserialize",
"params" : [ {
"name" : "contentStr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Documentable",
"mixing" : true
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "deserialize",
"params" : [ {
"name" : "contentStr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "contentType",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "ContentType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Documentable",
"mixing" : true
},
"paramNames" : [ "contentStr", "contentType" ]
}
}, {
"type" : "Method",
"name" : "fingerprint",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Produce a checksum that can easily be compared to determine if two objects are definitely different. Note that\nthere is a slight possibility that two objects with the same fingerprint will actually differ.\n\nThe fingerprint recurses into field values, including collections and referenced Objs. The handling of nested\n{@link Identified identified} references (typically entities) differ in that _only_ the `id` field is included\nunless the allIdentifiedRefFields option is specified.\n\nIf the object graph may contain recursive embedded object references, the trackRecursiveRefs option may be used.\nHowever, maintaining the list of visited objects is costly so this should not be done unnecessarily.\n\n@param allIdentifiedRefFields\n          if `true`, fingerprint individual fields of persistable references, not just the `id`\n@param trackRecursiveRefs\n          if `true`, a set of referenced objects is maintained to avoid infinite recursion\n@param traversedRefs\n          only considered together with trackRecursiveRefs and if provided then all traversed references are\n          checked against and added to it\n@return integer fingerprint\n\n@see https://en.wikipedia.org/wiki/Fingerprint_(computing)",
"name" : "fingerprint",
"params" : [ {
"name" : "allIdentifiedRefFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "trackRecursiveRefs",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "traversedRefs",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<Obj>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fingerprint",
"params" : [ {
"name" : "allIdentifiedRefFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "trackRecursiveRefs",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "traversedRefs",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<Obj>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"annotationsJson" : [ {
"js" : [ {
"name" : "bigInt",
"value" : true
} ]
} ],
"modifier" : "NON_EMPTY",
"name" : "int"
},
"paramNames" : [ "allIdentifiedRefFields", "trackRecursiveRefs", "traversedRefs" ]
}
}, {
"type" : "Method",
"name" : "retainedMemory",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Measures retained memory by this instance.\n\n@param deep\n       if true and this instance contains references to other objects also measures memory retained by those\n@param allMeasured\n       if set then will skip instances that are in the set and will add instances that where measured by this call\n@return retained memory in bytes for this instances",
"name" : "retainedMemory",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "allMeasured",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<any>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "retainedMemory",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "allMeasured",
"valueType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<any>",
"hadDeclaredVarBindings" : true
}
} ],
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"paramNames" : [ "deep", "allMeasured" ]
}
}, {
"type" : "Method",
"name" : "instanceOf",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Checks whether this Obj is an instance of the specified type by checking both its type and the mixin chain.\nThis is the most convenient way to ask \"is this type usable in a context requiring the other type?\"\n\n@return true if this instance is of this type or any of its mixins",
"name" : "instanceOf",
"params" : [ {
"name" : "typeName",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Checks whether this instance is an instance of the specified type by checking both its type and the mixin chain.\nThis is the most convenient way to ask \"is this type usable in a context requiring the other type?\"\n\n@return true if this instance is of this type or any of its mixins\n\n@see ValueType#isA",
"name" : "instanceOf",
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "instanceOf",
"params" : [ {
"name" : "typeNameOrType",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ]
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "typeNameOrType" ]
}
}, {
"type" : "Method",
"name" : "isEmptyObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether all the fields of this instance are empty.",
"name" : "isEmptyObj",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isEmptyObj",
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "isSame",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether the specified instance represents exactly the same object as this instance.",
"name" : "isSame",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "isSame",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "other" ]
}
}, {
"type" : "Method",
"name" : "fieldValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns value of the given field.\n\n@param field\n          Field to return the value for\n       defaultToEmpty\n          will return default empty value if field is missing",
"name" : "fieldValue",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Returns value of the given field type. Be sure to use the FieldType instance for the exact same type as the type of\nthe obj.\n\n@param field\n          Field to return the value for\n       defaultToEmpty\n          will return default empty value if field is missing\n@return value for the given field",
"name" : "fieldValue",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValue",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
} ]
}
}, {
"name" : "defaultToEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "field", "defaultToEmpty" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fieldValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldValue"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all non empty field values. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValues",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldValue"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValues",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldValue"
}
}
}
}, {
"type" : "Method",
"name" : "fieldValuesByOrdinal",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all field values including empty ones as array where value of a field is at corresponding ordinal position.\nUnless `skipTrailingEmpty` parameter is set and there are trailing empty values resulting array has same size as\n#dataFieldTypes",
"name" : "fieldValuesByOrdinal",
"params" : [ {
"name" : "skipTrailingEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesByOrdinal",
"params" : [ {
"name" : "skipTrailingEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"paramNames" : [ "skipTrailingEmpty" ]
}
}, {
"type" : "Method",
"name" : "fieldValuesByFieldType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all non empty field values by field type. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValuesByFieldType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesByFieldType",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
}
}, {
"type" : "Method",
"name" : "fieldValuesByFieldName",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all non empty field values by field name. Note that it is recommended to use #eachFieldValue instead",
"name" : "fieldValuesByFieldName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesByFieldName",
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}
}, {
"type" : "Method",
"name" : "fieldNames",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Returns all data field names including those whose values are empty. Array is ordered by field ordinal.",
"name" : "fieldNames",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldNames",
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}
}, {
"type" : "Method",
"name" : "at",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Return value of the field at provided ordinal\n\n@param ordinal\n        Integer ordinal of the field in the parent type\n@return value of field at ordinal",
"name" : "at",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "ordinal",
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Return value for the given serialized expression\n\n@param expr\n        Serialized expression to obtain the value in the given Obj\n@param failIfNotValid\n        If set, fails if not a valid expression\n@return value obtained as a result of expression evaluation",
"name" : "at",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "expr",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
}, {
"name" : "failIfNotValid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "at",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "ordinalOrExpr",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "Int32Type",
"modifier" : "NON_EMPTY",
"name" : "int32"
}
}, {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
} ]
}
}, {
"name" : "failIfNotValid",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "ordinalOrExpr", "failIfNotValid" ]
}
}, {
"type" : "Method",
"name" : "fieldValueAtPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Looks up a single field value by path from this Obj. Field paths are separated by dots so an expression like\n`fieldValueAtPath(\"location.elevation\")` is equivalent to `traverse(\"location\").fieldValue(\"elevation\")` except\nthat it also handles `null`. If path contains any collections then only first element will be traversed,\nunless the collection index is specified in the path.\n\nIf you need to traverse all elements of collection fields use #fieldValuesAtPath instead.\n\n@param fieldPath\n          field names separated by dots\n@param failIfNotFound\n          if true, an error will be thrown if the any of the field types aren't defined\n@param context\n          if an error is thrown, the context returned by calling the lambda will be incorporated\n@return the field or null",
"name" : "fieldValueAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValueAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "fieldPath", "failIfNotFound", "context" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fieldValuesAtPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "VarReferenceType",
"name" : "T"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Looks up all the fields by path from root Obj. If path contains any collections then result will contain all\ntraversals, unless the collection index is specified in the path.\n\n@param fieldPath\n          field names separated by dots\n@param failIfNotFound\n          if true, an error will be thrown if the any of the field types aren't defined\n@param context\n          if an error is thrown, the context returned by calling the lambda will be incorporated\n@return fields as a flat list\n\n@see #fieldValueAtPath",
"name" : "fieldValuesAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "VarReferenceType",
"name" : "T"
}
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fieldValuesAtPath",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
}, {
"name" : "failIfNotFound",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "context",
"valueType" : {
"type" : "LambdaType",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "VarReferenceType",
"name" : "T"
}
},
"paramNames" : [ "fieldPath", "failIfNotFound", "context" ]
}
}, {
"type" : "Method",
"name" : "eachFieldValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Perform an action for each non-empty field of this object.\n\n@param action\n          lambda to apply",
"name" : "eachFieldValue",
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Perform an action for each field of this object. Fields are filtered based on provided `spec`.\n\n@param spec\n          which fields to include\n@param action\n          lambda to apply",
"name" : "eachFieldValue",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachFieldValue",
"params" : [ {
"name" : "actionOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ]
}
} ],
"paramNames" : [ "actionOrSpec", "action" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "eachFieldValueWhile",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Perform an action for each field of this object while processing action returns `true`. Fields are filtered based\non provided `spec`.\n\n@param spec\n          which fields to include\n@param action\n          lambda to apply; stop if this `action` returns `false\n@return `true` if iteration was not aborted by lambda i.e. it saw all field values",
"name" : "eachFieldValueWhile",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachFieldValueWhile",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "ValueSpec"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "spec", "action" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "eachRef",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type. For reference fields, this means\nthe field value if non-null and for collections of Obj, this means each element in the collection.\n\n@param action\n          function to be executed for each pair of field type and Obj instance",
"name" : "eachRef",
"params" : [ {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type. For reference fields, this means\nthe field value if non-null and for collections of Obj, this means each element in the collection.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param action\n          function to be executed for each pair of field type and Obj instance",
"name" : "eachRef",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRef",
"params" : [ {
"name" : "actionOrIncludeEmpty",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
}, {
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ]
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"paramNames" : [ "actionOrIncludeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "eachRefWhile",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type while processing action returns\n`true`.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param action\n          function to be executed for each pair of field type and Obj instance; stops processing if return `false`\n@return `true` if iteration was not aborted by lambda i.e. it saw all refs",
"name" : "eachRefWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRefWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "includeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "eachRefRecursive",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type or in any child refs.",
"name" : "eachRefRecursive",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRefRecursive",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ]
}
} ],
"paramNames" : [ "includeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "eachRefRecursiveWhile",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Execute the specified lambda against each referenced Obj instance in this type or in any child refs. Continue while\nprocessing action returns `true`.",
"name" : "eachRefRecursiveWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "eachRefRecursiveWhile",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "action",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldPath"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "includeEmpty", "action" ]
}
}, {
"type" : "Method",
"name" : "mapFieldValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Result of this function call is a copy of current instance with all non empty fields replaced based on results of\nthe `mapper` invocation.\n\n@param action\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValues",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Result of this function call is a copy of current instance with all fields replaced based on results of the\n`mapper` invocation.\n\n@param spec\n          which fields to include\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValues",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapFieldValues",
"params" : [ {
"name" : "mapperOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "convertValueOrMapper",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ]
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"paramNames" : [ "mapperOrSpec", "convertValueOrMapper", "convertValue" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapFieldValuesAsync",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing Documentable>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Result of this function call is a copy of current instance with all non empty fields replaced based on results of\nthe asynchronous `mapper` invocation.\n\n@param action\n          lambda to apply for every field value to produce a new value for that fields\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValuesAsync",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing Documentable>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Result of this function call is a copy of current instance with all fields replaced based on results of the\nasynchronous `mapper` invocation.\n\n@param spec\n          which fields to include\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValuesAsync",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing Documentable>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"name" : "mapFieldValuesAsync",
"params" : [ {
"name" : "mapperOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "convertValueOrMapper",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Promise<any>",
"hadDeclaredVarBindings" : true
}
}
} ]
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Promise<mixing Documentable>",
"hadDeclaredVarBindings" : true
},
"paramNames" : [ "mapperOrSpec", "convertValueOrMapper", "convertValue" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapFieldValue",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Result of this function call is a copy of current instance with specified field value replaced based on result of\nthe `mapper` invocation.\n@param field\n          field being mapped\n@param includeEmpty\n          if set, invokes mapper for fields with empty value\n@param mapper\n          lambda to apply for every field value to produce a new value for that field\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapFieldValue",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapFieldValue",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"paramNames" : [ "field", "includeEmpty", "mapper", "convertValue" ]
}
}, {
"type" : "Method",
"name" : "mapRefs",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Executes the specified lambda against each referenced Obj instance and replaces it's value with result of this\nlambda application.\n\nResult of this function call is a copy of current instance with all references replaced based on results of the\n`mapper` invocation.\n\n@param action\n          function to be executed for each pair of field type and Obj instance\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapRefs",
"params" : [ {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Executes the specified lambda against each referenced Obj instance and replaces it's value with result of this\nlambda application.\n\nResult of this function call is a copy of current instance with all references replaced based on results of the\n`mapper` invocation.\n\n@param includeEmpty\n          if `true` will also process references with `null` / \"Empty\" references\n@param mapper\n          function to be executed for each pair of field type and Obj instance for producing new reference value\n@param convertValue\n          if true, attempt to convert the value to match the field's type",
"name" : "mapRefs",
"params" : [ {
"name" : "includeEmpty",
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
}, {
"name" : "mapper",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapRefs",
"params" : [ {
"name" : "mapperOrIncludeEmpty",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
}, {
"valueType" : {
"type" : "BooleanType",
"modifier" : "NON_EMPTY",
"name" : "boolean"
}
} ]
}
}, {
"name" : "convertValueOrMapper",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "o",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
}
} ]
}
}, {
"name" : "convertValue",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"paramNames" : [ "mapperOrIncludeEmpty", "convertValueOrMapper", "convertValue" ]
}
}, {
"type" : "Method",
"name" : "foldFieldValues",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
},
"kwargsParamIndex" : 1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Result of this function is application of `folder` lambda to every non empty field value where `accumulator`\nargument is a result of previous application. Initial value of `accumulator` will be `null`.\n\nThis function is useful for calculating aggregate values based on all current non empty field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Result of this function is application of `folder` lambda to every non empty field value where `accumulator`\nargument is a result of previous application. Initial value of `accumulator` is provided via `initial` parameter.\n\nThis function is useful for calculating aggregate values based on all current non empty field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "initial",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Result of this function is application of `folder` lambda to every field value where `accumulator` argument is a\nresult of previous application. Initial value of `accumulator` is provided via `initial` parameter.\n\nThis function is useful for calculating aggregate values based on all field values.\nBased on the folder, may return `any` value. (Primitive, Obj, Collection, Any, etc.)\ne.g\n```\no = {a:1, b:2, c:0}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == 0 // Primitive\n\no = {a: {x:1, y:2}, b: {x:10, z:2}}\no.foldFieldValues((ft,value,acc) -> Val.min(acc,value)) == {x:1, y:2, z: 2} // Obj\n```",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "initial",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}, {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "foldFieldValues",
"genericVars" : [ {
"name" : "T"
} ],
"params" : [ {
"name" : "folderOrInitialOrInitial",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
}, {
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ]
}
}, {
"name" : "folderOrSpec",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueSpec"
}
} ]
}
}, {
"name" : "folder",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_EMPTY"
}
}, {
"name" : "accumulator",
"valueType" : {
"type" : "VarReferenceType",
"name" : "T"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "T"
},
"paramNames" : [ "folderOrInitialOrInitial", "folderOrSpec", "folder" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "evalProjection",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "AnyType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Evaluates given projection expression over this instance.",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
}, {
"name" : "resultType",
"valueType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "AnyType"
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Evaluates given projection over this instance and returns results as json.",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "JsonType",
"name" : "json"
},
"inline" : true,
"member" : true,
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Evaluates given projection over this instance and returns results as instance of the new Obj.",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
}, {
"name" : "resultType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
}, {
"name" : "bindings",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Obj"
},
"inline" : true,
"member" : true,
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "evalProjection",
"params" : [ {
"name" : "projection",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "Expr"
}
}
}, {
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_EMPTY",
"name" : "json"
}
} ]
}
}, {
"name" : "resultTypeOrBindingsOrResultType",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"name" : "ValueType"
}
}, {
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
} ]
}
}, {
"name" : "bindingsOrOptionsOrBindings",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ]
}
}, {
"name" : "options",
"valueType" : {
"type" : "ReferenceType",
"name" : "Expr.CompileOptions"
}
} ],
"returnType" : {
"type" : "AnyType"
},
"paramNames" : [ "projection", "resultTypeOrBindingsOrResultType", "bindingsOrOptionsOrBindings", "options" ]
}
}, {
"type" : "Method",
"name" : "validateObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjResult"
}
} ]
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Populates all missing default values and throws error if any constraint it violated.",
"name" : "validateObj",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Validate that the Obj fields are set according to all the required rules.",
"name" : "validateObj",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjSpec"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjResult"
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "validateObj",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjSpec"
}
} ],
"returnType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValidateObjResult"
}
} ]
},
"paramNames" : [ "spec" ]
}
}, {
"type" : "Method",
"name" : "withField",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the provided field in it. The name must correspond to an existing field\ndefined on this type or its mixins. The value must be of the correct type if doNotConvert flag is true.\n\n@param field\n          name of the field\n@param value\n          of the field\n@param doNotConvert\n          if true, do not attempt to convert the value to match the field's type\n@return new Obj",
"name" : "withField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the provided field in it. The name must correspond to an existing field\ndefined on this type or its mixins. The value must be of the correct type if doNotConvert flag is true.\n\n@param field\n          the field\n@param value\n          of the field\n@param doNotConvert\n          if true, do not attempt to convert the value to match the field's type\n@return new Obj",
"name" : "withField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "FieldType"
}
} ]
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"paramNames" : [ "field", "value", "doNotConvert" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "withFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the provided fields in it. The name must correspond to an existing fields\ndefined on this type or its mixins. The values must be of the correct type if doNotConvert flag is true.\n\n@param fields\n          map of fields name/values\n@param doNotConvert\n          if true, attempt to convert the values to match the fields' type\n@return new Obj",
"name" : "withFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyType"
}
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"paramNames" : [ "fields", "doNotConvert" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "withFieldAtPath",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj with the value at the specified path field. If the value is null, the final field is removed.\n\nImmutable objects may return the same instance if the field being set or removed does not actually represent a\nchange to the existing object.\n\n@param path\n          path to set value at\n@param value\n          value to set\n@param doNotConvert\n          if true, attempt to convert the values to match the fields' type\n@param doNotCreateIfMissing\n          true indicates that any empty reference along the path will not set the value\n@return new Obj",
"name" : "withFieldAtPath",
"params" : [ {
"name" : "path",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "doNotCreateIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withFieldAtPath",
"params" : [ {
"name" : "path",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string"
}
}, {
"name" : "value",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "doNotConvert",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "doNotCreateIfMissing",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"paramNames" : [ "path", "value", "doNotConvert", "doNotCreateIfMissing" ]
}
}, {
"type" : "Method",
"name" : "withoutField",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the field with the provided name.\n\nImmutable objects may return the same instance if the field being removed is not present in the existing object.\n\n@param name\n          of the field to remove\n@return new Obj with removed field",
"name" : "withoutField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the field with the provided field type.\n\nImmutable objects may return the same instance if the field being removed is not present in the existing object.\n\n@param field\n          of the field to remove\n@return new Obj with removed field",
"name" : "withoutField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 1
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutField",
"params" : [ {
"name" : "field",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "StringType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "string"
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "FieldType"
}
} ]
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"paramNames" : [ "field" ]
}
}, {
"type" : "Method",
"name" : "withoutFields",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the fields with the provided names.\n\nImmutable objects may return the same instance if the fields being removed are not present in the existing object.\n\n@param names\n          of the fields to remove\n@return new Obj with removed fields",
"name" : "withoutFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "withoutFieldsByType",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj, removing the fields with the provided field types. Be sure to use the FieldType instance for the\nexact same type as the type of the obj to respect the \"ordinal\" of the field type\n\nImmutable objects may return the same instance if the fields being removed are not present in the existing object.\n\n@param fields\n          of the fields to remove\n@return new Obj with removed fields",
"name" : "withoutFieldsByType",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withoutFieldsByType",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "ArrayType",
"modifier" : "NON_OPTIONAL_PARAM",
"elementType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "withDefaults",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Builds a new Obj instance by adding the default values (if defined) for all empty fields. This is implemented by\ncalling {@link FieldType#defaultValue defaultValue} for a field if it is not already set and\n{@link FieldType#hasDefault has a default}. It will also set {@see ValueType#initialValue initial values} for\nfields with required primitive ValueTypes (E.g. x: `!int32` -> will be set to 0). Note that this will not overwrite\nfields that have already been set.\n\n{@link FunctionParam#validateArg} will call {@link #withDefaults} for {@link Spec}s passed as arguments to methods.\nAs a result, methods should be implemented assuming all default values are set on `Spec` arguments.\n\n@param includeEmptyRefsWithDefaults\n          it `true` then missing / empty child references that have fields with defaults will also be instantiated\n@param defaultFields\n          If not empty, a list of default field paths to populate.  Any default fields not specified in the\n          array will be ignored.\n@return new Obj\n\n@see FieldType#defaultValueConst\n@see FieldType#defaultValue",
"name" : "withDefaults",
"params" : [ {
"name" : "includeEmptyRefsWithDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "defaultFields",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "withDefaults",
"params" : [ {
"name" : "includeEmptyRefsWithDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "defaultFields",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"paramNames" : [ "includeEmptyRefsWithDefaults", "defaultFields" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mergeObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Merges all the fields of the provided Obj into this instance, producing a new Obj of the same type as this one.\nIn case of conflicts, fields of other instance take precedence unless otherwise specified by the fieldPathMergeSpec\n\n@param other\n          object\n@param fieldPathMergeSpec\n          mapping of fields of the object to the respective merge annotations\n@return the new merged Obj",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "fieldPathMergeSpec",
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Merges all the fields of the provided Obj into this instance, producing a new Obj of the same type as this one.\nIn case of conflicts, fields of other instance take precedence.\n\n@param other\n          object\n@param otherFieldsFilter\n          only fields of otherFieldsFilter type from other are merged into this obj.\n@return the new merged Obj",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "otherFieldsFilter",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : "Merge the fields of this Obj with corresponding fields on other Obj using the provided lambda. This means that\nfields that exist on other Obj and do not exist on this Obj will not be added to final Obj.\n@param deep\n       if set to true then traverse reference and collection fields and merge corresponding fields or elements with\n       the same key or index.",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 2
}, {
"type" : "MethodType",
"doc" : "Merge the fields of this Obj with corresponding fields on other Obj using the provided lambda. This means that\nfields that exist other Obj and do not exist on this Obj will not be added to final Obj or evaluated. Does not\ntraverse child reference and collection fields.",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 3
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "fieldPathMergeSpecOrOtherFieldsFilterOrDeepOrMerger",
"valueType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "MapType",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ]
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "fp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFp",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldPath"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"paramNames" : [ "other", "fieldPathMergeSpecOrOtherFieldsFilterOrDeepOrMerger", "merger" ]
}
}, {
"type" : "Method",
"name" : "mergeAndExpandObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Create new Obj with all non-null fields of this and other. Fields that are non null in both apply merger lambda.\nFields that non null in only one of this and other will be in the resulting Obj without change.",
"name" : "mergeAndExpandObj",
"genericVars" : [ {
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeAndExpandObj",
"genericVars" : [ {
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "merger",
"valueType" : {
"type" : "LambdaType",
"modifier" : "NON_EMPTY",
"params" : [ {
"name" : "ft",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "v",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "otherFt",
"valueType" : {
"type" : "ReferenceType",
"name" : "FieldType"
}
}, {
"name" : "otherV",
"valueType" : {
"type" : "AnyType"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"name" : "R",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"paramNames" : [ "other", "merger" ]
}
}, {
"type" : "Method",
"name" : "mergeJson",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "mergeJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeJson",
"params" : [ {
"name" : "json",
"valueType" : {
"type" : "JsonType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "json"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"paramNames" : [ "json" ]
}
}, {
"type" : "Method",
"name" : "mergeChildren",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Merge the obj references within the current obj\n@param deep\n       If set, traverses the reference fields within the obj as well for a deep merge\n@param objKey\n       lambda specifying how to obtain the key for the Obj while determining which Objs to merge\n@param filter\n       Field paths that need to be filtered from this merge\n@return Obj with child references merged",
"name" : "mergeChildren",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "objKey",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "child",
"valueType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "filter",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mergeChildren",
"params" : [ {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}, {
"name" : "objKey",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "child",
"valueType" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"returnType" : {
"type" : "AnyType"
}
}
}, {
"name" : "filter",
"valueType" : {
"type" : "LambdaType",
"params" : [ {
"name" : "fieldPath",
"valueType" : {
"type" : "StringType",
"modifier" : "NON_EMPTY",
"name" : "string",
"serRefType" : {
"name" : "FieldPath"
}
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
}
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"paramNames" : [ "deep", "objKey", "filter" ]
}
}, {
"type" : "Method",
"name" : "sumObj",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Adds the numeric Obj fields with the other Objs respective fields.\nIf deep is set it will traverse reference and collection fields and sum corresponding numeric fields in\nreferences with same name and collection elements at same index or key.",
"name" : "sumObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "sumObj",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "deep",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"paramNames" : [ "other", "deep" ]
}
}, {
"type" : "Method",
"name" : "singletonArray",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "Documentable",
"mixing" : true
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Build an array of the correct type with a single element which is this instance.\n\n@return new array instance with this as only element.",
"name" : "singletonArray",
"returnType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "Documentable",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"name" : "singletonArray",
"returnType" : {
"type" : "ArrayType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "Documentable",
"mixing" : true
}
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "array",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Documentable",
"mixing" : true
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an array of instances of this type.",
"name" : "array",
"params" : [ {
"name" : "elements",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Documentable",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "array",
"params" : [ {
"name" : "elements",
"valueType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "AnyType"
}
},
"varArgs" : true
} ],
"returnType" : {
"type" : "ArrayType",
"elementType" : {
"type" : "ReferenceType",
"name" : "Documentable",
"mixing" : true
}
},
"paramNames" : [ "elements" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "arrayBuilder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "ArrayBuilder<mixing Documentable>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an array of instances of this type.",
"name" : "arrayBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "ArrayBuilder<mixing Documentable>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "arrayBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "ArrayBuilder<mixing Documentable>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "singletonSet",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "SetType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "Documentable",
"mixing" : true
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"doc" : "Build an set of the correct type with a single element which is this instance.\n\n@return new array instance with this as only element.",
"name" : "singletonSet",
"returnType" : {
"type" : "SetType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "Documentable",
"mixing" : true
}
},
"final" : true,
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"annotationsJson" : [ {
"java" : [ {
"name" : "returnWildcardVarBindings",
"value" : true
} ]
} ],
"name" : "singletonSet",
"returnType" : {
"type" : "SetType",
"modifier" : "NON_EMPTY",
"elementType" : {
"type" : "ReferenceType",
"name" : "Documentable",
"mixing" : true
}
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "setBuilder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<mixing Documentable>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates a set of instances of this type.",
"name" : "setBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<mixing Documentable>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "setBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "SetBuilder<mixing Documentable>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapBuilder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<string, mixing Documentable>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Create a map of string to elements of this type.",
"name" : "mapBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<string, mixing Documentable>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapBuilder",
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<string, mixing Documentable>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "mapBuilderOf",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<any, mixing Documentable>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Create a map with the given key type and elements of this type.",
"name" : "mapBuilderOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<any, mixing Documentable>",
"hadDeclaredVarBindings" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mapBuilderOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "MapBuilder<any, mixing Documentable>",
"hadDeclaredVarBindings" : true
},
"paramNames" : [ "keyType" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "myReferenceType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myReferenceType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myReferenceType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ReferenceType"
}
}
}, {
"type" : "Method",
"name" : "myMapTypeOf",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myMapTypeOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myMapTypeOf",
"params" : [ {
"name" : "keyType",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ValueType"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"paramNames" : [ "keyType" ]
}
}, {
"type" : "Method",
"name" : "myMapType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myMapType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myMapType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "MapType"
}
}
}, {
"type" : "Method",
"name" : "myArrayType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myArrayType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myArrayType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ArrayType"
}
}
}, {
"type" : "Method",
"name" : "mySetType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "mySetType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "mySetType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "SetType"
}
}
}, {
"type" : "Method",
"name" : "myStreamType",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"name" : "myStreamType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "myStreamType",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "StreamType"
}
}
}, {
"type" : "Method",
"name" : "toBuilder",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing Documentable>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return new ObjBuilder with initial state set to fields of this instance.",
"name" : "toBuilder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing Documentable>",
"hadDeclaredVarBindings" : true
},
"inline" : true,
"member" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toBuilder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing Documentable>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "builder",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing Documentable>",
"hadDeclaredVarBindings" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return new ObjBuilder of this instance.",
"name" : "builder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing Documentable>",
"hadDeclaredVarBindings" : true
},
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "builder",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "ObjBuilder<mixing Documentable>",
"hadDeclaredVarBindings" : true
}
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "fromFields",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type from provided fields\n@param fields\n           Fields to construct the instance of the obj with\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0) populated\n\n@see withDefaults",
"name" : "fromFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java" ],
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "fromFields",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"paramNames" : [ "fields", "withDefaults" ]
}
}, {
"type" : "Method",
"name" : "make",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ "Obj" ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : "Obj"
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : true
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type with no non-default field values unless explicitly specified by passing param true\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0)\n           populated\n\n@see withDefaults",
"name" : "make",
"params" : [ {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 0
}, {
"type" : "MethodType",
"doc" : "Construct an instance from provided fields\n@param fields\n           Fields (in the format <field_name, value>) to construct an instance of the obj. Note that \"type\" as a\n           field_name will be considered as the actual Obj's type, e.g. Obj.make({\"type\": \"Panda\"}) is equivalent\n           to Panda.make()\n@param withDefaults\n           If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32\n           -> 0) populated. Passing an empty value for a field will result in the default field value being set if\n           the field does not {@link ValueModifier#PRESERVES_EMPTY preserve empty} and {@link FieldType#hasDefault\n           has a default value}.\n\n\n@see fromFields\n@see beforeMake\n@see afterMake\n@see withDefaults",
"name" : "make",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "StringType",
"name" : "string"
},
"elementType" : {
"type" : "AnyOfType",
"restrictions" : [ {
"valueType" : {
"type" : "AnyType"
}
}, {
"valueType" : {
"type" : "NativeType"
}
} ]
}
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 1
}, {
"type" : "MethodType",
"doc" : " Construct an instance of this type from provided fields. Note it is more efficient to use #fromFields and other overloads\n\n ```js\n User.make({\n   email: 'joe@smith.com',\n   realName: 'Joe Smith'\n })\n\n Obj.make({\n   type: 'User',\n   email: 'joe@smith.com',\n   realName: 'Joe Smith'\n })\n ```\n\n ```py\n c3.User.make({\n   \"email\": 'joe@smith.com',\n   \"realName\": 'Joe Smith'\n })\n\n c3.Obj.make({\n   \"type\": 'User',\n   \"email\": 'joe@smith.com',\n   \"realName\": 'Joe Smith'\n })\n\n c3.User(email='joe@smith.com', realName='Joe Smith')\n\n c3.Obj(type='User', email='joe@smith.com', realName='Joe Smith')\n```\n\n Note that this is **not** the same as the [serialization format](serdeser.c3doc). This is a convenient way to\n specify fields and values in the \"JSON like\" form supported by each language, but the usual serialization rules,\n such as {@link Ann.Ser} do not apply.\n @param fields\n            Fields to construct the instance of the obj with\n @param withDefaults\n            If set, then the Obj is made with default & initial values (required primitive fields e.g. !int32 -> 0) populated\n\n @see fromFields\n @see beforeMake\n @see afterMake\n @see withDefaults",
"name" : "make",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "AnyType",
"modifier" : "NON_OPTIONAL_PARAM"
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"final" : true,
"inline" : true,
"actionRequirementNames" : [ "java", "js", "py-client" ],
"ordinal" : 2
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "make",
"params" : [ {
"name" : "withDefaultsOrFieldsOrFields",
"valueType" : {
"type" : "AnyType"
}
}, {
"name" : "withDefaults",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"paramNames" : [ "withDefaultsOrFieldsOrFields", "withDefaults" ]
},
"$nearestImplementedOn" : "Obj"
}, {
"type" : "Method",
"name" : "remake",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Construct an instance of this type from provided instance of a subtype or a \"duck type\".",
"name" : "remake",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "failIfExtraOrInvalidFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"final" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "remake",
"params" : [ {
"name" : "other",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Obj"
}
}, {
"name" : "failIfExtraOrInvalidFields",
"valueType" : {
"type" : "BooleanType",
"name" : "boolean"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"paramNames" : [ "other", "failIfExtraOrInvalidFields" ]
}
}, {
"type" : "Method",
"name" : "remakeAs",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an obj of the new type with all fields that exist on the original obj that are defined in the new type\nconverted and copied to the new obj instance. Note, that checking assignability and conversion of field values\ncould be costly if types have different value types for same fields.\n\n@param type\n        Type of new obj to return\n@return new obj of the requested type with all fields present in the original obj that are defined in the new type\n        converted and copied to it",
"name" : "remakeAs",
"genericVars" : [ {
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"final" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "remakeAs",
"genericVars" : [ {
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
} ],
"params" : [ {
"name" : "type",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Type"
}
} ],
"returnType" : {
"type" : "VarReferenceType",
"modifier" : "NON_EMPTY",
"name" : "O",
"restriction" : {
"type" : "ReferenceType",
"name" : "Obj"
}
},
"paramNames" : [ "type" ]
}
}, {
"type" : "Method",
"name" : "beforeMake",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : true,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : false,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Optional override that will be called every time instance of this type is created.\n\n\nNote that it introduces additional overhead so should only be implemented for low volume data.",
"name" : "beforeMake",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"private" : true,
"optional" : true,
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "beforeMake",
"params" : [ {
"name" : "fields",
"valueType" : {
"type" : "MapType",
"modifier" : "NON_OPTIONAL_PARAM",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
}
} ],
"returnType" : {
"type" : "MapType",
"keyType" : {
"type" : "ReferenceType",
"name" : "FieldType"
},
"elementType" : {
"type" : "AnyType"
}
},
"paramNames" : [ "fields" ]
}
}, {
"type" : "Method",
"name" : "afterMake",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : true,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : false,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Optional override that will be called after every instance creation.\n\nNote that it introduces additional overhead so should only be implemented for low volume data.",
"name" : "afterMake",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"private" : true,
"optional" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "afterMake",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
}
}
}, {
"type" : "Method",
"name" : "cachedEmptyInst",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Creates an empty inst using `MyType.make()` and caches it. Avoid recreating multiple copies of the spec for\nevery action dispatch. The cached inst can also be used for comparing whether the object is an empty or not\nWill only create empty instance for immutable Obj e.g. if an Obj is Mutable, this method will throw an error\n\n@see ValueType#defaultEmptyValue",
"name" : "cachedEmptyInst",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "cachedEmptyInst",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable",
"mixing" : true
}
}
}, {
"type" : "Method",
"name" : "toData",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Data"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Represent the current obj instance as {@link Data}",
"name" : "toData",
"returnType" : {
"type" : "ReferenceType",
"name" : "Data"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "toData",
"returnType" : {
"type" : "ReferenceType",
"name" : "Data"
}
}
}, {
"type" : "Method",
"name" : "declaredSrcLine",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : true,
"isProperty" : true,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "Int32Type",
"name" : "int32"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : false,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Source line number in a C3 Type declaration [.c3typ] file starting with 1 where this metadata element is declared.",
"name" : "declaredSrcLine",
"returnType" : {
"type" : "Int32Type",
"name" : "int32"
},
"optional" : true,
"inline" : true,
"member" : true,
"property" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "declaredSrcLine",
"returnType" : {
"type" : "Int32Type",
"name" : "int32"
}
}
}, {
"type" : "Method",
"name" : "declaredSrcCharInLine",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : true,
"isProperty" : true,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "Int32Type",
"name" : "int32"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : false,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Source character position in a line in a C3 Type declaration [.c3typ] file starting with 1 where this metadata\nelement is declared.",
"name" : "declaredSrcCharInLine",
"returnType" : {
"type" : "Int32Type",
"name" : "int32"
},
"optional" : true,
"inline" : true,
"member" : true,
"property" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "declaredSrcCharInLine",
"returnType" : {
"type" : "Int32Type",
"name" : "int32"
}
}
}, {
"type" : "Method",
"name" : "pkgVersion",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Version of the #pkg when this type was built",
"name" : "pkgVersion",
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
},
"private" : true,
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "pkgVersion",
"returnType" : {
"type" : "IntType",
"modifier" : "NON_EMPTY",
"name" : "int"
}
}
}, {
"type" : "Method",
"name" : "typesys",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "@return package for built-in Type System; this could be different from #pkg() when package is loaded from a disk\n        for code gen",
"name" : "typesys",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg"
},
"private" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "typesys",
"returnType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Pkg"
}
}
}, {
"type" : "Method",
"name" : "docParsed",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParam" : {
"type" : "FunctionParam",
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"name" : "DocumentationParserSpec"
}
},
"kwargsParamIndex" : 0,
"mergedReturnType" : {
"type" : "ReferenceType",
"name" : "Documentation"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Documentation parsing will produce a structured documentation object from the attributes of the metadata along\nwith the contents of the documentation comment. This can be examined and also rendered for display to the user\nusing {@link DocumentationRenderer}.\n\nIf this is not one of the known metadata types, nor has any documentation associated, the method returns null.\nOtherwise, it will build an object that contains as much as is possible to assemble about the piece of\nstructure, both from the metadata itself and from the text in #docText.\n\n@return parsed documentation object\n\n@see DocumentationParser",
"name" : "docParsed",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"name" : "DocumentationParserSpec"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Documentation"
},
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "docParsed",
"params" : [ {
"name" : "spec",
"valueType" : {
"type" : "ReferenceType",
"name" : "DocumentationParserSpec"
}
} ],
"returnType" : {
"type" : "ReferenceType",
"name" : "Documentation"
},
"paramNames" : [ "spec" ]
}
}, {
"type" : "Method",
"name" : "docMarkdown",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Rendered markdown document for the Documentable instance.",
"name" : "docMarkdown",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "docMarkdown",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "docText",
"hasAnyStatic" : false,
"hasAnyAbstract" : false,
"hasAnyMember" : true,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : true,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "StringType",
"name" : "string"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Rendered plain text for the Documentable instance.",
"name" : "docText",
"returnType" : {
"type" : "StringType",
"name" : "string"
},
"cached" : true,
"inline" : true,
"member" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "docText",
"returnType" : {
"type" : "StringType",
"name" : "string"
}
}
}, {
"type" : "Method",
"name" : "haveSameDoc",
"hasAnyStatic" : true,
"hasAnyAbstract" : false,
"hasAnyMember" : false,
"hasAnyOptional" : false,
"isProperty" : false,
"isInline" : true,
"isCached" : false,
"cachedFailIfMissing" : false,
"cachedReturnNullIfNotCached" : false,
"kwargsParamIndex" : -1,
"mergedReturnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"annotations" : {
"type" : "Annotations"
},
"hasAnyTargetFunc" : false,
"hasAnyImplementation" : true,
"implementedOn" : {
"js-ide-vscode-client-node" : [ ]
},
"nearestImplementedOn" : {
"js-ide-vscode-client-node" : null
},
"shouldStayInEngine" : {
"js-ide-vscode-client-node" : false
},
"overloads" : [ {
"type" : "MethodType",
"doc" : "Whether the specified instances have same documentation.",
"name" : "haveSameDoc",
"params" : [ {
"name" : "d1",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Documentable"
}
}, {
"name" : "d2",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"inline" : true,
"ordinal" : 0
} ],
"mergeOverloads" : {
"type" : "FunctionType",
"name" : "haveSameDoc",
"params" : [ {
"name" : "d1",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_OPTIONAL_PARAM",
"name" : "Documentable"
}
}, {
"name" : "d2",
"valueType" : {
"type" : "ReferenceType",
"modifier" : "NON_EMPTY",
"name" : "Documentable"
}
} ],
"returnType" : {
"type" : "BooleanType",
"name" : "boolean"
},
"paramNames" : [ "d1", "d2" ]
}
} ],
"hasSourceCode" : {
"js-ide-vscode-client-node" : true
}
});
function renderer() {
return DocumentableRenderer.make({ documentable: this });
}
"use strict";
function $Builder(type, inst) {
let fields = {};
this.$type = type;
this.$setup = function (_inst) {};
this.$findType = function (type, _fields) { return type; };
this.$makeField = function (ft, value) { return value; };
this.$afterMake = function (inst) { return inst; };
if (inst != null) {
Object.keys(inst).forEach(fn => fields[fn] = inst[fn]);
}
Object.defineProperties(this, {
$objType: { value: type },
$onbuild: { value: undefined, writable: true },
$fields: { value: fields, configurable: true },
$refs: { value: {}, configurable: true },
$arrays: { value: {}, configurable: true },
$sets: { value: {}, configurable: true },
$maps: { value: {}, configurable: true },
$builder: { value: true },
});
}
$Builder.prototype.a = function a(field, element, doNotConvert) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isArray()) {
throw Err.invalidCall('ObjBuilder.a', `non-array field ${field.name}`);
}
let b = this.$arrays[field.name];
if (b == null) {
b = this.$fields[field.name];
if (b == null || !b.$builder) {
b = this.$arrays[field.name] = vt.makeBuilder(b);
}
}
if (arguments.length == 1) {
return b;
} else if (arguments.length == 2 || arguments.length == 3) {
b.add(element);
return this;
} else {
throw Err.invalidCall('ObjBuilder.a', 'expected field and element');
}
};
$Builder.prototype.clear = function clear() {
Object.defineProperty(this, '$fields', { value: {}, configurable: true });
Object.defineProperty(this, "$refs", { value: {}, configurable: true });
Object.defineProperty(this, "$arrays", { value: {}, configurable: true });
Object.defineProperty(this, "$sets", { value: {}, configurable: true });
Object.defineProperty(this, "$maps", { value: {}, configurable: true });
};
$Builder.prototype.constrain = function constrain() {
throw new Error('Unsupported operation ObjBuilder.constrain for JavaScript.');
};
$Builder.prototype.current = function current() {
let init = {};
Object.keys(this.$fields).forEach(p => {
let v = this.$fields[p];
if (v != null && v.$builder)
v = v.current();
init[p] = v;
});
return this.$objType.make(init);
};
$Builder.prototype.isEmpty = function isEmpty() {
return Object.keys(this.$fields).length === 0 &&
Object.keys(this.$refs).length === 0 &&
Object.keys(this.$arrays).length === 0 &&
Object.keys(this.$sets).length === 0 &&
Object.keys(this.$maps).length === 0;
};
$Builder.prototype.m = function m(field, key, element, doNotConvert) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isMap()) {
throw new Error(`Invalid call to ObjBuilder.m: non-map field ${field.name}.`);
}
let b = this.$maps[field.name];
if (b == null) {
b = this.$fields[field.name];
if (b == null || !b.$builder) {
b = this.$maps[field.name] = vt.makeBuilder(b);
}
}
if (arguments.length == 1) {
return b;
} else if (arguments.length == 3 || arguments.length == 4) {
b.put(key, element);
return this;
} else {
throw new Error(`Invalid call to ObjBuilder.m: expected field, key and value.`);
}
};
$Builder.prototype.mergeJson = function mergeJson(json) {
if (json != null) {
Object.keys(json).forEach(fn => this.v(fn, json[fn], false));
}
return this;
};
$Builder.prototype.mergeObj = function mergeObj(other, otherFieldsFilter) {
if (other == null) {
return this;
}
if (arguments.length == 1) {
if (this.objType() == other.type()) {
other.eachFieldValue((ft, v) => this.v(ft, v));
} else {
other.eachFieldValue((ft, v) => this.v(this.objType().fieldType(ft.name), v));
}
return this;
} else if (arguments.length == 2) {
if (other.instanceOf(otherFieldsFilter)) {
const tm = otherFieldsFilter.meta();
other.eachFieldValue((ft, v) => {
if (tm.fieldType(ft.name) != null)
this.v(ft, v);
});
}
return this;
}
throw new Error(`Invalid call to ObjBuilder.mergeObj: expected other and otherFieldsFilter.`);
};
$Builder.prototype.objType = function objType() {
return this.$objType;
};
$Builder.prototype.r = function r(field) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isReference()) {
throw new Error(`Invalid call to ObjBuilder.r: non-reference field ${field.name}.`);
}
let type = vt.dereference(true);
let b = this.$refs[field.name];
if (b == null) {
if (b == null || !b.$builder) {
b = this.$refs[field.name] = type.builder().mergeObj(b);
}
}
return b;
};
$Builder.prototype.s = function s(field, element, doNotConvert) {
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
const vt = field.valueType();
if (!vt.isSet()) {
throw Err.invalidCall('ObjBuilder.a', `non-array field ${field.name}`);
}
let b = this.$sets[field.name];
if (b == null) {
b = this.$fields[field.name];
if (b == null || !b.$builder) {
b = this.$sets[field.name] = vt.makeBuilder(b);
}
}
if (arguments.length == 1) {
return b;
} else if (arguments.length == 2 || arguments.length == 3) {
b.add(element);
return this;
} else {
throw Err.invalidCall('ObjBuilder.s', 'expected field and element');
}
};
$Builder.prototype.setFields = function setFields(fields, doNotConvert) {
if (fields != null) {
for (let [name, v] of fields) {
const ft = this.$objType.meta().fieldType(name, true);
if (v == null) {
delete this.$fields[ft.name];
} else {
this.$fields[ft.name] = v;
}
}
}
return this;
};
$Builder.prototype.v = function v(field, value, doNotConvert) {
if (arguments.length < 2) {
throw new Error(`Invalid call to ObjBuilder.v: expected field and value.`);
}
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
this.$fields[field.name] = value;
return this;
};
$Builder.prototype.build = function build() {
const type = this.$findType(this.$type, this.$fields);
let inst = Object.create(type.$objProto);
this.$setup(inst);
Object.keys(this.$refs).forEach(fn => {
this.$fields[fn] = this.$refs[fn].build();
});
Object.keys(this.$arrays).forEach(fn => {
this.$fields[fn] = this.$arrays[fn].build();
});
Object.keys(this.$sets).forEach(fn => {
this.$fields[fn] = this.$sets[fn].build();
});
Object.keys(this.$maps).forEach(fn => {
this.$fields[fn] = this.$maps[fn].build();
});
Object.keys(this.$fields).forEach(fn => {
let ft = type.$init.fieldTypes.find(fieldType => fieldType.name === fn && !fieldType.constant);
if (ft && inst[fn] === undefined && this.$fields[fn] != null) {
inst[fn] = this.$makeField(ft, this.$fields[fn]);
}
});
type.$init.fieldTypes.forEach(ft => {
if (!ft.constant && !_hasOwnProperty(inst, ft.name)) {
let vt = ft.valueType;
if (vt.modifier !== 'PRESERVES_EMPTY') {
let v = this.$makeField(ft, null);
if (v != null) {
inst[ft.name] = v;
}
}
}
});
inst = this.$afterMake(inst);
Object.freeze(inst);
if (this.$onbuild) {
this.$onbuild(inst);
}
return inst;
};
$Builder.prototype.type = function type() { return $type; };
$Builder.prototype.v = function v(field, value, doNotConvert) {
if (arguments.length < 2) {
throw new Error('Invalid call to ObjBuilder.v: expected field and value.');
}
if (typeof field === 'string') {
field = this.$objType.meta().fieldType(field, true);
}
this.$fields[field.name] = value;
return this;
};
$Builder.prototype.metadataPath = function (v) {
if (v == null) {
delete this.$fields.metadataPath;
} else {
this.$fields.metadataPath = v;
}
return this;
};
$Builder.prototype.package = function (v) {
if (v == null) {
delete this.$fields.package;
} else {
this.$fields.package = v;
}
return this;
};
$Builder.prototype.packageSubPath = function (v) {
if (v == null) {
delete this.$fields.packageSubPath;
} else {
this.$fields.packageSubPath = v;
}
return this;
};
$Builder.prototype.pkg = function (v) {
if (v == null) {
delete this.$fields.pkg;
} else {
this.$fields.pkg = v;
}
return this;
};
$Builder.prototype.doc = function (v) {
if (v == null) {
delete this.$fields.doc;
} else {
this.$fields.doc = v;
}
return this;
};
$Builder.prototype.docSingleLine = function (v) {
if (v == null) {
delete this.$fields.docSingleLine;
} else {
this.$fields.docSingleLine = v;
}
return this;
};
let $logger;
function log() {
if ($logger == null) {
$logger = C3.Logger.for($type.name());
}
return $logger;
};
const $type = new Type$Proto($conn, $init);
const $proto = new (function Documentable() {});
Object.defineProperty($proto, '$conn', { value: $conn });
Object.defineProperties($type, {
$objProto: { value: $proto },
$withType: { value: true }
});
Object.defineProperty($type, Symbol.hasInstance, { value: function(inst) { return inst != null && inst.$c3inst && inst.$c3inst.meta().isA(this); } });
$proto.renderer = renderer;
$type.buildArray = function buildArray(builder) {
const b = this.arrayBuilder();
builder(b);
return b.build();
};
$type.buildMap = function buildMap(builder) {
const b = this.mapBuilder();
builder(b);
return b.build();
};
$type.builder = function builder(inst) { return new $Builder(this, inst); };
Object.defineProperty($type.builder, '$std', { value: true });
$type._instantiate = function _instantiate(fields) {
return this.builder(fields).build();
};
$type.buildSet = function buildSet(builder) {
const b = this.setBuilder();
builder(b);
return b.build();
};
$proto.type = function type() { return $type; };
$proto.log = log;
$proto.withMetadataPath = function(v) { return this.type().builder(this).metadataPath(v).build(); };
$proto.withoutMetadataPath = function() { return this.type().builder(this).metadataPath().build(); };
$proto.withPackage = function(v) { return this.type().builder(this).package(v).build(); };
$proto.withoutPackage = function() { return this.type().builder(this).package().build(); };
$proto.withPackageSubPath = function(v) { return this.type().builder(this).packageSubPath(v).build(); };
$proto.withoutPackageSubPath = function() { return this.type().builder(this).packageSubPath().build(); };
$proto.withPkg = function(v) { return this.type().builder(this).pkg(v).build(); };
$proto.withoutPkg = function() { return this.type().builder(this).pkg().build(); };
$proto.withDoc = function(v) { return this.type().builder(this).doc(v).build(); };
$proto.withoutDoc = function() { return this.type().builder(this).doc().build(); };
$proto.withDocSingleLine = function(v) { return this.type().builder(this).docSingleLine(v).build(); };
$proto.withoutDocSingleLine = function() { return this.type().builder(this).docSingleLine().build(); };
$proto.toJSON = function toJSON() { return this.toTypedJson(); };
Object.freeze($type);
Object.freeze($proto);
return $type;
})());
Ctx.bootstrapped = true;
})//# sourceMappingURL=http://localhost:8888/dev/c3/typesys/8/bootstrap.js-ide-vscode-client-node.js.map?tier=FULL
//# sourceURL=http://localhost:8888/dev/c3/typesys/8/bootstrap.js-ide-vscode-client-node.js?tier=FULL